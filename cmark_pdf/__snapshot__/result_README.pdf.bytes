b"%PDF-1.4\x0a%\x80\x81\x82\x83\x0a1 0 obj\x0a<<\x0a  /Type /Catalog  \x0a  /Pages 2 0 R\x0a>>\x0aendobj\x0a2 0 obj\x0a<<\x0a  /Type /Pages  \x0a  /Kids [4 0 R 6 0 R 8 0 R 10 0 R]  \x0a  /Count 4\x0a>>\x0aendobj\x0a3 0 obj\x0a<<\x0a  /Length 546\x0a>>\x0astream\x0a 1 0 0 1 50 770 cm BT /F0 24 Tf 24 TL (Table of Contents)' /F0 12 Tf 12 TL T* (1)' 0 TL 40 0 Td (Moonbit/Core Result) Tj -40 0 Td 12 TL (1.1)' 0 TL 40 0 Td (Overview) Tj -40 0 Td 12 TL (1.2)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (1.2.1)' 0 TL 40 0 Td (Constructing Result) Tj -40 0 Td 12 TL (1.2.2)' 0 TL 40 0 Td (Querying variant) Tj -40 0 Td 12 TL (1.2.3)' 0 TL 40 0 Td (Extracting values) Tj -40 0 Td 12 TL (1.2.4)' 0 TL 40 0 Td (Transforming values) Tj -40 0 Td 12 TL (1.2.5)' 0 TL 40 0 Td (Monadic operations) Tj -40 0 Td 12 TL 36 TL T* ET\x0aendstream\x0aendobj\x0a4 0 obj\x0a<<\x0a  /Type /Page  \x0a  /Contents 3 0 R  \x0a  /Parent 2 0 R  \x0a  /MediaBox [0 0 595.2765 841.89105]  \x0a  /Resources <<\x0a  /Font <<\x0a  /F0 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Roman\x0a>>  \x0a  /F1 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Bold\x0a>>  \x0a  /F2 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Italic\x0a>>  \x0a  /F3 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-BoldItalic\x0a>>  \x0a  /F4 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Courier\x0a>>\x0a>>\x0a>>\x0a>>\x0aendobj\x0a5 0 obj\x0a<<\x0a  /Length 5662\x0a>>\x0astream\x0a 1 0 0 1 50 770 cm BT /F0 24 Tf (Moonbit/Core Result) Tj 24 TL T* 12 TL T* /F0 20 Tf (Overview) Tj 20 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Result[T,E]) Tj /F0 12 Tf ( is a type used for handling computation results and errors in an exp) Tj T* (licit and declarative manner, similar to Rust \x5c() Tj /F0 12 Tf (Result<T,E>) Tj /F0 12 Tf (\x5c) and OCaml \x5c() Tj /F0 12 Tf (\x5c('a, ) Tj T* ('e\x5c) result) Tj /F0 12 Tf (\x5c).) Tj /F0 12 Tf ( ) Tj /F0 12 Tf (It is an enum with two variants: ) Tj /F0 12 Tf (Ok\x5c(T\x5c)) Tj /F0 12 Tf (, which represents succes) Tj T* (s and contains a value of type ) Tj /F0 12 Tf (T) Tj /F0 12 Tf (, and ) Tj /F0 12 Tf (Err\x5c(E\x5c)) Tj /F0 12 Tf (, representing error and containin) Tj T* (g an error value of type ) Tj /F0 12 Tf (E) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F0 20 Tf (Usage) Tj 20 TL T* /F0 16 Tf (Constructing Result) Tj 16 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can create a ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( value using the ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf ( constructors, remember to giv) Tj T* (e proper type annotations.) Tj T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( _result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (42) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( _error) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Err) Tj 0 0 0 rg (\x5c() Tj 1 0 0 rg (\x22Error message\x22) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Or use the ) Tj /F0 12 Tf (ok) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (err) Tj /F0 12 Tf ( functions to create a ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( value.) Tj T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( _result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (String) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( Unit) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 0 rg (\x22yes\x22) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( _error) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Err) Tj 0 0 0 rg (\x5c() Tj 1 0 0 rg (\x22error\x22) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* /F0 16 Tf (Querying variant) Tj 16 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can check the variant of a ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( using the ) Tj /F0 12 Tf (is_ok) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (is_err) Tj /F0 12 Tf ( methods.) Tj T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (42) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( is_ok) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( result) Tj 0 0 1 rg ( is) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (_) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (is_ok) Tj 0 0 0 rg (,) Tj 0 0 1 rg ( true) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( is_err) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( result) Tj 0 0 1 rg ( is) Tj 0 0 0 rg ( Err) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (_) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (7   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (is_err) Tj 0 0 0 rg (,) Tj 0 0 1 rg ( false) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (8   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* /F0 16 Tf (Extracting values) Tj 16 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can extract the value from a ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( using the ) Tj /F0 12 Tf (match) Tj /F0 12 Tf ( expression \x5c(Pattern Mat) Tj T* (ching\x5c).) Tj T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( Unit) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (33) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( val) Tj 0 0 0 rg ( =) Tj 0 0 1 rg ( match) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (    Ok) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (value) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( value) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (    Err) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (_) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( -) Tj 1 0 1 rg (1) Tj 0 0 0 rg () Tj T* 12 TL (7   ) Tj 0 0 0 rg (  }) Tj 0 0 0 rg () Tj T* 12 TL (8   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (val) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 33) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (9   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* ET\x0aendstream\x0aendobj\x0a6 0 obj\x0a<<\x0a  /Type /Page  \x0a  /Contents 5 0 R  \x0a  /Parent 2 0 R  \x0a  /MediaBox [0 0 595.2765 841.89105]  \x0a  /Resources <<\x0a  /Font <<\x0a  /F0 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Roman\x0a>>  \x0a  /F1 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Bold\x0a>>  \x0a  /F2 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Italic\x0a>>  \x0a  /F3 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-BoldItalic\x0a>>  \x0a  /F4 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Courier\x0a>>\x0a>>\x0a>>\x0a>>\x0aendobj\x0a7 0 obj\x0a<<\x0a  /Length 6190\x0a>>\x0astream\x0a 1 0 0 1 50 770 cm BT 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Or using the ) Tj /F0 12 Tf (unwrap) Tj /F0 12 Tf ( method, which will panic if the result is ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf ( and return the) Tj T* ( value if it is ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf (.) Tj T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (42) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( value) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( result) Tj 0 0 0 rg (.unwrap) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (value) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 42) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A safe alternative is the ) Tj /F0 12 Tf (or) Tj /F0 12 Tf ( method, which returns the value if the result is ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf () Tj T* ( or a default value if it is ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf (.) Tj T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Err) Tj 0 0 0 rg (\x5c() Tj 1 0 0 rg (\x22error\x22) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( value) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( result) Tj 0 0 0 rg (.or) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (0) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (value) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 0) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (There is a lazy version of ) Tj /F0 12 Tf (or) Tj /F0 12 Tf ( called ) Tj /F0 12 Tf (or_else) Tj /F0 12 Tf (, which takes a function that return) Tj T* (s a default value.) Tj T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Err) Tj 0 0 0 rg (\x5c() Tj 1 0 0 rg (\x22error\x22) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( value) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( result) Tj 0 0 0 rg (.or_else) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg ( =>) Tj 1 0 1 rg ( 0) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (value) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 0) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* /F0 16 Tf (Transforming values) Tj 16 TL T* 12 TL /F0 12 Tf /F0 12 Tf (To transform values inside a ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf (, you can use the ) Tj /F0 12 Tf (map) Tj /F0 12 Tf ( method, which applies a) Tj T* ( function to the value if the result is ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf (,) Tj /F0 12 Tf ( ) Tj /F0 12 Tf (and remains unchanged if it is ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf (.) Tj T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (42) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( new_result) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( result) Tj 0 0 0 rg (.map) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (x) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( x) Tj 0 0 0 rg ( +) Tj 1 0 1 rg ( 1) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (new_result) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (43) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A dual method to ) Tj /F0 12 Tf (map) Tj /F0 12 Tf ( is ) Tj /F0 12 Tf (map_err) Tj /F0 12 Tf (, which applies a function to the error value if ) Tj T* (the result is ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf (, and remains unchanged if it is ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf (.) Tj T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Err) Tj 0 0 0 rg (\x5c() Tj 1 0 0 rg (\x22error\x22) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( new_result) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( result) Tj 0 0 0 rg (.map_err) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (x) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( x) Tj 0 0 0 rg ( +) Tj 1 0 0 rg ( \x22!\x22) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (new_result) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( Err) Tj 0 0 0 rg (\x5c() Tj 1 0 0 rg (\x22error!\x22) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can turn a ) Tj /F0 12 Tf (Result[T, E]) Tj /F0 12 Tf ( into a ) Tj /F0 12 Tf (Option[T]) Tj /F0 12 Tf ( by using the method ) Tj /F0 12 Tf (to_option) Tj /F0 12 Tf (, whic) Tj T* (h returns ) Tj /F0 12 Tf (Some\x5c(value\x5c)) Tj /F0 12 Tf ( if the result is ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf (, and ) Tj /F0 12 Tf (None) Tj /F0 12 Tf ( if it is ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf (.) Tj T* ET\x0aendstream\x0aendobj\x0a8 0 obj\x0a<<\x0a  /Type /Page  \x0a  /Contents 7 0 R  \x0a  /Parent 2 0 R  \x0a  /MediaBox [0 0 595.2765 841.89105]  \x0a  /Resources <<\x0a  /Font <<\x0a  /F0 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Roman\x0a>>  \x0a  /F1 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Bold\x0a>>  \x0a  /F2 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Italic\x0a>>  \x0a  /F3 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-BoldItalic\x0a>>  \x0a  /F4 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Courier\x0a>>\x0a>>\x0a>>\x0a>>\x0aendobj\x0a9 0 obj\x0a<<\x0a  /Length 4043\x0a>>\x0astream\x0a 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (42) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( option) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( result) Tj 0 0 0 rg (.to_option) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (option) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( Some) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (42) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result1) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Err) Tj 0 0 0 rg (\x5c() Tj 1 0 0 rg (\x22error\x22) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (7   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( option1) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( result1) Tj 0 0 0 rg (.to_option) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (8   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (option1) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( None) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (9   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* /F0 16 Tf (Monadic operations) Tj 16 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Moonbit provides monadic operations for ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf (, such as ) Tj /F0 12 Tf (flatten) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (bind) Tj /F0 12 Tf (, which ) Tj T* (allow chaining of computations that return ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf (.) Tj T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (42) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( flattened) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( result) Tj 0 0 0 rg (.flatten) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (flattened) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (42) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (bind) Tj /F0 12 Tf ( method is similar to ) Tj /F0 12 Tf (map) Tj /F0 12 Tf (, but the function passed to it should return a) Tj T* ( ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( value.) Tj T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Result) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (42) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( new_result) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( result) Tj 0 0 0 rg (.bind) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (x) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (x) Tj 0 0 0 rg ( +) Tj 1 0 1 rg ( 1) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\x5c() Tj 0 0 0 rg (new_result) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( Ok) Tj 0 0 0 rg (\x5c() Tj 1 0 1 rg (43) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg (\x5c)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* ET\x0aendstream\x0aendobj\x0a10 0 obj\x0a<<\x0a  /Type /Page  \x0a  /Contents 9 0 R  \x0a  /Parent 2 0 R  \x0a  /MediaBox [0 0 595.2765 841.89105]  \x0a  /Resources <<\x0a  /Font <<\x0a  /F0 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Roman\x0a>>  \x0a  /F1 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Bold\x0a>>  \x0a  /F2 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-Italic\x0a>>  \x0a  /F3 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Times-BoldItalic\x0a>>  \x0a  /F4 <<\x0a  /Type /Font  \x0a  /Subtype /Type1  \x0a  /BaseFont /Courier\x0a>>\x0a>>\x0a>>\x0a>>\x0aendobj\x0axref\x0a0 11\x0a0000000000 65535 f \x0a0000000055 00000 n\x0d\x0a0000000086 00000 n\x0d\x0a0000000599 00000 n\x0d\x0a0000000521 00000 n\x0d\x0a0000005716 00000 n\x0d\x0a0000000521 00000 n\x0d\x0a0000006244 00000 n\x0d\x0a0000000521 00000 n\x0d\x0a0000004097 00000 n\x0d\x0a0000000522 00000 n\x0d\x0atrailer\x0a<<\x0a  /Size 5  \x0a  /Root 1 0 R\x0a>>\x0astartxref\x0a19177\x0a%%EOF\x0a"
