// Generated using `moon info`, DON'T EDIT IT
package "illusory0x0/pdf/pdf_object_parser"

import(
  "illusory0x0/pdf/types"
  "moonbitlang/core/json"
)

// Values
fn parse(Array[(Token, Position, Position)], initial_pos? : Position) -> @types.Object raise ParseError

fn tokenize(BytesView) -> Array[(Token, Position, Position)]

fn tokenize_pdf_hexadecimal_string(BytesView) -> Bytes

fn tokenize_pdf_literal_string(BytesView) -> (Bytes, Int)

fn tokenize_pdf_name(BytesView) -> (Bytes, Int)

// Errors
pub suberror ParseError {
  UnexpectedToken(Token, (Position, Position), Array[TokenKind])
  UnexpectedEndOfInput(Position, Array[TokenKind])
}

// Types and methods
pub type DICT_BEGIN

pub type DICT_END

pub type EOF

pub type FALSE

pub type GREATER_THAN_SIGN

pub(all) struct INDIRECT {
  object_num : Int
  generation_num : Int
}

pub type LEFT_CURLY_BRACE

pub type LEFT_PARENTHESIS

pub type LEFT_SQUARE_BRACKET

pub type LESS_THAN_SIGN

pub type NULL

pub struct Position {
  row : Int
  col : Int
}
impl Show for Position
impl ToJson for Position
impl @json.FromJson for Position

pub type RIGHT_CURLY_BRACE

pub type RIGHT_PARENTHESIS

pub type RIGHT_SQUARE_BRACKET

pub type SOLIDUS

pub type TRUE

pub(all) enum Token {
  LEFT_PARENTHESIS
  RIGHT_PARENTHESIS
  LEFT_CURLY_BRACE
  RIGHT_CURLY_BRACE
  LEFT_SQUARE_BRACKET
  RIGHT_SQUARE_BRACKET
  LESS_THAN_SIGN
  GREATER_THAN_SIGN
  SOLIDUS
  DICT_BEGIN
  DICT_END
  NULL
  TRUE
  FALSE
  INTEGER(Int)
  REAL(Double)
  STRING(Bytes)
  NAME(Bytes)
  INDIRECT(INDIRECT)
  STREAM_BYTES(Bytes)
  EOF
}
fn Token::kind(Self) -> TokenKind
impl Show for Token

pub(all) enum TokenKind {
  TK_LEFT_PARENTHESIS
  TK_RIGHT_PARENTHESIS
  TK_LEFT_CURLY_BRACE
  TK_RIGHT_CURLY_BRACE
  TK_LEFT_SQUARE_BRACKET
  TK_RIGHT_SQUARE_BRACKET
  TK_LESS_THAN_SIGN
  TK_GREATER_THAN_SIGN
  TK_SOLIDUS
  TK_DICT_BEGIN
  TK_DICT_END
  TK_NULL
  TK_TRUE
  TK_FALSE
  TK_INTEGER
  TK_REAL
  TK_STRING
  TK_NAME
  TK_INDIRECT
  TK_STREAM_BYTES
  TK_EOF
}
impl Eq for TokenKind
impl Show for TokenKind

// Type aliases
pub using @types {type Object as Atom}

pub type DictEntries = Array[(Bytes, @types.Object)]

pub type INTEGER = Int

pub type NAME = Bytes

pub using @types {type Object as PDF_Array}

pub type PDF_ArrayEntries = Array[@types.Object]

pub using @types {type Object as PDF_Dict}

pub using @types {type Object as PDF_Obj}

pub using @types {type Object as PDF_Stream}

pub type REAL = Double

pub type STREAM_BYTES = Bytes

pub type STRING = Bytes

// Traits

