// Generated using `moon info`, DON'T EDIT IT
package "illusory0x0/pdf/pdf_object_parser"

import(
  "illusory0x0/pdf/types"
  "moonbitlang/core/json"
)

// Values
fn parse(Array[(Token, Position, Position)], initial_pos? : Position) -> @types.Object raise ParseError

fn tokenize(BytesView) -> Array[(Token, Position, Position)]

fn tokenize_pdf_hexadecimal_string(BytesView) -> Bytes

fn tokenize_pdf_literal_string(BytesView) -> (Bytes, Int)

fn tokenize_pdf_name(BytesView) -> (Bytes, Int)

// Errors
pub suberror ParseError {
  UnexpectedToken(Token, (Position, Position), Array[TokenKind])
  UnexpectedEndOfInput(Position, Array[TokenKind])
}

// Types and methods
type DICT_BEGIN

type DICT_END

type EOF

type FALSE

type GREATER_THAN_SIGN

type INDIRECT
impl Eq for INDIRECT
impl Show for INDIRECT

type LEFT_CURLY_BRACE

type LEFT_PARENTHESIS

type LEFT_SQUARE_BRACKET

type LESS_THAN_SIGN

type NULL

pub struct Position {
  row : Int
  col : Int
}
impl Show for Position
impl ToJson for Position
impl @json.FromJson for Position

type RIGHT_CURLY_BRACE

type RIGHT_PARENTHESIS

type RIGHT_SQUARE_BRACKET

type SOLIDUS

type TRUE

pub(all) enum Token {
  LEFT_PARENTHESIS
  RIGHT_PARENTHESIS
  LEFT_CURLY_BRACE
  RIGHT_CURLY_BRACE
  LEFT_SQUARE_BRACKET
  RIGHT_SQUARE_BRACKET
  LESS_THAN_SIGN
  GREATER_THAN_SIGN
  SOLIDUS
  DICT_BEGIN
  DICT_END
  NULL
  TRUE
  FALSE
  INTEGER(Int)
  REAL(Double)
  STRING(Bytes)
  NAME(Bytes)
  INDIRECT(INDIRECT)
  STREAM_BYTES(Bytes)
  EOF
}
fn Token::kind(Self) -> TokenKind
impl Show for Token

pub(all) enum TokenKind {
  TK_LEFT_PARENTHESIS
  TK_RIGHT_PARENTHESIS
  TK_LEFT_CURLY_BRACE
  TK_RIGHT_CURLY_BRACE
  TK_LEFT_SQUARE_BRACKET
  TK_RIGHT_SQUARE_BRACKET
  TK_LESS_THAN_SIGN
  TK_GREATER_THAN_SIGN
  TK_SOLIDUS
  TK_DICT_BEGIN
  TK_DICT_END
  TK_NULL
  TK_TRUE
  TK_FALSE
  TK_INTEGER
  TK_REAL
  TK_STRING
  TK_NAME
  TK_INDIRECT
  TK_STREAM_BYTES
  TK_EOF
}
impl Eq for TokenKind
impl Show for TokenKind

// Type aliases

// Traits

