%PDF-1.4
%ÄÅÇÉ
1 0 obj
<<
  /Type /Catalog  
  /Pages 2 0 R
>>
endobj
2 0 obj
<<
  /Type /Pages  
  /Kids [4 0 R 6 0 R 8 0 R 10 0 R 12 0 R 14 0 R 16 0 R 18 0 R 20 0 R 22 0 R 24 0 R 26 0 R 28 0 R 30 0 R 32 0 R 34 0 R 36 0 R 38 0 R 40 0 R 42 0 R 44 0 R 46 0 R 48 0 R 50 0 R 52 0 R 54 0 R 56 0 R 58 0 R 60 0 R 62 0 R 64 0 R 66 0 R 68 0 R 70 0 R 72 0 R 74 0 R 76 0 R 78 0 R 80 0 R 82 0 R 84 0 R 86 0 R 88 0 R 90 0 R 92 0 R 94 0 R 96 0 R 98 0 R 100 0 R 102 0 R 104 0 R 106 0 R 108 0 R 110 0 R 112 0 R 114 0 R 116 0 R 118 0 R 120 0 R 122 0 R 124 0 R 126 0 R 128 0 R 130 0 R 132 0 R 134 0 R 136 0 R 138 0 R 140 0 R 142 0 R 144 0 R 146 0 R 148 0 R 150 0 R 152 0 R 154 0 R 156 0 R 158 0 R 160 0 R 162 0 R 164 0 R 166 0 R 168 0 R 170 0 R 172 0 R 174 0 R 176 0 R 178 0 R 180 0 R 182 0 R 184 0 R 186 0 R 188 0 R 190 0 R 192 0 R 194 0 R 196 0 R 198 0 R 200 0 R 202 0 R 204 0 R 206 0 R 208 0 R 210 0 R 212 0 R 214 0 R 216 0 R 218 0 R 220 0 R 222 0 R 224 0 R 226 0 R 228 0 R 230 0 R 232 0 R 234 0 R 236 0 R 238 0 R 240 0 R 242 0 R 244 0 R 246 0 R 248 0 R 250 0 R 252 0 R 254 0 R 256 0 R 258 0 R 260 0 R 262 0 R 264 0 R 266 0 R 268 0 R 270 0 R 272 0 R 274 0 R 276 0 R 278 0 R 280 0 R 282 0 R 284 0 R 286 0 R]  
  /Count 142
>>
endobj
3 0 obj
<<
  /Length 22622
>>
stream
 1 0 0 1 50 770 cm BT /F0 24 Tf 24 TL (Table of Contents)' /F0 12 Tf 12 TL T* (1)' 0 TL 40 0 Td (Test Package Documentation) Tj -40 0 Td 12 TL (1.1)' 0 TL 40 0 Td (Basic Test Structure) Tj -40 0 Td 12 TL (1.2)' 0 TL 40 0 Td (Assertion Functions) Tj -40 0 Td 12 TL (1.2.1)' 0 TL 40 0 Td (Object Identity Testing) Tj -40 0 Td 12 TL (1.2.2)' 0 TL 40 0 Td (Failure Testing) Tj -40 0 Td 12 TL (1.3)' 0 TL 40 0 Td (Test Output and Logging) Tj -40 0 Td 12 TL (1.4)' 0 TL 40 0 Td (Snapshot Testing) Tj -40 0 Td 12 TL (1.5)' 0 TL 40 0 Td (Advanced Testing Patterns) Tj -40 0 Td 12 TL (1.5.1)' 0 TL 40 0 Td (Testing with Complex Data) Tj -40 0 Td 12 TL (1.5.2)' 0 TL 40 0 Td (Error Condition Testing) Tj -40 0 Td 12 TL (1.5.3)' 0 TL 40 0 Td (Property-Based Testing) Tj -40 0 Td 12 TL (1.6)' 0 TL 40 0 Td (Test Organization) Tj -40 0 Td 12 TL (1.6.1)' 0 TL 40 0 Td (Grouping Related Tests) Tj -40 0 Td 12 TL (1.6.2)' 0 TL 40 0 Td (Setup and Teardown Patterns) Tj -40 0 Td 12 TL (1.7)' 0 TL 40 0 Td (Testing Best Practices) Tj -40 0 Td 12 TL (1.7.1)' 0 TL 40 0 Td (Clear Test Names) Tj -40 0 Td 12 TL (1.7.2)' 0 TL 40 0 Td (One Concept Per Test) Tj -40 0 Td 12 TL (1.7.3)' 0 TL 40 0 Td (Use Meaningful Test Data) Tj -40 0 Td 12 TL (1.8)' 0 TL 40 0 Td (Integration with MoonBit Build System) Tj -40 0 Td 12 TL (1.9)' 0 TL 40 0 Td (Common Testing Patterns) Tj -40 0 Td 12 TL (1.10)' 0 TL 40 0 Td (Performance Considerations) Tj -40 0 Td 12 TL (2)' 0 TL 40 0 Td (byte) Tj -40 0 Td 12 TL (2.1)' 0 TL 40 0 Td (Constants) Tj -40 0 Td 12 TL (2.2)' 0 TL 40 0 Td (Conversion) Tj -40 0 Td 12 TL (2.3)' 0 TL 40 0 Td (Byte Literals) Tj -40 0 Td 12 TL (3)' 0 TL 40 0 Td (Builtin Package Documentation) Tj -40 0 Td 12 TL (3.1)' 0 TL 40 0 Td (Core Types and Functions) Tj -40 0 Td 12 TL (3.1.1)' 0 TL 40 0 Td (Assertions and Testing) Tj -40 0 Td 12 TL (3.1.2)' 0 TL 40 0 Td (Inspect Function) Tj -40 0 Td 12 TL (3.2)' 0 TL 40 0 Td (Result Type) Tj -40 0 Td 12 TL (3.3)' 0 TL 40 0 Td (Option Type) Tj -40 0 Td 12 TL (3.4)' 0 TL 40 0 Td (Iterator Type) Tj -40 0 Td 12 TL (3.5)' 0 TL 40 0 Td (Array and FixedArray) Tj -40 0 Td 12 TL (3.6)' 0 TL 40 0 Td (String Operations) Tj -40 0 Td 12 TL (3.7)' 0 TL 40 0 Td (StringBuilder) Tj -40 0 Td 12 TL (3.8)' 0 TL 40 0 Td (JSON Support) Tj -40 0 Td 12 TL (3.9)' 0 TL 40 0 Td (Comparison Operations) Tj -40 0 Td 12 TL (3.10)' 0 TL 40 0 Td (Utility Functions) Tj -40 0 Td 12 TL (3.11)' 0 TL 40 0 Td (Error Handling) Tj -40 0 Td 12 TL (3.12)' 0 TL 40 0 Td (Best Practices) Tj -40 0 Td 12 TL (3.13)' 0 TL 40 0 Td (Performance Notes) Tj -40 0 Td 12 TL (4)' 0 TL 40 0 Td (HashMap) Tj -40 0 Td 12 TL (5)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (5.1)' 0 TL 40 0 Td (Create) Tj -40 0 Td 12 TL (5.2)' 0 TL 40 0 Td (Set & Get) Tj -40 0 Td 12 TL (5.3)' 0 TL 40 0 Td (Remove) Tj -40 0 Td 12 TL (5.4)' 0 TL 40 0 Td (Contains) Tj -40 0 Td 12 TL (5.5)' 0 TL 40 0 Td (Size & Capacity) Tj -40 0 Td 12 TL (5.6)' 0 TL 40 0 Td (Clear) Tj -40 0 Td 12 TL (5.7)' 0 TL 40 0 Td (Iteration) Tj -40 0 Td 12 TL (6)' 0 TL 40 0 Td (String Package Documentation) Tj -40 0 Td 12 TL (6.1)' 0 TL 40 0 Td (String Creation and Conversion) Tj -40 0 Td 12 TL (6.2)' 0 TL 40 0 Td (String Iteration) Tj -40 0 Td 12 TL (6.3)' 0 TL 40 0 Td (String Conversion) Tj -40 0 Td 12 TL (6.4)' 0 TL 40 0 Td (Unicode Handling) Tj -40 0 Td 12 TL (6.5)' 0 TL 40 0 Td (String Comparison) Tj -40 0 Td 12 TL (6.6)' 0 TL 40 0 Td (String Views) Tj -40 0 Td 12 TL (6.7)' 0 TL 40 0 Td (Practical Examples) Tj -40 0 Td 12 TL (6.8)' 0 TL 40 0 Td (Performance Notes) Tj -40 0 Td 12 TL (7)' 0 TL 40 0 Td (Moonbit/Core Result) Tj -40 0 Td 12 TL (7.1)' 0 TL 40 0 Td (Overview) Tj -40 0 Td 12 TL (7.2)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (7.2.1)' 0 TL 40 0 Td (Constructing Result) Tj -40 0 Td 12 TL (7.2.2)' 0 TL 40 0 Td (Querying variant) Tj -40 0 Td 12 TL (7.2.3)' 0 TL 40 0 Td (Extracting values) Tj -40 0 Td 12 TL (7.2.4)' 0 TL 40 0 Td (Transforming values) Tj -40 0 Td 12 TL (7.2.5)' 0 TL 40 0 Td (Monadic operations) Tj -40 0 Td 12 TL (8)' 0 TL 40 0 Td (uint16) Tj -40 0 Td 12 TL (8.1)' 0 TL 40 0 Td (Constants) Tj -40 0 Td 12 TL (8.2)' 0 TL 40 0 Td (Arithmetic Operations) Tj -40 0 Td 12 TL (8.3)' 0 TL 40 0 Td (Bitwise Operations) Tj -40 0 Td 12 TL (8.4)' 0 TL 40 0 Td (Comparison and Equality) Tj -40 0 Td 12 TL (8.5)' 0 TL 40 0 Td (Default Value and Hashing) Tj -40 0 Td 12 TL (8.6)' 0 TL 40 0 Td (Type Conversions) Tj -40 0 Td 12 TL (9)' 0 TL 40 0 Td (Tuple) Tj -40 0 Td 12 TL (10)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (10.1)' 0 TL 40 0 Td (Create) Tj -40 0 Td 12 TL (10.2)' 0 TL 40 0 Td (Access) Tj -40 0 Td 12 TL (10.3)' 0 TL 40 0 Td (Transformation) Tj -40 0 Td 12 TL (11)' 0 TL 40 0 Td (List) Tj -40 0 Td 12 TL (11.1)' 0 TL 40 0 Td (Table of Contents) Tj -40 0 Td 12 TL (11.2)' 0 TL 40 0 Td (Overview) Tj -40 0 Td 12 TL (11.3)' 0 TL 40 0 Td (Performance) Tj -40 0 Td 12 TL (11.4)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (11.4.1)' 0 TL 40 0 Td (Create) Tj -40 0 Td 12 TL (11.4.2)' 0 TL 40 0 Td (Basic Operations) Tj -40 0 Td 12 TL (11.4.3)' 0 TL 40 0 Td (Prepend) Tj -40 0 Td 12 TL (11.4.4)' 0 TL 40 0 Td (Length) Tj -40 0 Td 12 TL (11.4.5)' 0 TL 40 0 Td (Check if Empty) Tj -40 0 Td 12 TL (11.4.6)' 0 TL 40 0 Td (Access Elements) Tj -40 0 Td 12 TL (11.4.7)' 0 TL 40 0 Td (Head) Tj -40 0 Td 12 TL (11.4.8)' 0 TL 40 0 Td (Tail) Tj -40 0 Td 12 TL (11.4.9)' 0 TL 40 0 Td (Nth Element) Tj -40 0 Td 12 TL (11.4.10)' 0 TL 40 0 Td (Iteration) Tj -40 0 Td 12 TL (11.4.11)' 0 TL 40 0 Td (Each) Tj -40 0 Td 12 TL (11.4.12)' 0 TL 40 0 Td (Map) Tj -40 0 Td 12 TL (11.4.13)' 0 TL 40 0 Td (Filter) Tj -40 0 Td 12 TL (11.4.14)' 0 TL 40 0 Td (Advanced Operations) Tj -40 0 Td 12 TL (11.4.15)' 0 TL 40 0 Td (Reverse) Tj -40 0 Td 12 TL (11.4.16)' 0 TL 40 0 Td (Concatenate) Tj -40 0 Td 12 TL (11.4.17)' 0 TL 40 0 Td (Flatten) Tj -40 0 Td 12 TL (11.4.18)' 0 TL 40 0 Td (Sort) Tj -40 0 Td 12 TL (11.4.19)' 0 TL 40 0 Td (Conversion) Tj -40 0 Td 12 TL (11.4.20)' 0 TL 40 0 Td (To Array) Tj -40 0 Td 12 TL (11.4.21)' 0 TL 40 0 Td (From Array) Tj -40 0 Td 12 TL (11.4.22)' 0 TL 40 0 Td (Equality) Tj -40 0 Td 12 TL (11.5)' 0 TL 40 0 Td (Error Handling Best Practices) Tj -40 0 Td 12 TL (11.5.1)' 0 TL 40 0 Td (Additional Error Cases) Tj -40 0 Td 12 TL (11.6)' 0 TL 40 0 Td (Implementation Notes) Tj -40 0 Td 12 TL (11.7)' 0 TL 40 0 Td (Comparison with Other Collections) Tj -40 0 Td 12 TL (12)' 0 TL 40 0 Td (Priority Queue) Tj -40 0 Td 12 TL (13)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (13.1)' 0 TL 40 0 Td (Create) Tj -40 0 Td 12 TL (13.2)' 0 TL 40 0 Td (Length) Tj -40 0 Td 12 TL (13.3)' 0 TL 40 0 Td (Peek) Tj -40 0 Td 12 TL (13.4)' 0 TL 40 0 Td (Push) Tj -40 0 Td 12 TL (13.5)' 0 TL 40 0 Td (Pop) Tj -40 0 Td 12 TL (13.6)' 0 TL 40 0 Td (Clear) Tj -40 0 Td 12 TL (13.7)' 0 TL 40 0 Td (Copy and Transfer) Tj -40 0 Td 12 TL (14)' 0 TL 40 0 Td (Array Package Documentation) Tj -40 0 Td 12 TL (14.1)' 0 TL 40 0 Td (Creating Arrays) Tj -40 0 Td 12 TL (14.2)' 0 TL 40 0 Td (Array Operations) Tj -40 0 Td 12 TL (14.3)' 0 TL 40 0 Td (Sorting) Tj -40 0 Td 12 TL (14.4)' 0 TL 40 0 Td (Array Views) Tj -40 0 Td 12 TL (14.5)' 0 TL 40 0 Td (Fixed Arrays) Tj -40 0 Td 12 TL (14.6)' 0 TL 40 0 Td (Utilities) Tj -40 0 Td 12 TL (15)' 0 TL 40 0 Td (Sorted Set) Tj -40 0 Td 12 TL (16)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (16.1)' 0 TL 40 0 Td (Create) Tj -40 0 Td 12 TL (16.1.1)' 0 TL 40 0 Td (Container Operations) Tj -40 0 Td 12 TL (16.1.2)' 0 TL 40 0 Td (Set Operations) Tj -40 0 Td 12 TL (16.1.3)' 0 TL 40 0 Td (Stringify) Tj -40 0 Td 12 TL (17)' 0 TL 40 0 Td (int) Tj -40 0 Td 12 TL (17.1)' 0 TL 40 0 Td (Basic Operations) Tj -40 0 Td 12 TL (17.2)' 0 TL 40 0 Td (Byte Conversion) Tj -40 0 Td 12 TL (17.3)' 0 TL 40 0 Td (Method Syntax) Tj -40 0 Td 12 TL (18)' 0 TL 40 0 Td (int64) Tj -40 0 Td 12 TL (18.1)' 0 TL 40 0 Td (Basic Operations) Tj -40 0 Td 12 TL (18.2)' 0 TL 40 0 Td (Binary Representation) Tj -40 0 Td 12 TL (18.3)' 0 TL 40 0 Td (Method-Style Usage) Tj -40 0 Td 12 TL (19)' 0 TL 40 0 Td (unit) Tj -40 0 Td 12 TL (19.1)' 0 TL 40 0 Td (Understanding Unit Type) Tj -40 0 Td 12 TL (19.2)' 0 TL 40 0 Td (Unit Value Creation) Tj -40 0 Td 12 TL (19.3)' 0 TL 40 0 Td (Working with Side-Effect Functions) Tj -40 0 Td 12 TL (19.4)' 0 TL 40 0 Td (String Representation and Debugging) Tj -40 0 Td 12 TL (19.5)' 0 TL 40 0 Td (Generic Programming with Unit) Tj -40 0 Td 12 TL (19.6)' 0 TL 40 0 Td (Built-in Trait Implementations) Tj -40 0 Td 12 TL (19.7)' 0 TL 40 0 Td (Practical Use Cases) Tj -40 0 Td 12 TL (19.7.1)' 0 TL 40 0 Td (Result Accumulation) Tj -40 0 Td 12 TL (19.7.2)' 0 TL 40 0 Td (Builder Pattern Termination) Tj -40 0 Td 12 TL (20)' 0 TL 40 0 Td (BigInt Package Documentation) Tj -40 0 Td 12 TL (20.1)' 0 TL 40 0 Td (Creating BigInt Values) Tj -40 0 Td 12 TL (20.2)' 0 TL 40 0 Td (Basic Arithmetic Operations) Tj -40 0 Td 12 TL (20.3)' 0 TL 40 0 Td (Comparison Operations) Tj -40 0 Td 12 TL (20.4)' 0 TL 40 0 Td (Bitwise Operations) Tj -40 0 Td 12 TL (20.5)' 0 TL 40 0 Td (Power and Modular Arithmetic) Tj -40 0 Td 12 TL (20.6)' 0 TL 40 0 Td (String and Hexadecimal Conversion) Tj -40 0 Td 12 TL (20.7)' 0 TL 40 0 Td (Byte Array Conversion) Tj -40 0 Td 12 TL (20.8)' 0 TL 40 0 Td (Type Conversions) Tj -40 0 Td 12 TL (20.9)' 0 TL 40 0 Td (JSON Serialization) Tj -40 0 Td 12 TL (20.10)' 0 TL 40 0 Td (Utility Functions) Tj -40 0 Td 12 TL (20.11)' 0 TL 40 0 Td (Use Cases and Applications) Tj -40 0 Td 12 TL (20.12)' 0 TL 40 0 Td (Performance Considerations) Tj -40 0 Td 12 TL (20.13)' 0 TL 40 0 Td (Best Practices) Tj -40 0 Td 12 TL (21)' 0 TL 40 0 Td (Bench Package Documentation) Tj -40 0 Td 12 TL (21.1)' 0 TL 40 0 Td (Basic Benchmarking) Tj -40 0 Td 12 TL (21.2)' 0 TL 40 0 Td (Benchmark Collection) Tj -40 0 Td 12 TL (21.3)' 0 TL 40 0 Td (Benchmarking Different Algorithms) Tj -40 0 Td 12 TL (21.4)' 0 TL 40 0 Td (Data Structure Benchmarks) Tj -40 0 Td 12 TL (21.5)' 0 TL 40 0 Td (String Operations Benchmarking) Tj -40 0 Td 12 TL (21.6)' 0 TL 40 0 Td (Memory Usage Prevention) Tj -40 0 Td 12 TL (21.7)' 0 TL 40 0 Td (Iteration Count Control) Tj -40 0 Td 12 TL (21.8)' 0 TL 40 0 Td (Benchmarking Best Practices) Tj -40 0 Td 12 TL (21.8.1)' 0 TL 40 0 Td (1. Isolate What You're Measuring) Tj -40 0 Td 12 TL (21.8.2)' 0 TL 40 0 Td (2. Warm Up Before Measuring) Tj -40 0 Td 12 TL (21.8.3)' 0 TL 40 0 Td (3. Use Meaningful Names) Tj -40 0 Td 12 TL (21.9)' 0 TL 40 0 Td (Performance Analysis) Tj -40 0 Td 12 TL (21.10)' 0 TL 40 0 Td (Integration with Testing) Tj -40 0 Td 12 TL (21.11)' 0 TL 40 0 Td (Common Benchmarking Patterns) Tj -40 0 Td 12 TL (21.12)' 0 TL 40 0 Td (Tips for Accurate Benchmarks) Tj -40 0 Td 12 TL (22)' 0 TL 40 0 Td (cmp) Tj -40 0 Td 12 TL (22.1)' 0 TL 40 0 Td (Generic Comparison Functions) Tj -40 0 Td 12 TL (22.2)' 0 TL 40 0 Td (Comparison by Key) Tj -40 0 Td 12 TL (23)' 0 TL 40 0 Td (math) Tj -40 0 Td 12 TL (23.1)' 0 TL 40 0 Td (Constants) Tj -40 0 Td 12 TL (23.2)' 0 TL 40 0 Td (Basic Arithmetic Functions) Tj -40 0 Td 12 TL (23.2.1)' 0 TL 40 0 Td (Rounding Functions) Tj -40 0 Td 12 TL (23.2.2)' 0 TL 40 0 Td (Exponential and Logarithmic Functions) Tj -40 0 Td 12 TL (23.3)' 0 TL 40 0 Td (Trigonometric Functions) Tj -40 0 Td 12 TL (23.3.1)' 0 TL 40 0 Td (Basic Trigonometric Functions) Tj -40 0 Td 12 TL (23.3.2)' 0 TL 40 0 Td (Hyperbolic Functions) Tj -40 0 Td 12 TL (23.4)' 0 TL 40 0 Td (Special Functions) Tj -40 0 Td 12 TL (23.4.1)' 0 TL 40 0 Td (Two-argument Functions) Tj -40 0 Td 12 TL (24)' 0 TL 40 0 Td (ref) Tj -40 0 Td 12 TL (24.1)' 0 TL 40 0 Td (Creating and Accessing References) Tj -40 0 Td 12 TL (24.2)' 0 TL 40 0 Td (Updating Reference Values) Tj -40 0 Td 12 TL (24.3)' 0 TL 40 0 Td (Mapping References) Tj -40 0 Td 12 TL (24.4)' 0 TL 40 0 Td (Swapping Reference Values) Tj -40 0 Td 12 TL (24.5)' 0 TL 40 0 Td (Temporary Value Protection) Tj -40 0 Td 12 TL (25)' 0 TL 40 0 Td (bytes) Tj -40 0 Td 12 TL (25.1)' 0 TL 40 0 Td (Creating Bytes) Tj -40 0 Td 12 TL (25.2)' 0 TL 40 0 Td (Converting Between Formats) Tj -40 0 Td 12 TL (25.3)' 0 TL 40 0 Td (Working with Views) Tj -40 0 Td 12 TL (25.4)' 0 TL 40 0 Td (Binary Data Interpretation) Tj -40 0 Td 12 TL (25.5)' 0 TL 40 0 Td (Concatenation and Comparison) Tj -40 0 Td 12 TL (26)' 0 TL 40 0 Td (char) Tj -40 0 Td 12 TL (26.1)' 0 TL 40 0 Td (Basic ASCII Classification) Tj -40 0 Td 12 TL (26.2)' 0 TL 40 0 Td (Number Classification) Tj -40 0 Td 12 TL (26.3)' 0 TL 40 0 Td (Special Characters) Tj -40 0 Td 12 TL (26.4)' 0 TL 40 0 Td (Method Style Usage) Tj -40 0 Td 12 TL (27)' 0 TL 40 0 Td (Deque) Tj -40 0 Td 12 TL (28)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (28.1)' 0 TL 40 0 Td (Create) Tj -40 0 Td 12 TL (28.2)' 0 TL 40 0 Td (Length & Capacity) Tj -40 0 Td 12 TL (28.3)' 0 TL 40 0 Td (Front & Back & Get) Tj -40 0 Td 12 TL (28.4)' 0 TL 40 0 Td (Push & Set) Tj -40 0 Td 12 TL (28.5)' 0 TL 40 0 Td (Pop) Tj -40 0 Td 12 TL (28.6)' 0 TL 40 0 Td (Clear) Tj -40 0 Td 12 TL (28.7)' 0 TL 40 0 Td (Equal) Tj -40 0 Td 12 TL (28.8)' 0 TL 40 0 Td (Iter & Map) Tj -40 0 Td 12 TL (28.9)' 0 TL 40 0 Td (Search & Contains) Tj -40 0 Td 12 TL (29)' 0 TL 40 0 Td (Error Package Documentation) Tj -40 0 Td 12 TL (29.1)' 0 TL 40 0 Td (Basic Error Usage) Tj -40 0 Td 12 TL (29.2)' 0 TL 40 0 Td (Custom Error Types) Tj -40 0 Td 12 TL (29.3)' 0 TL 40 0 Td (Error Display and JSON Conversion) Tj -40 0 Td 12 TL (29.4)' 0 TL 40 0 Td (Error Propagation and Handling) Tj -40 0 Td 12 TL (29.5)' 0 TL 40 0 Td (Resource Management with Finally) Tj -40 0 Td 12 TL (29.6)' 0 TL 40 0 Td (Error Composition) Tj -40 0 Td 12 TL (29.7)' 0 TL 40 0 Td (Best Practices) Tj -40 0 Td 12 TL (29.8)' 0 TL 40 0 Td (Performance Notes) Tj -40 0 Td 12 TL (30)' 0 TL 40 0 Td (HashSet) Tj -40 0 Td 12 TL (31)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (31.1)' 0 TL 40 0 Td (Create) Tj -40 0 Td 12 TL (31.2)' 0 TL 40 0 Td (Insert & Contain) Tj -40 0 Td 12 TL (31.3)' 0 TL 40 0 Td (Remove) Tj -40 0 Td 12 TL (31.4)' 0 TL 40 0 Td (Size & Capacity) Tj -40 0 Td 12 TL (31.5)' 0 TL 40 0 Td (Clear) Tj -40 0 Td 12 TL (31.6)' 0 TL 40 0 Td (Iteration) Tj -40 0 Td 12 TL (31.7)' 0 TL 40 0 Td (Set Operations) Tj -40 0 Td 12 TL (32)' 0 TL 40 0 Td (Rational \(DEPRECATED\)) Tj -40 0 Td 12 TL (33)' 0 TL 40 0 Td (bool) Tj -40 0 Td 12 TL (33.1)' 0 TL 40 0 Td (Overview) Tj -40 0 Td 12 TL (33.2)' 0 TL 40 0 Td (Basic Integer Conversion) Tj -40 0 Td 12 TL (33.3)' 0 TL 40 0 Td (Specialized Integer Types) Tj -40 0 Td 12 TL (33.4)' 0 TL 40 0 Td (Practical Use Cases) Tj -40 0 Td 12 TL (33.4.1)' 0 TL 40 0 Td (Boolean Indexing and Selection) Tj -40 0 Td 12 TL (33.4.2)' 0 TL 40 0 Td (Bit Manipulation and Flags) Tj -40 0 Td 12 TL (33.4.3)' 0 TL 40 0 Td (Statistical and Mathematical Operations) Tj -40 0 Td 12 TL (34)' 0 TL 40 0 Td (Coverage Package Documentation) Tj -40 0 Td 12 TL (34.1)' 0 TL 40 0 Td (Coverage Counter) Tj -40 0 Td 12 TL (34.2)' 0 TL 40 0 Td (Tracking Code Execution) Tj -40 0 Td 12 TL (34.3)' 0 TL 40 0 Td (Loop Coverage Tracking) Tj -40 0 Td 12 TL (34.4)' 0 TL 40 0 Td (Function Coverage) Tj -40 0 Td 12 TL (34.5)' 0 TL 40 0 Td (Coverage Analysis) Tj -40 0 Td 12 TL (34.6)' 0 TL 40 0 Td (Integration with Testing) Tj -40 0 Td 12 TL (34.7)' 0 TL 40 0 Td (Coverage Reporting) Tj -40 0 Td 12 TL (34.8)' 0 TL 40 0 Td (Best Practices) Tj -40 0 Td 12 TL (34.8.1)' 0 TL 40 0 Td (1. Automatic Coverage Generation) Tj -40 0 Td 12 TL (34.8.2)' 0 TL 40 0 Td (2. Coverage-Driven Testing) Tj -40 0 Td 12 TL (34.9)' 0 TL 40 0 Td (Integration with Build System) Tj -40 0 Td 12 TL (34.10)' 0 TL 40 0 Td (Performance Considerations) Tj -40 0 Td 12 TL (34.11)' 0 TL 40 0 Td (Common Use Cases) Tj -40 0 Td 12 TL (35)' 0 TL 40 0 Td (MoonBit Float Package Documentation) Tj -40 0 Td 12 TL (35.1)' 0 TL 40 0 Td (Special Values) Tj -40 0 Td 12 TL (35.2)' 0 TL 40 0 Td (Rounding Functions) Tj -40 0 Td 12 TL (35.3)' 0 TL 40 0 Td (Utility Functions) Tj -40 0 Td 12 TL (35.4)' 0 TL 40 0 Td (Byte Representation) Tj -40 0 Td 12 TL (35.5)' 0 TL 40 0 Td (Method Style) Tj -40 0 Td 12 TL (36)' 0 TL 40 0 Td (int16) Tj -40 0 Td 12 TL (36.1)' 0 TL 40 0 Td (Range and Constants) Tj -40 0 Td 12 TL (36.2)' 0 TL 40 0 Td (Arithmetic Operations) Tj -40 0 Td 12 TL (36.3)' 0 TL 40 0 Td (Bitwise Operations) Tj -40 0 Td 12 TL (36.4)' 0 TL 40 0 Td (Comparison Operations) Tj -40 0 Td 12 TL (36.5)' 0 TL 40 0 Td (Default Value) Tj -40 0 Td 12 TL (36.6)' 0 TL 40 0 Td (Type Coercion and Conversion) Tj -40 0 Td 12 TL (37)' 0 TL 40 0 Td (Set Package Documentation) Tj -40 0 Td 12 TL (37.1)' 0 TL 40 0 Td (Creating Sets) Tj -40 0 Td 12 TL (37.2)' 0 TL 40 0 Td (Basic Operations) Tj -40 0 Td 12 TL (37.3)' 0 TL 40 0 Td (Set Operations) Tj -40 0 Td 12 TL (37.4)' 0 TL 40 0 Td (Set Relationships) Tj -40 0 Td 12 TL (37.5)' 0 TL 40 0 Td (Iteration and Conversion) Tj -40 0 Td 12 TL (37.6)' 0 TL 40 0 Td (Modifying Sets) Tj -40 0 Td 12 TL (37.7)' 0 TL 40 0 Td (JSON Serialization) Tj -40 0 Td 12 TL (37.8)' 0 TL 40 0 Td (Working with Different Types) Tj -40 0 Td 12 TL (37.9)' 0 TL 40 0 Td (Performance Examples) Tj -40 0 Td 12 TL (37.10)' 0 TL 40 0 Td (Use Cases) Tj -40 0 Td 12 TL (37.11)' 0 TL 40 0 Td (Performance Characteristics) Tj -40 0 Td 12 TL (37.12)' 0 TL 40 0 Td (Best Practices) Tj -40 0 Td 12 TL (38)' 0 TL 40 0 Td (buffer) Tj -40 0 Td 12 TL (38.1)' 0 TL 40 0 Td (Basic Usage) Tj -40 0 Td 12 TL (38.2)' 0 TL 40 0 Td (Writing Numbers) Tj -40 0 Td 12 TL (38.3)' 0 TL 40 0 Td (Writing Byte Sequences) Tj -40 0 Td 12 TL (38.4)' 0 TL 40 0 Td (Writing Structured Data) Tj -40 0 Td 12 TL (38.5)' 0 TL 40 0 Td (Size Hints) Tj -40 0 Td 12 TL (38.6)' 0 TL 40 0 Td (Buffer as Logger) Tj -40 0 Td 12 TL (38.7)' 0 TL 40 0 Td (Converting to String/Bytes) Tj -40 0 Td 12 TL (38.8)' 0 TL 40 0 Td (Binary Viewing) Tj -40 0 Td 12 TL (39)' 0 TL 40 0 Td (Random) Tj -40 0 Td 12 TL (40)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (41)' 0 TL 40 0 Td (Strconv) Tj -40 0 Td 12 TL (42)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (42.1)' 0 TL 40 0 Td (Parse) Tj -40 0 Td 12 TL (43)' 0 TL 40 0 Td (Option) Tj -40 0 Td 12 TL (44)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (44.1)' 0 TL 40 0 Td (Create) Tj -40 0 Td 12 TL (44.2)' 0 TL 40 0 Td (Extracting values) Tj -40 0 Td 12 TL (44.3)' 0 TL 40 0 Td (Transforming values) Tj -40 0 Td 12 TL (44.4)' 0 TL 40 0 Td (Monadic operations) Tj -40 0 Td 12 TL (45)' 0 TL 40 0 Td (uint64) Tj -40 0 Td 12 TL (45.1)' 0 TL 40 0 Td (Constants) Tj -40 0 Td 12 TL (45.2)' 0 TL 40 0 Td (Arithmetic Operations) Tj -40 0 Td 12 TL (45.3)' 0 TL 40 0 Td (Bitwise Operations) Tj -40 0 Td 12 TL (45.4)' 0 TL 40 0 Td (Comparison and Equality) Tj -40 0 Td 12 TL (45.5)' 0 TL 40 0 Td (Byte Conversion) Tj -40 0 Td 12 TL (45.6)' 0 TL 40 0 Td (Default Value and Hashing) Tj -40 0 Td 12 TL (45.7)' 0 TL 40 0 Td (Type Conversions) Tj -40 0 Td 12 TL (45.8)' 0 TL 40 0 Td (Working with Large Numbers) Tj -40 0 Td 12 TL (45.9)' 0 TL 40 0 Td (Working with Hexadecimal Literals) Tj -40 0 Td 12 TL (46)' 0 TL 40 0 Td (Queue) Tj -40 0 Td 12 TL (47)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (47.1)' 0 TL 40 0 Td (Create and Clear) Tj -40 0 Td 12 TL (47.2)' 0 TL 40 0 Td (Length) Tj -40 0 Td 12 TL (47.3)' 0 TL 40 0 Td (Pop and Push) Tj -40 0 Td 12 TL (47.4)' 0 TL 40 0 Td (Peek) Tj -40 0 Td 12 TL (47.5)' 0 TL 40 0 Td (Traverse) Tj -40 0 Td 12 TL (47.6)' 0 TL 40 0 Td (Copy and Transfer) Tj -40 0 Td 12 TL (48)' 0 TL 40 0 Td (double) Tj -40 0 Td 12 TL (48.1)' 0 TL 40 0 Td (Constants and Special Values) Tj -40 0 Td 12 TL (48.2)' 0 TL 40 0 Td (Basic Operations) Tj -40 0 Td 12 TL (48.3)' 0 TL 40 0 Td (Special Value Testing) Tj -40 0 Td 12 TL (48.4)' 0 TL 40 0 Td (Binary Representation) Tj -40 0 Td 12 TL (49)' 0 TL 40 0 Td (Sorted Map) Tj -40 0 Td 12 TL (49.1)' 0 TL 40 0 Td (Overview) Tj -40 0 Td 12 TL (49.2)' 0 TL 40 0 Td (Performance) Tj -40 0 Td 12 TL (49.3)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (49.3.1)' 0 TL 40 0 Td (Create) Tj -40 0 Td 12 TL (49.3.2)' 0 TL 40 0 Td (Container Operations) Tj -40 0 Td 12 TL (49.3.3)' 0 TL 40 0 Td (Data Extraction) Tj -40 0 Td 12 TL (49.3.4)' 0 TL 40 0 Td (Range Operations) Tj -40 0 Td 12 TL (49.3.5)' 0 TL 40 0 Td (Iterators) Tj -40 0 Td 12 TL (49.3.6)' 0 TL 40 0 Td (Equality) Tj -40 0 Td 12 TL (49.3.7)' 0 TL 40 0 Td (Error Handling Best Practices) Tj -40 0 Td 12 TL (49.4)' 0 TL 40 0 Td (Implementation Notes) Tj -40 0 Td 12 TL (49.5)' 0 TL 40 0 Td (Comparison with Other Collections) Tj -40 0 Td 12 TL (50)' 0 TL 40 0 Td (MoonBit QuickCheck Package) Tj -40 0 Td 12 TL (50.1)' 0 TL 40 0 Td (Basic Usage) Tj -40 0 Td 12 TL (50.2)' 0 TL 40 0 Td (Multiple Samples) Tj -40 0 Td 12 TL (50.3)' 0 TL 40 0 Td (Built-in Types) Tj -40 0 Td 12 TL (50.4)' 0 TL 40 0 Td (Custom Types) Tj -40 0 Td 12 TL (51)' 0 TL 40 0 Td (uint) Tj -40 0 Td 12 TL (51.1)' 0 TL 40 0 Td (Basic Properties) Tj -40 0 Td 12 TL (51.2)' 0 TL 40 0 Td (Byte Representation) Tj -40 0 Td 12 TL (51.3)' 0 TL 40 0 Td (Converting to Other Number Types) Tj -40 0 Td 12 TL (52)' 0 TL 40 0 Td (json) Tj -40 0 Td 12 TL (52.1)' 0 TL 40 0 Td (Basic JSON Operations) Tj -40 0 Td 12 TL (52.1.1)' 0 TL 40 0 Td (Parsing and Validating JSON) Tj -40 0 Td 12 TL (52.1.2)' 0 TL 40 0 Td (Object Navigation) Tj -40 0 Td 12 TL (52.1.3)' 0 TL 40 0 Td (Array Navigation) Tj -40 0 Td 12 TL (52.2)' 0 TL 40 0 Td (Type-Safe JSON Conversion) Tj -40 0 Td 12 TL (52.2.1)' 0 TL 40 0 Td (From JSON to Native Types) Tj -40 0 Td 12 TL (52.2.2)' 0 TL 40 0 Td (Error Handling with JSON Path) Tj -40 0 Td 12 TL (52.3)' 0 TL 40 0 Td (JSON-based Snapshot Testing) Tj -40 0 Td 12 TL (53)' 0 TL 40 0 Td (Env Package Documentation) Tj -40 0 Td 12 TL (53.1)' 0 TL 40 0 Td (Command Line Arguments) Tj -40 0 Td 12 TL (53.2)' 0 TL 40 0 Td (Current Time) Tj -40 0 Td 12 TL (53.3)' 0 TL 40 0 Td (Working Directory) Tj -40 0 Td 12 TL (53.4)' 0 TL 40 0 Td (Practical Usage Examples) Tj -40 0 Td 12 TL (53.4.1)' 0 TL 40 0 Td (Command Line Tool Pattern) Tj -40 0 Td 12 TL (53.4.2)' 0 TL 40 0 Td (Configuration Loading) Tj -40 0 Td 12 TL (53.4.3)' 0 TL 40 0 Td (Logging with Timestamps) Tj -40 0 Td 12 TL (53.4.4)' 0 TL 40 0 Td (File Path Operations) Tj -40 0 Td 12 TL (53.5)' 0 TL 40 0 Td (Platform Differences) Tj -40 0 Td 12 TL (53.5.1)' 0 TL 40 0 Td (JavaScript Environment) Tj -40 0 Td 12 TL (53.5.2)' 0 TL 40 0 Td (WebAssembly Environment) Tj -40 0 Td 12 TL (53.5.3)' 0 TL 40 0 Td (Native Environment) Tj -40 0 Td 12 TL (53.6)' 0 TL 40 0 Td (Error Handling) Tj -40 0 Td 12 TL (53.7)' 0 TL 40 0 Td (Best Practices) Tj -40 0 Td 12 TL (53.7.1)' 0 TL 40 0 Td (1. Handle Missing Environment Data Gracefully) Tj -40 0 Td 12 TL (53.7.2)' 0 TL 40 0 Td (2. Validate Command Line Arguments) Tj -40 0 Td 12 TL (53.7.3)' 0 TL 40 0 Td (3. Use Timestamps for Unique Identifiers) Tj -40 0 Td 12 TL (53.8)' 0 TL 40 0 Td (Common Use Cases) Tj -40 0 Td 12 TL (53.9)' 0 TL 40 0 Td (Performance Considerations) Tj -40 0 Td 12 TL 36 TL T* ET
endstream
endobj
4 0 obj
<<
  /Type /Page  
  /Contents 3 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
5 0 obj
<<
  /Length 1349
>>
stream
 1 0 0 1 50 770 cm BT /F0 24 Tf (Test Package Documentation) Tj 24 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (hello) Tj T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (moonbit) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (test) Tj T* -10 0 Td 12 TL T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (world) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides testing utilities and assertion functions for MoonBit prog) Tj T* (rams. It includes functions for comparing values, checking object identity, and ) Tj T* (creating structured test outputs with snapshot testing capabilities.) Tj T* 12 TL T* /F0 20 Tf (Basic Test Structure) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (MoonBit tests are written using the ) Tj /F0 12 Tf (test) Tj /F0 12 Tf ( keyword:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "basic test example" {)' 12 TL (3     let result = 2 + 2)' 12 TL (4     inspect\(result, content="4"\))' 12 TL (5   )' 12 TL (6     // Test passes if no errors are raised)' 12 TL (7   })' T* 12 TL T* /F0 20 Tf (Assertion Functions) Tj 20 TL T* 12 TL T* /F0 16 Tf (Object Identity Testing) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Test whether two values refer to the same object in memory:) Tj T* 12 TL T* ET
endstream
endobj
6 0 obj
<<
  /Type /Page  
  /Contents 5 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
7 0 obj
<<
  /Length 1597
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "object identity" {)' 12 TL (3     let str1 = "hello")' 12 TL (4     let _str2 = "hello")' 12 TL (5     let str3 = str1)' 12 TL (6   )' 12 TL (7     // Same object reference)' 12 TL (8     @test.same_object\(str1, str3\) // Passes - same reference)' 12 TL (9   )' 12 TL (10    // Different objects \(even if equal values\))' 12 TL (11  )' 12 TL (12    // @test.is_not\(str1, str2\))' 12 TL (13    // May or may not pass - different string objects)' 12 TL (14    // depend on how compiler optimization works)' 12 TL (15    // here we interned)' 12 TL (16  )' 12 TL (17    // Arrays and object identity)' 12 TL (18    let arr1 = [1, 2, 3])' 12 TL (19    let _arr2 = [1, 2, 3])' 12 TL (20    let arr3 = arr1)' 12 TL (21    @test.same_object\(arr1, arr3\) // Passes - same array reference @test.is_not\(arr1, arr2\) // Passes - different array objects)' 12 TL (22  })' T* 12 TL T* /F0 16 Tf (Failure Testing) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Explicitly fail tests with custom messages:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "conditional failure" {)' 12 TL (3     let value = 10)' 12 TL (4     if value < 0 {)' 12 TL (5       @test.fail\("Value should not be negative: \\{value}"\))' 12 TL (6     })' 12 TL (7   )' 12 TL (8     // Test continues if condition is not met)' 12 TL (9     inspect\(value, content="10"\))' 12 TL (10  })' T* 12 TL T* /F0 20 Tf (Test Output and Logging) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Create structured test outputs using the Test type:) Tj T* 12 TL T* ET
endstream
endobj
8 0 obj
<<
  /Type /Page  
  /Contents 7 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
9 0 obj
<<
  /Length 2061
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "test output" {)' 12 TL (3     let t = @test.new\("Example Test"\))' 12 TL (4   )' 12 TL (5     // Write output to test buffer)' 12 TL (6     t.write\("Testing basic functionality: "\))' 12 TL (7     t.writeln\("PASS"\))' 12 TL (8   )' 12 TL (9     // Write multiple lines)' 12 TL (10    t.writeln\("Step 1: Initialize data"\))' 12 TL (11    t.writeln\("Step 2: Process data"\))' 12 TL (12    t.writeln\("Step 3: Verify results"\))' 12 TL (13  )' 12 TL (14    // The test output is captured for reporting)' 12 TL (15  })' T* 12 TL T* /F0 20 Tf (Snapshot Testing) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Compare test outputs against saved snapshots:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "snapshot testing" {)' 12 TL (3     let t = @test.new\("Snapshot Test"\))' 12 TL (4   )' 12 TL (5     // Generate some output)' 12 TL (6     t.writeln\("Current timestamp: 2024-01-01"\))' 12 TL (7     t.writeln\("Processing items: [1, 2, 3, 4, 5]"\))' 12 TL (8     t.writeln\("Result: SUCCESS"\))' 12 TL (9   )' 12 TL (10    // Compare against snapshot file)' 12 TL (11    // This will create or update a snapshot file)' 12 TL (12    t.snapshot\(filename="test_output"\))' 12 TL (13  })' T* 12 TL T* /F0 20 Tf (Advanced Testing Patterns) Tj 20 TL T* 12 TL T* /F0 16 Tf (Testing with Complex Data) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Test functions that work with complex data structures:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "complex data testing" {)' 12 TL (3     // Test with arrays)' 12 TL (4     let numbers = [1, 2, 3, 4, 5])' 12 TL (5     let doubled = numbers.map\(fn\(x\) { x * 2 }\))' 12 TL (6     inspect\(doubled, content="[2, 4, 6, 8, 10]"\))' 12 TL (7   )' 12 TL (8     // Test with tuples \(simpler than custom structs in test examples\))' 12 TL (9     let person_data = \("Alice", 30\))' 12 TL (10    inspect\(person_data.0, content="Alice"\))' 12 TL (11    inspect\(person_data.1, content="30"\))' 12 TL (12  })' T* 12 TL T* ET
endstream
endobj
10 0 obj
<<
  /Type /Page  
  /Contents 9 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
11 0 obj
<<
  /Length 1817
>>
stream
 1 0 0 1 50 770 cm BT /F0 16 Tf (Error Condition Testing) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Test that functions properly handle error conditions:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "error handling" {)' 12 TL (3     fn safe_divide\(a : Int, b : Int\) -> Int? {)' 12 TL (4       if b == 0 {)' 12 TL (5         None)' 12 TL (6       } else {)' 12 TL (7         Some\(a / b\))' 12 TL (8       })' 12 TL (9     })' 12 TL (10  )' 12 TL (11    // Test normal case)' 12 TL (12    let result = safe_divide\(10, 2\))' 12 TL (13    inspect\(result, content="Some\(5\)"\))' 12 TL (14  )' 12 TL (15    // Test error case)' 12 TL (16    let error_result = safe_divide\(10, 0\))' 12 TL (17    inspect\(error_result, content="None"\))' 12 TL (18  })' T* 12 TL T* /F0 16 Tf (Property-Based Testing) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Test properties that should hold for various inputs:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "property testing" {)' 12 TL (3     fn is_even\(n : Int\) -> Bool {)' 12 TL (4       n % 2 == 0)' 12 TL (5     })' 12 TL (6   )' 12 TL (7     // Test the property with multiple values)' 12 TL (8     let test_values = [0, 2, 4, 6, 8, 10])' 12 TL (9     for value in test_values {)' 12 TL (10      if not\(is_even\(value\)\) {)' 12 TL (11        @test.fail\("Expected \\{value} to be even"\))' 12 TL (12      })' 12 TL (13    })' 12 TL (14  )' 12 TL (15    // Test negative cases)' 12 TL (16    let odd_values = [1, 3, 5, 7, 9])' 12 TL (17    for value in odd_values {)' 12 TL (18      if is_even\(value\) {)' 12 TL (19        @test.fail\("Expected \\{value} to be odd"\))' 12 TL (20      })' 12 TL (21    })' 12 TL (22  })' T* 12 TL T* /F0 20 Tf (Test Organization) Tj 20 TL T* 12 TL T* /F0 16 Tf (Grouping Related Tests) Tj 16 TL T* ET
endstream
endobj
12 0 obj
<<
  /Type /Page  
  /Contents 11 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
13 0 obj
<<
  /Length 1805
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use descriptive test names to group related functionality:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "string operations - concatenation" {)' 12 TL (3     let result = "hello" + " " + "world")' 12 TL (4     inspect\(result, content="hello world"\))' 12 TL (5   })' 12 TL (6   )' 12 TL (7   ///|)' 12 TL (8   test "string operations - length" {)' 12 TL (9     let text = "MoonBit")' 12 TL (10    inspect\(text.length\(\), content="7"\))' 12 TL (11  })' 12 TL (12  )' 12 TL (13  ///|)' 12 TL (14  test "string operations - substring" {)' 12 TL (15    let text = "Hello, World!")' 12 TL (16    let sub = text.length\(\) // Just test length instead of substring)' 12 TL (17    inspect\(sub, content="13"\))' 12 TL (18  })' T* 12 TL T* /F0 16 Tf (Setup and Teardown Patterns) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Create helper functions for common test setup:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "with setup helper" {)' 12 TL (3     fn setup_test_data\(\) -> Array[Int] {)' 12 TL (4       [10, 20, 30, 40, 50])' 12 TL (5     })' 12 TL (6   )' 12 TL (7     fn cleanup_test_data\(_data : Array[Int]\) -> Unit {)' 12 TL (8       // Cleanup logic here)' 12 TL (9     })' 12 TL (10  )' 12 TL (11    let data = setup_test_data\(\))' 12 TL (12  )' 12 TL (13    // Perform tests)' 12 TL (14    inspect\(data.length\(\), content="5"\))' 12 TL (15    inspect\(data[0], content="10"\))' 12 TL (16    inspect\(data[4], content="50"\))' 12 TL (17    cleanup_test_data\(data\))' 12 TL (18  })' T* 12 TL T* /F0 20 Tf (Testing Best Practices) Tj 20 TL T* 12 TL T* /F0 16 Tf (Clear Test Names) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use descriptive names that explain what is being tested:) Tj T* 12 TL T* ET
endstream
endobj
14 0 obj
<<
  /Type /Page  
  /Contents 13 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
15 0 obj
<<
  /Length 1973
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "user_can_login_with_valid_credentials" {)' 12 TL (3     // Test implementation)' 12 TL (4   })' 12 TL (5   )' 12 TL (6   ///|)' 12 TL (7   test "login_fails_with_invalid_password" {)' 12 TL (8     // Test implementation  )' 12 TL (9   })' 12 TL (10  )' 12 TL (11  ///|)' 12 TL (12  test "shopping_cart_calculates_total_correctly" {)' 12 TL (13    // Test implementation)' 12 TL (14  })' T* 12 TL T* /F0 16 Tf (One Concept Per Test) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Keep tests focused on a single concept:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   ///  Good - tests one specific behavior)' 12 TL (3   test "array_push_increases_length" {)' 12 TL (4     let arr = Array::new\(\))' 12 TL (5     let initial_length = arr.length\(\))' 12 TL (6     arr.push\(42\))' 12 TL (7     let new_length = arr.length\(\))' 12 TL (8     inspect\(new_length, content="\\{initial_length + 1}"\))' 12 TL (9   })' 12 TL (10  )' 12 TL (11  ///|)' 12 TL (12  ///  Good - tests another specific behavior)' 12 TL (13  test "array_push_adds_element_at_end" {)' 12 TL (14    let arr = Array::new\(\))' 12 TL (15    arr.push\(10\))' 12 TL (16    arr.push\(20\))' 12 TL (17    inspect\(arr[arr.length\(\) - 1], content="20"\))' 12 TL (18  })' T* 12 TL T* /F0 16 Tf (Use Meaningful Test Data) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Choose test data that makes the test's intent clear:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "tax_calculation_for_standard_rate" {)' 12 TL (3     let price = 100)' 12 TL (4     let tax_rate = 8 // 8% tax as integer percentage)' 12 TL (5     let calculated_tax = price * tax_rate / 100)' 12 TL (6     inspect\(calculated_tax, content="8"\))' 12 TL (7   })' T* 12 TL T* /F0 20 Tf (Integration with MoonBit Build System) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Tests are automatically discovered and run by the MoonBit build system:) Tj T* ET
endstream
endobj
16 0 obj
<<
  /Type /Page  
  /Contents 15 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
17 0 obj
<<
  /Length 2895
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Use ) Tj /F0 12 Tf (moon test) Tj /F0 12 Tf ( to run all tests) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Use ) Tj /F0 12 Tf (moon test --update) Tj /F0 12 Tf ( to update snapshots) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Tests in ) Tj /F0 12 Tf (*_test.mbt) Tj /F0 12 Tf ( files are blackbox tests) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Tests in regular ) Tj /F0 12 Tf (.mbt) Tj /F0 12 Tf ( files are whitebox tests) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Common Testing Patterns) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Arrange-Act-Assert) Tj /F0 12 Tf (: Set up data, perform operation, verify result) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Given-When-Then) Tj /F0 12 Tf (: Given some context, when an action occurs, then verify outcome) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Red-Green-Refactor) Tj /F0 12 Tf (: Write failing test, make it pass, improve code) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Test-Driven Development) Tj /F0 12 Tf (: Write tests before implementation) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Performance Considerations) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Keep tests fast by avoiding expensive operations when possible) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Use setup/teardown functions to share expensive initialization) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Consider using smaller datasets for unit tests) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Save integration tests with large datasets for separate test suites) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The test package provides essential tools for ensuring code quality and correctn) Tj T* (ess in MoonBit applications through comprehensive testing capabilities.) Tj T* 12 TL T* /F0 24 Tf (byte) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A package for working with bytes \(8-bit unsigned integers\) in MoonBit.) Tj T* 12 TL T* /F0 20 Tf (Constants) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The package provides constants for the minimum and maximum values of a byte:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "byte constants" {)' 12 TL (3     inspect\(@byte.min_value, content="b'\\\\x00'"\))' 12 TL (4     inspect\(@byte.max_value, content="b'\\\\xFF'"\))' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Conversion) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Bytes can be converted to other numeric types. The package provides conversion t) Tj T* (o ) Tj /F0 12 Tf (UInt64) Tj /F0 12 Tf (:) Tj T* 12 TL T* ET
endstream
endobj
18 0 obj
<<
  /Type /Page  
  /Contents 17 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
19 0 obj
<<
  /Length 1953
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "byte conversion" {)' 12 TL (3     let byte = b'A')' 12 TL (4     inspect\(byte.to_uint64\(\), content="65"\))' 12 TL (5     let byte = b' ')' 12 TL (6     inspect\(byte.to_uint64\(\), content="32"\))' 12 TL (7   })' T* 12 TL T* /F0 20 Tf (Byte Literals) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Although not directly part of this package, MoonBit provides byte literals with ) Tj T* (the ) Tj /F0 12 Tf (b) Tj /F0 12 Tf ( prefix:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "byte literals" {)' 12 TL (3     // ASCII character)' 12 TL (4     let a = b'a')' 12 TL (5     inspect\(a.to_uint64\(\), content="97"\))' 12 TL (6   )' 12 TL (7     // Hexadecimal escape sequence)' 12 TL (8     let hex = b'\\x41')' 12 TL (9     inspect\(hex.to_uint64\(\), content="65"\))' 12 TL (10  )' 12 TL (11    // Null byte)' 12 TL (12    let null = b'\\x00')' 12 TL (13    inspect\(null.to_uint64\(\), content="0"\))' 12 TL (14  )' 12 TL (15    // Maximum value)' 12 TL (16    let max = b'\\xff')' 12 TL (17    inspect\(max.to_uint64\(\), content="255"\))' 12 TL (18  })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Note: The same conversion method can be called either as a method \() Tj /F0 12 Tf (b.to_uint64\) Tj T* ((\)) Tj /F0 12 Tf (\) or as a package function \() Tj /F0 12 Tf (@byte.to_uint64\(b\)) Tj /F0 12 Tf (\).) Tj T* 12 TL T* /F0 24 Tf (Builtin Package Documentation) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides the core built-in types, functions, and utilities that are) Tj T* ( fundamental to MoonBit programming. It includes basic data structures, iterator) Tj T* (s, assertions, and core language features.) Tj T* 12 TL T* /F0 20 Tf (Core Types and Functions) Tj 20 TL T* 12 TL T* /F0 16 Tf (Assertions and Testing) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (MoonBit provides built-in assertion functions for testing:) Tj T* 12 TL T* ET
endstream
endobj
20 0 obj
<<
  /Type /Page  
  /Contents 19 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
21 0 obj
<<
  /Length 1236
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "assertions" {)' 12 TL (3     // Basic equality assertion)' 12 TL (4     assert_eq\(1 + 1, 2\))' 12 TL (5     assert_eq\("hello", "hello"\))' 12 TL (6   )' 12 TL (7     // Boolean assertions)' 12 TL (8     assert_true\(5 > 3\))' 12 TL (9     assert_false\(2 > 5\))' 12 TL (10  )' 12 TL (11    // Inequality assertion)' 12 TL (12    assert_not_eq\(1, 2\))' 12 TL (13    assert_not_eq\("foo", "bar"\))' 12 TL (14  })' T* 12 TL T* /F0 16 Tf (Inspect Function) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (inspect) Tj /F0 12 Tf ( function is used for testing and debugging:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "inspect usage" {)' 12 TL (3     let value = 42)' 12 TL (4     inspect\(value, content="42"\))' 12 TL (5     let list = [1, 2, 3])' 12 TL (6     inspect\(list, content="[1, 2, 3]"\))' 12 TL (7     let result : Result[Int, String] = Ok\(100\))' 12 TL (8     inspect\(result, content="Ok\(100\)"\))' 12 TL (9   })' T* 12 TL T* /F0 20 Tf (Result Type) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (Result[T, E]) Tj /F0 12 Tf ( type represents operations that can succeed or fail:) Tj T* 12 TL T* ET
endstream
endobj
22 0 obj
<<
  /Type /Page  
  /Contents 21 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
23 0 obj
<<
  /Length 1956
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "result type" {)' 12 TL (3     fn divide\(a : Int, b : Int\) -> Result[Int, String] {)' 12 TL (4       if b == 0 {)' 12 TL (5         Err\("Division by zero"\))' 12 TL (6       } else {)' 12 TL (7         Ok\(a / b\))' 12 TL (8       })' 12 TL (9     })' 12 TL (10  )' 12 TL (11    // Success case)' 12 TL (12    let result1 = divide\(10, 2\))' 12 TL (13    inspect\(result1, content="Ok\(5\)"\))' 12 TL (14  )' 12 TL (15    // Error case)' 12 TL (16    let result2 = divide\(10, 0\))' 12 TL (17    inspect\(result2, content="Err\(\\"Division by zero\\"\)"\))' 12 TL (18  )' 12 TL (19    // Pattern matching on Result)' 12 TL (20    match result1 {)' 12 TL (21      Ok\(value\) => inspect\(value, content="5"\))' 12 TL (22      Err\(_\) => inspect\(false, content="true"\))' 12 TL (23    })' 12 TL (24  })' T* 12 TL T* /F0 20 Tf (Option Type) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (Option[T]) Tj /F0 12 Tf ( type represents values that may or may not exist:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "option type" {)' 12 TL (3     fn find_first_even\(numbers : Array[Int]\) -> Int? {)' 12 TL (4       for num in numbers {)' 12 TL (5         if num % 2 == 0 {)' 12 TL (6           return Some\(num\))' 12 TL (7         })' 12 TL (8       })' 12 TL (9       None)' 12 TL (10    })' 12 TL (11  )' 12 TL (12    // Found case)' 12 TL (13    let result1 = find_first_even\([1, 3, 4, 5]\))' 12 TL (14    inspect\(result1, content="Some\(4\)"\))' 12 TL (15  )' 12 TL (16    // Not found case)' 12 TL (17    let result2 = find_first_even\([1, 3, 5]\))' 12 TL (18    inspect\(result2, content="None"\))' 12 TL (19  )' 12 TL (20    // Pattern matching on Option)' 12 TL (21    match result1 {)' 12 TL (22      Some\(value\) => inspect\(value, content="4"\))' 12 TL (23      None => inspect\(false, content="true"\))' 12 TL (24    })' 12 TL (25  })' T* ET
endstream
endobj
24 0 obj
<<
  /Type /Page  
  /Contents 23 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
25 0 obj
<<
  /Length 2030
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F0 20 Tf (Iterator Type) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (Iter[T]) Tj /F0 12 Tf ( type provides lazy iteration over sequences:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "iterators" {)' 12 TL (3     // Create iterator from array)' 12 TL (4     let numbers = [1, 2, 3, 4, 5])' 12 TL (5     let iter = numbers.iter\(\))' 12 TL (6   )' 12 TL (7     // Collect back to array)' 12 TL (8     let collected = iter.collect\(\))' 12 TL (9     inspect\(collected, content="[1, 2, 3, 4, 5]"\))' 12 TL (10  )' 12 TL (11    // Map transformation)' 12 TL (12    let doubled = numbers.iter\(\).map\(fn\(x\) { x * 2 }\).collect\(\))' 12 TL (13    inspect\(doubled, content="[2, 4, 6, 8, 10]"\))' 12 TL (14  )' 12 TL (15    // Filter elements)' 12 TL (16    let evens = numbers.iter\(\).filter\(fn\(x\) { x % 2 == 0 }\).collect\(\))' 12 TL (17    inspect\(evens, content="[2, 4]"\))' 12 TL (18  )' 12 TL (19    // Fold \(reduce\) operation)' 12 TL (20    let sum = numbers.iter\(\).fold\(init=0, fn\(acc, x\) { acc + x }\))' 12 TL (21    inspect\(sum, content="15"\))' 12 TL (22  })' T* 12 TL T* /F0 20 Tf (Array and FixedArray) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Built-in array types for storing collections:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "arrays" {)' 12 TL (3     // Dynamic arrays)' 12 TL (4     let arr = Array::new\(\))' 12 TL (5     arr.push\(1\))' 12 TL (6     arr.push\(2\))' 12 TL (7     arr.push\(3\))' 12 TL (8     inspect\(arr, content="[1, 2, 3]"\))' 12 TL (9   )' 12 TL (10    // Array from literal)' 12 TL (11    let fixed_arr = [10, 20, 30])' 12 TL (12    inspect\(fixed_arr, content="[10, 20, 30]"\))' 12 TL (13  )' 12 TL (14    // Array operations)' 12 TL (15    let length = fixed_arr.length\(\))' 12 TL (16    inspect\(length, content="3"\))' 12 TL (17    let first = fixed_arr[0])' 12 TL (18    inspect\(first, content="10"\))' 12 TL (19  })' T* 12 TL T* /F0 20 Tf (String Operations) Tj 20 TL T* ET
endstream
endobj
26 0 obj
<<
  /Type /Page  
  /Contents 25 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
27 0 obj
<<
  /Length 1293
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Basic string functionality:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "strings" {)' 12 TL (3     let text = "Hello, World!")' 12 TL (4   )' 12 TL (5     // String length)' 12 TL (6     let len = text.length\(\))' 12 TL (7     inspect\(len, content="13"\))' 12 TL (8   )' 12 TL (9     // String concatenation)' 12 TL (10    let greeting = "Hello" + ", " + "World!")' 12 TL (11    inspect\(greeting, content="Hello, World!"\))' 12 TL (12  )' 12 TL (13    // String comparison)' 12 TL (14    let equal = "test" == "test")' 12 TL (15    inspect\(equal, content="true"\))' 12 TL (16  })' T* 12 TL T* /F0 20 Tf (StringBuilder) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Efficient string building:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "string builder" {)' 12 TL (3     let builder = StringBuilder::new\(\))' 12 TL (4     builder.write_string\("Hello"\))' 12 TL (5     builder.write_string\(", "\))' 12 TL (6     builder.write_string\("World!"\))' 12 TL (7     let result = builder.to_string\(\))' 12 TL (8     inspect\(result, content="Hello, World!"\))' 12 TL (9   })' T* 12 TL T* /F0 20 Tf (JSON Support) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Basic JSON operations:) Tj T* 12 TL T* ET
endstream
endobj
28 0 obj
<<
  /Type /Page  
  /Contents 27 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
29 0 obj
<<
  /Length 1529
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "json" {)' 12 TL (3     // JSON values)' 12 TL (4     let json_null = null)' 12 TL (5     inspect\(json_null, content="Null"\))' 12 TL (6     let json_bool = true.to_json\(\))' 12 TL (7     inspect\(json_bool, content="True"\))' 12 TL (8     let json_number = \(42 : Int\).to_json\(\))' 12 TL (9     inspect\(json_number, content="Number\(42\)"\))' 12 TL (10    let json_string = "hello".to_json\(\))' 12 TL (11    inspect\()' 12 TL (12      json_string,)' 12 TL (13      content=\()' 12 TL (14        #|String\("hello"\))' 12 TL (15      \),)' 12 TL (16    \))' 12 TL (17  })' T* 12 TL T* /F0 20 Tf (Comparison Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Built-in comparison operators:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "comparisons" {)' 12 TL (3     // Equality)' 12 TL (4     inspect\(5 == 5, content="true"\))' 12 TL (5     inspect\(5 != 3, content="true"\))' 12 TL (6   )' 12 TL (7     // Ordering)' 12 TL (8     inspect\(3 < 5, content="true"\))' 12 TL (9     inspect\(5 > 3, content="true"\))' 12 TL (10    inspect\(5 >= 5, content="true"\))' 12 TL (11    inspect\(3 <= 5, content="true"\))' 12 TL (12  )' 12 TL (13    // String comparison)' 12 TL (14    inspect\("apple" < "banana", content="true"\))' 12 TL (15    inspect\("hello" == "hello", content="true"\))' 12 TL (16  })' T* 12 TL T* /F0 20 Tf (Utility Functions) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Helpful utility functions:) Tj T* 12 TL T* ET
endstream
endobj
30 0 obj
<<
  /Type /Page  
  /Contents 29 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
31 0 obj
<<
  /Length 1614
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "utilities" {)' 12 TL (3     // Identity and ignore)' 12 TL (4     let value = 42)' 12 TL (5     ignore\(value\) // Discards the value)' 12 TL (6   )' 12 TL (7     // Boolean negation)' 12 TL (8     let result = not\(false\))' 12 TL (9     inspect\(result, content="true"\))' 12 TL (10  )' 12 TL (11    // Physical equality \(reference equality\))' 12 TL (12    let arr1 = [1, 2, 3])' 12 TL (13    let arr2 = [1, 2, 3])' 12 TL (14    let same_ref = arr1)' 12 TL (15    inspect\(physical_equal\(arr1, arr2\), content="false"\) // Different objects)' 12 TL (16    inspect\(physical_equal\(arr1, same_ref\), content="true"\) // Same reference)' 12 TL (17  })' T* 12 TL T* /F0 20 Tf (Error Handling) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Basic error handling with panic and abort:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "error handling" {)' 12 TL (3     // This would panic in a real scenario, but we demonstrate the concept)' 12 TL (4     fn safe_divide\(a : Int, b : Int\) -> Int {)' 12 TL (5       if b == 0 {)' 12 TL (6         // In real code: panic\(\))' 12 TL (7         // For testing, we return a default value)' 12 TL (8         0)' 12 TL (9       } else {)' 12 TL (10        a / b)' 12 TL (11      })' 12 TL (12    })' 12 TL (13  )' 12 TL (14    let result = safe_divide\(10, 2\))' 12 TL (15    inspect\(result, content="5"\))' 12 TL (16    let safe_result = safe_divide\(10, 0\))' 12 TL (17    inspect\(safe_result, content="0"\))' 12 TL (18  })' T* 12 TL T* /F0 20 Tf (Best Practices) Tj 20 TL T* 12 TL T* ET
endstream
endobj
32 0 obj
<<
  /Type /Page  
  /Contents 31 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
33 0 obj
<<
  /Length 2828
>>
stream
 1 0 0 1 50 770 cm BT /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Use assertions liberally in tests) Tj /F0 12 Tf (: They help catch bugs early and document expec) Tj T* (ted behavior) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Prefer ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( over exceptions) Tj /F0 12 Tf (: For recoverable errors, use ) Tj /F0 12 Tf (Result[T, E]) Tj /F0 12 Tf ( instead ) Tj T* (of panicking) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Use ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf ( for nullable values) Tj /F0 12 Tf (: Instead of null pointers, use ) Tj /F0 12 Tf (Option[T]) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Leverage iterators for data processing) Tj /F0 12 Tf (: They provide composable and efficient da) Tj T* (ta transformations) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Use ) Tj /F0 12 Tf (StringBuilder) Tj /F0 12 Tf ( for string concatenation) Tj /F0 12 Tf (: More efficient than repeated string ) Tj T* (concatenation) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Pattern match on ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf (: Handle both success and failure cases explic) Tj T* (itly) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Performance Notes) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Arrays have O\(1\) access and O\(1\) amortized append) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Iterators are lazy and don't allocate intermediate collections) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (StringBuilder is more efficient than string concatenation for building large str) Tj T* (ings) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Physical equality is faster than structural equality but should be used carefull) Tj T* (y) Tj T* 12 TL T* -10 0 Td 12 TL T* /F0 24 Tf (HashMap) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A mutable hash map based on a Robin Hood hash table.) Tj T* 12 TL T* /F0 24 Tf (Usage) Tj 24 TL T* 12 TL T* /F0 20 Tf (Create) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can create an empty map using ) Tj /F0 12 Tf (new\(\)) Tj /F0 12 Tf ( or construct it using ) Tj /F0 12 Tf (from_array\(\)) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let _map2 : @hashmap.HashMap[String, Int] = @hashmap.new\(\))' 12 TL (4   )' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Set & Get) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (set\(\)) Tj /F0 12 Tf ( to add a key-value pair to the map, and use ) Tj /F0 12 Tf (get\(\)) Tj /F0 12 Tf ( to get a) Tj T* ( value.) Tj T* 12 TL T* ET
endstream
endobj
34 0 obj
<<
  /Type /Page  
  /Contents 33 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
35 0 obj
<<
  /Length 2204
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map : @hashmap.HashMap[String, Int] = @hashmap.new\(\))' 12 TL (4     map.set\("a", 1\))' 12 TL (5     assert_eq\(map.get\("a"\), Some\(1\)\))' 12 TL (6     assert_eq\(map.get_or_default\("a", 0\), 1\))' 12 TL (7     assert_eq\(map.get_or_default\("b", 0\), 0\))' 12 TL (8     map.remove\("a"\))' 12 TL (9     assert_eq\(map.contains\("a"\), false\))' 12 TL (10  })' T* 12 TL T* /F0 20 Tf (Remove) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (remove\(\)) Tj /F0 12 Tf ( to remove a key-value pair.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @hashmap.of\([\("a", 1\), \("b", 2\), \("c", 3\)]\))' 12 TL (4     map.remove\("a"\) |> ignore)' 12 TL (5     assert_eq\(map.to_array\(\), [\("c", 3\), \("b", 2\)]\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Contains) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (contains\(\)) Tj /F0 12 Tf ( to check whether a key exists.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @hashmap.of\([\("a", 1\), \("b", 2\), \("c", 3\)]\))' 12 TL (4     assert_eq\(map.contains\("a"\), true\))' 12 TL (5     assert_eq\(map.contains\("d"\), false\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Size & Capacity) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (size\(\)) Tj /F0 12 Tf ( to get the number of key-value pairs in the map, or ) Tj /F0 12 Tf (capacit) Tj T* (y\(\)) Tj /F0 12 Tf ( to get the current capacity.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @hashmap.of\([\("a", 1\), \("b", 2\), \("c", 3\)]\))' 12 TL (4     assert_eq\(map.size\(\), 3\))' 12 TL (5     assert_eq\(map.capacity\(\), 8\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Similarly, you can use ) Tj /F0 12 Tf (is_empty\(\)) Tj /F0 12 Tf ( to check whether the map is empty.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map : @hashmap.HashMap[String, Int] = @hashmap.new\(\))' 12 TL (4     assert_eq\(map.is_empty\(\), true\))' 12 TL (5   })' T* 12 TL T* ET
endstream
endobj
36 0 obj
<<
  /Type /Page  
  /Contents 35 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
37 0 obj
<<
  /Length 1781
>>
stream
 1 0 0 1 50 770 cm BT /F0 20 Tf (Clear) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (clear) Tj /F0 12 Tf ( to remove all key-value pairs from the map, but the allocated ) Tj T* (memory will not change.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @hashmap.of\([\("a", 1\), \("b", 2\), \("c", 3\)]\))' 12 TL (4     map.clear\(\))' 12 TL (5     assert_eq\(map.is_empty\(\), true\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Iteration) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (each\(\)) Tj /F0 12 Tf ( or ) Tj /F0 12 Tf (eachi\(\)) Tj /F0 12 Tf ( to iterate through all key-value pairs.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @hashmap.of\([\("a", 1\), \("b", 2\), \("c", 3\)]\))' 12 TL (4     let arr = [])' 12 TL (5     map.each\(\(k, v\) => arr.push\(\(k, v\)\)\))' 12 TL (6     let arr2 = [])' 12 TL (7     map.eachi\(\(i, k, v\) => arr2.push\(\(i, k, v\)\)\))' 12 TL (8   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Or use ) Tj /F0 12 Tf (iter\(\)) Tj /F0 12 Tf ( to get an iterator of hashmap.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @hashmap.of\([\("a", 1\), \("b", 2\), \("c", 3\)]\))' 12 TL (4     let _iter = map.iter\(\))' 12 TL (5   )' 12 TL (6   })' T* 12 TL T* /F0 24 Tf (String Package Documentation) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides comprehensive string manipulation utilities for MoonBit, i) Tj T* (ncluding string creation, conversion, searching, and Unicode handling.) Tj T* 12 TL T* /F0 20 Tf (String Creation and Conversion) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Create strings from various sources:) Tj T* 12 TL T* ET
endstream
endobj
38 0 obj
<<
  /Type /Page  
  /Contents 37 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
39 0 obj
<<
  /Length 1910
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "string creation" {)' 12 TL (3     // From character array)' 12 TL (4     let chars = ['H', 'e', 'l', 'l', 'o'])' 12 TL (5     let str1 = String::from_array\(chars\))' 12 TL (6     inspect\(str1, content="Hello"\))' 12 TL (7   )' 12 TL (8     // From character iterator)' 12 TL (9     let str2 = String::from_iter\(['W', 'o', 'r', 'l', 'd'].iter\(\)\))' 12 TL (10    inspect\(str2, content="World"\))' 12 TL (11  )' 12 TL (12    // Default empty string)' 12 TL (13    let empty = String::default\(\))' 12 TL (14    inspect\(empty, content=""\))' 12 TL (15  })' T* 12 TL T* /F0 20 Tf (String Iteration) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Iterate over Unicode characters in strings:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "string iteration" {)' 12 TL (3     let text = "Hello??")' 12 TL (4   )' 12 TL (5     // Forward iteration)' 12 TL (6     let chars = text.iter\(\).collect\(\))' 12 TL (7     inspect\(chars, content="['H', 'e', 'l', 'l', 'o', '??']"\))' 12 TL (8   )' 12 TL (9     // Reverse iteration)' 12 TL (10    let reversed = text.rev_iter\(\).collect\(\))' 12 TL (11    inspect\(reversed, content="['??', 'o', 'l', 'l', 'e', 'H']"\))' 12 TL (12  )' 12 TL (13    // Iteration with indices - demonstrate iter2 functionality)' 12 TL (14    let mut count = 0)' 12 TL (15    let mut first_char = 'a')' 12 TL (16    text)' 12 TL (17    .iter2\(\))' 12 TL (18    .each\(fn\(idx, char\) {)' 12 TL (19      if idx == 0 {)' 12 TL (20        first_char = char)' 12 TL (21      })' 12 TL (22      count = count + 1)' 12 TL (23    }\))' 12 TL (24    inspect\(first_char, content="H"\))' 12 TL (25    inspect\(count, content="6"\) // 6 Unicode characters)' 12 TL (26  })' T* 12 TL T* /F0 20 Tf (String Conversion) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Convert strings to other formats:) Tj T* 12 TL T* ET
endstream
endobj
40 0 obj
<<
  /Type /Page  
  /Contents 39 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
41 0 obj
<<
  /Length 2280
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "string conversion" {)' 12 TL (3     let text = "Hello")' 12 TL (4   )' 12 TL (5     // Convert to character array)' 12 TL (6     let chars = text.to_array\(\))' 12 TL (7     inspect\(chars, content="['H', 'e', 'l', 'l', 'o']"\))' 12 TL (8   )' 12 TL (9     // Convert to bytes \(UTF-16 LE encoding\))' 12 TL (10    let bytes = text.to_bytes\(\))' 12 TL (11    inspect\(bytes.length\(\), content="10"\) // 5 chars * 2 bytes each)' 12 TL (12  })' T* 12 TL T* /F0 20 Tf (Unicode Handling) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Work with Unicode characters and surrogate pairs:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "unicode handling" {)' 12 TL (3     let emoji_text = "Hello??World")' 12 TL (4   )' 12 TL (5     // Character count vs UTF-16 code unit count)' 12 TL (6     let char_count = emoji_text.iter\(\).count\(\))' 12 TL (7     let code_unit_count = emoji_text.length\(\))' 12 TL (8     inspect\(char_count, content="11"\) // Unicode characters)' 12 TL (9     inspect\(code_unit_count, content="12"\) // UTF-16 code units)' 12 TL (10  )' 12 TL (11    // Find character offset)' 12 TL (12    let offset = emoji_text.offset_of_nth_char\(5\) // Position of emoji)' 12 TL (13    inspect\(offset, content="Some\(5\)"\))' 12 TL (14  )' 12 TL (15    // Test character length)' 12 TL (16    let has_11_chars = emoji_text.char_length_eq\(11\))' 12 TL (17    inspect\(has_11_chars, content="true"\))' 12 TL (18  })' T* 12 TL T* /F0 20 Tf (String Comparison) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Strings are ordered using shortlex order by Unicode code points:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "string comparison" {)' 12 TL (3     let result1 = "apple".compare\("banana"\))' 12 TL (4     inspect\(result1, content="-1"\) // apple < banana)' 12 TL (5     let result2 = "hello".compare\("hello"\))' 12 TL (6     inspect\(result2, content="0"\) // equal)' 12 TL (7     let result3 = "zebra".compare\("apple"\))' 12 TL (8     inspect\(result3, content="1"\) // zebra > apple)' 12 TL (9   })' T* 12 TL T* /F0 20 Tf (String Views) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (String views provide efficient substring operations without copying:) Tj T* ET
endstream
endobj
42 0 obj
<<
  /Type /Page  
  /Contents 41 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
43 0 obj
<<
  /Length 2049
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "string views" {)' 12 TL (3     let text = "Hello, World!")' 12 TL (4     let view = text[:][7:12] // "World" - create view using slice notation)' 12 TL (5   )' 12 TL (6     // Views support similar operations as strings)' 12 TL (7     let chars = view.iter\(\).collect\(\))' 12 TL (8     inspect\(chars, content="['W', 'o', 'r', 'l', 'd']"\))' 12 TL (9   )' 12 TL (10    // Convert view back to string)' 12 TL (11    let substring = view.to_string\(\))' 12 TL (12    inspect\(substring, content="World"\))' 12 TL (13  })' T* 12 TL T* /F0 20 Tf (Practical Examples) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Common string manipulation tasks:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "practical examples" {)' 12 TL (3     let text = "The quick brown fox")' 12 TL (4   )' 12 TL (5     // Split into words \(using whitespace\) - returns Iter[View])' 12 TL (6     let words = text.split\(" "\).collect\(\))' 12 TL (7     inspect\(words.length\(\), content="4"\))' 12 TL (8     inspect\(words[0].to_string\(\), content="The"\))' 12 TL (9     inspect\(words[3].to_string\(\), content="fox"\))' 12 TL (10  )' 12 TL (11    // Join words back together - convert views to strings first)' 12 TL (12    let word_strings = words.map\(fn\(v\) { v.to_string\(\) }\))' 12 TL (13    let mut result = "")' 12 TL (14    for i, word in word_strings.iter2\(\) {)' 12 TL (15      if i > 0 {)' 12 TL (16        result = result + "-")' 12 TL (17      })' 12 TL (18      result = result + word)' 12 TL (19    })' 12 TL (20    inspect\(result, content="The-quick-brown-fox"\))' 12 TL (21  )' 12 TL (22    // Case conversion \(works on views\))' 12 TL (23    let upper = text[:].to_upper\(\).to_string\(\))' 12 TL (24    inspect\(upper, content="THE QUICK BROWN FOX"\))' 12 TL (25    let lower = text[:].to_lower\(\).to_string\(\))' 12 TL (26    inspect\(lower, content="the quick brown fox"\))' 12 TL (27  })' T* 12 TL T* /F0 20 Tf (Performance Notes) Tj 20 TL T* 12 TL T* ET
endstream
endobj
44 0 obj
<<
  /Type /Page  
  /Contents 43 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
45 0 obj
<<
  /Length 3166
>>
stream
 1 0 0 1 50 770 cm BT /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Use ) Tj /F0 12 Tf (StringBuilder) Tj /F0 12 Tf ( or ) Tj /F0 12 Tf (Buffer) Tj /F0 12 Tf ( for building strings incrementally rather than repea) Tj T* (ted concatenation) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (String views are lightweight and don't copy the underlying data) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Unicode iteration handles surrogate pairs correctly but is slower than UTF-16 co) Tj T* (de unit iteration) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Character length operations \() Tj /F0 12 Tf (char_length_eq) Tj /F0 12 Tf (, ) Tj /F0 12 Tf (char_length_ge) Tj /F0 12 Tf (\) have O\(n\) compl) Tj T* (exity where n is the character count) Tj T* 12 TL T* -10 0 Td 12 TL T* /F0 24 Tf (Moonbit/Core Result) Tj 24 TL T* 12 TL T* /F0 20 Tf (Overview) Tj 20 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Result[T,E]) Tj /F0 12 Tf ( is a type used for handling computation results and errors in an exp) Tj T* (licit and declarative manner, similar to Rust \() Tj /F0 12 Tf (Result<T,E>) Tj /F0 12 Tf (\) and OCaml \() Tj /F0 12 Tf (\('a, ) Tj T* ('e\) result) Tj /F0 12 Tf (\).) Tj /F0 12 Tf ( ) Tj /F0 12 Tf (It is an enum with two variants: ) Tj /F0 12 Tf (Ok\(T\)) Tj /F0 12 Tf (, which represents succes) Tj T* (s and contains a value of type ) Tj /F0 12 Tf (T) Tj /F0 12 Tf (, and ) Tj /F0 12 Tf (Err\(E\)) Tj /F0 12 Tf (, representing error and containin) Tj T* (g an error value of type ) Tj /F0 12 Tf (E) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F0 20 Tf (Usage) Tj 20 TL T* /F0 16 Tf (Constructing Result) Tj 16 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can create a ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( value using the ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf ( constructors, remember to giv) Tj T* (e proper type annotations.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let _result : Result[Int, String] = Ok\(42\))' 12 TL (4     let _error : Result[Int, String] = Err\("Error message"\))' 12 TL (5   )' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Or use the ) Tj /F0 12 Tf (ok) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (err) Tj /F0 12 Tf ( functions to create a ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( value.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let _result : Result[String, Unit] = Ok\("yes"\))' 12 TL (4     let _error : Result[Int, String] = Err\("error"\))' 12 TL (5   )' 12 TL (6   })' T* 12 TL T* /F0 16 Tf (Querying variant) Tj 16 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can check the variant of a ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( using the ) Tj /F0 12 Tf (is_ok) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (is_err) Tj /F0 12 Tf ( methods.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let result : Result[Int, String] = Ok\(42\))' 12 TL (4     let is_ok = result is Ok\(_\))' 12 TL (5     assert_eq\(is_ok, true\))' 12 TL (6     let is_err = result is Err\(_\))' 12 TL (7     assert_eq\(is_err, false\))' 12 TL (8   })' T* 12 TL T* /F0 16 Tf (Extracting values) Tj 16 TL T* ET
endstream
endobj
46 0 obj
<<
  /Type /Page  
  /Contents 45 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
47 0 obj
<<
  /Length 2833
>>
stream
 1 0 0 1 50 770 cm BT 12 TL /F0 12 Tf /F0 12 Tf (You can extract the value from a ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( using the ) Tj /F0 12 Tf (match) Tj /F0 12 Tf ( expression \(Pattern Mat) Tj T* (ching\).) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let result : Result[Int, Unit] = Ok\(33\))' 12 TL (4     let val = match result {)' 12 TL (5       Ok\(value\) => value)' 12 TL (6       Err\(_\) => -1)' 12 TL (7     })' 12 TL (8     assert_eq\(val, 33\))' 12 TL (9   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Or using the ) Tj /F0 12 Tf (unwrap) Tj /F0 12 Tf ( method, which will panic if the result is ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf ( and return the) Tj T* ( value if it is ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf (.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let result : Result[Int, String] = Ok\(42\))' 12 TL (4     let value = result.unwrap\(\))' 12 TL (5     assert_eq\(value, 42\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A safe alternative is the ) Tj /F0 12 Tf (or) Tj /F0 12 Tf ( method, which returns the value if the result is ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf () Tj T* ( or a default value if it is ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf (.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let result : Result[Int, String] = Err\("error"\))' 12 TL (4     let value = result.or\(0\))' 12 TL (5     assert_eq\(value, 0\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (There is a lazy version of ) Tj /F0 12 Tf (or) Tj /F0 12 Tf ( called ) Tj /F0 12 Tf (or_else) Tj /F0 12 Tf (, which takes a function that return) Tj T* (s a default value.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let result : Result[Int, String] = Err\("error"\))' 12 TL (4     let value = result.or_else\(\(\) => 0\))' 12 TL (5     assert_eq\(value, 0\))' 12 TL (6   })' T* 12 TL T* /F0 16 Tf (Transforming values) Tj 16 TL T* 12 TL /F0 12 Tf /F0 12 Tf (To transform values inside a ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf (, you can use the ) Tj /F0 12 Tf (map) Tj /F0 12 Tf ( method, which applies a) Tj T* ( function to the value if the result is ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf (,) Tj /F0 12 Tf ( ) Tj /F0 12 Tf (and remains unchanged if it is ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf (.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let result : Result[Int, String] = Ok\(42\))' 12 TL (4     let new_result = result.map\(x => x + 1\))' 12 TL (5     assert_eq\(new_result, Ok\(43\)\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A dual method to ) Tj /F0 12 Tf (map) Tj /F0 12 Tf ( is ) Tj /F0 12 Tf (map_err) Tj /F0 12 Tf (, which applies a function to the error value if ) Tj T* (the result is ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf (, and remains unchanged if it is ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf (.) Tj T* ET
endstream
endobj
48 0 obj
<<
  /Type /Page  
  /Contents 47 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
49 0 obj
<<
  /Length 2630
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let result : Result[Int, String] = Err\("error"\))' 12 TL (4     let new_result = result.map_err\(x => x + "!"\))' 12 TL (5     assert_eq\(new_result, Err\("error!"\)\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can turn a ) Tj /F0 12 Tf (Result[T, E]) Tj /F0 12 Tf ( into a ) Tj /F0 12 Tf (Option[T]) Tj /F0 12 Tf ( by using the method ) Tj /F0 12 Tf (to_option) Tj /F0 12 Tf (, whic) Tj T* (h returns ) Tj /F0 12 Tf (Some\(value\)) Tj /F0 12 Tf ( if the result is ) Tj /F0 12 Tf (Ok) Tj /F0 12 Tf (, and ) Tj /F0 12 Tf (None) Tj /F0 12 Tf ( if it is ) Tj /F0 12 Tf (Err) Tj /F0 12 Tf (.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let result : Result[Int, String] = Ok\(42\))' 12 TL (4     let option = result.to_option\(\))' 12 TL (5     assert_eq\(option, Some\(42\)\))' 12 TL (6     let result1 : Result[Int, String] = Err\("error"\))' 12 TL (7     let option1 = result1.to_option\(\))' 12 TL (8     assert_eq\(option1, None\))' 12 TL (9   })' T* 12 TL T* /F0 16 Tf (Monadic operations) Tj 16 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Moonbit provides monadic operations for ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf (, such as ) Tj /F0 12 Tf (flatten) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (bind) Tj /F0 12 Tf (, which ) Tj T* (allow chaining of computations that return ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf (.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let result : Result[Result[Int, String], String] = Ok\(Ok\(42\)\))' 12 TL (4     let flattened = result.flatten\(\))' 12 TL (5     assert_eq\(flattened, Ok\(42\)\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (bind) Tj /F0 12 Tf ( method is similar to ) Tj /F0 12 Tf (map) Tj /F0 12 Tf (, but the function passed to it should return a) Tj T* ( ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( value.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let result : Result[Int, String] = Ok\(42\))' 12 TL (4     let new_result = result.bind\(x => Ok\(x + 1\)\))' 12 TL (5     assert_eq\(new_result, Ok\(43\)\))' 12 TL (6   })' T* 12 TL T* /F0 24 Tf (uint16) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (moonbitlang/core/uint16) Tj /F0 12 Tf ( package provides functionality for working with 16-b) Tj T* (it unsigned integers. This package includes constants, operators, and conversion) Tj T* (s for UInt16 values.) Tj T* 12 TL T* /F0 20 Tf (Constants) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The package defines the minimum and maximum values for UInt16:) Tj T* 12 TL T* ET
endstream
endobj
50 0 obj
<<
  /Type /Page  
  /Contents 49 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
51 0 obj
<<
  /Length 1377
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt16 constants" {)' 12 TL (3     // Minimum value of UInt16)' 12 TL (4     inspect\(@uint16.min_value, content="0"\))' 12 TL (5   )' 12 TL (6     // Maximum value of UInt16)' 12 TL (7     inspect\(@uint16.max_value, content="65535"\))' 12 TL (8   })' T* 12 TL T* /F0 20 Tf (Arithmetic Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt16 supports standard arithmetic operations:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt16 arithmetic" {)' 12 TL (3     let a : UInt16 = 100)' 12 TL (4     let b : UInt16 = 50)' 12 TL (5   )' 12 TL (6     // Addition)' 12 TL (7     inspect\(a + b, content="150"\))' 12 TL (8   )' 12 TL (9     // Subtraction)' 12 TL (10    inspect\(a - b, content="50"\))' 12 TL (11  )' 12 TL (12    // Multiplication)' 12 TL (13    inspect\(a * b, content="5000"\))' 12 TL (14  )' 12 TL (15    // Division)' 12 TL (16    inspect\(a / b, content="2"\))' 12 TL (17  )' 12 TL (18    // Overflow behavior)' 12 TL (19    inspect\(@uint16.max_value + 1, content="0"\) // Wraps around to 0)' 12 TL (20    inspect\(@uint16.min_value - 1, content="65535"\) // Underflow wraps to maximum value)' 12 TL (21  })' T* 12 TL T* /F0 20 Tf (Bitwise Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt16 supports various bitwise operations:) Tj T* 12 TL T* ET
endstream
endobj
52 0 obj
<<
  /Type /Page  
  /Contents 51 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
53 0 obj
<<
  /Length 1627
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt16 bitwise operations" {)' 12 TL (3     let a : UInt16 = 0b1010)' 12 TL (4     let b : UInt16 = 0b1100)' 12 TL (5   )' 12 TL (6     // Bitwise AND)' 12 TL (7     inspect\(a & b, content="8"\))' 12 TL (8   )' 12 TL (9     // Bitwise OR)' 12 TL (10    inspect\(a | b, content="14"\))' 12 TL (11  )' 12 TL (12    // Bitwise XOR)' 12 TL (13    inspect\(a ^ b, content="6"\))' 12 TL (14  )' 12 TL (15    // Left shift)' 12 TL (16    inspect\(a << 1, content="20"\))' 12 TL (17    inspect\(a << 2, content="40"\))' 12 TL (18  )' 12 TL (19    // Right shift)' 12 TL (20    inspect\(a >> 1, content="5"\))' 12 TL (21    inspect\(b >> 2, content="3"\))' 12 TL (22  })' T* 12 TL T* /F0 20 Tf (Comparison and Equality) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt16 supports comparison and equality operations:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt16 comparison and equality" {)' 12 TL (3     let a : UInt16 = 100)' 12 TL (4     let b : UInt16 = 50)' 12 TL (5     let c : UInt16 = 100)' 12 TL (6   )' 12 TL (7     // Equality)' 12 TL (8     inspect\(a == c, content="true"\))' 12 TL (9     inspect\(a != b, content="true"\))' 12 TL (10  )' 12 TL (11    // Comparison)' 12 TL (12    inspect\(a > b, content="true"\))' 12 TL (13    inspect\(b < a, content="true"\))' 12 TL (14    inspect\(a >= c, content="true"\))' 12 TL (15    inspect\(c <= a, content="true"\))' 12 TL (16  })' T* 12 TL T* /F0 20 Tf (Default Value and Hashing) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt16 implements the Default trait:) Tj T* 12 TL T* ET
endstream
endobj
54 0 obj
<<
  /Type /Page  
  /Contents 53 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
55 0 obj
<<
  /Length 1917
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt16 default value" {)' 12 TL (3     // Default value is 0)' 12 TL (4     let a : UInt16 = 0)' 12 TL (5     inspect\(a, content="0"\))' 12 TL (6   )' 12 TL (7     // Hash support is available via .hash\(\))' 12 TL (8     let value : UInt16 = 42)' 12 TL (9     inspect\(value.hash\(\), content="42"\))' 12 TL (10  })' T* 12 TL T* /F0 20 Tf (Type Conversions) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt16 works with various conversions to and from other types:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt16 conversions" {)' 12 TL (3     // From Int to UInt16)' 12 TL (4     inspect\(\(42\).to_uint16\(\), content="42"\))' 12 TL (5   )' 12 TL (6     // From UInt16 to Int)' 12 TL (7     let value : UInt16 = 100)' 12 TL (8     inspect\(value.to_int\(\), content="100"\))' 12 TL (9   )' 12 TL (10    // Overflow handling in conversions)' 12 TL (11    inspect\(\(-1\).to_uint16\(\), content="65535"\) // Negative numbers wrap around)' 12 TL (12    inspect\(\(65536\).to_uint16\(\), content="0"\) // Values too large wrap around)' 12 TL (13    inspect\(\(65537\).to_uint16\(\), content="1"\) // 65536 + 1 = 1 \(modulo 65536\))' 12 TL (14  )' 12 TL (15    // From Byte to UInt16)' 12 TL (16    inspect\(b'A'.to_uint16\(\), content="65"\))' 12 TL (17    inspect\(b'\\xFF'.to_uint16\(\), content="255"\))' 12 TL (18  })' T* 12 TL T* /F0 24 Tf (Tuple) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Tuple is a fixed-size collection of elements of different types. It is a lightwe) Tj T* (ight data structure that can be used to store multiple values in a single variab) Tj T* (le. This sub-package introduces utils for binary tuples.) Tj T* 12 TL T* /F0 24 Tf (Usage) Tj 24 TL T* 12 TL T* /F0 20 Tf (Create) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Create a new tuple using the tuple literal syntax.) Tj T* 12 TL T* ET
endstream
endobj
56 0 obj
<<
  /Type /Page  
  /Contents 55 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
57 0 obj
<<
  /Length 1727
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let tuple2 = \(1, 2\))' 12 TL (4     let tuple3 = \(1, 2, 3\))' 12 TL (5     inspect\(\(tuple2, tuple3\), content="\(\(1, 2\), \(1, 2, 3\)\)"\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Access) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can access the elements of the tuple using pattern match or  dot access.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let tuple = \(1, 2\))' 12 TL (4     assert_eq\(tuple.0, 1\))' 12 TL (5     assert_eq\(tuple.1, 2\))' 12 TL (6     let \(a, b\) = tuple)' 12 TL (7     assert_eq\(a, 1\))' 12 TL (8     assert_eq\(b, 2\))' 12 TL (9   })' T* 12 TL T* /F0 20 Tf (Transformation) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can transform the tuple using the matrix functions combined with ) Tj /F0 12 Tf (then) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let tuple = \(1, 2\))' 12 TL (4     let tuple2 = \(\(pair : \(Int, Int\)\) => \(pair.0 + 1, pair.1\)\)\(tuple\))' 12 TL (5     inspect\(tuple2, content="\(2, 2\)"\))' 12 TL (6     let tuple3 = tuple |> then\(pair => \(pair.0, pair.1 + 1\)\))' 12 TL (7     inspect\(tuple3, content="\(1, 3\)"\))' 12 TL (8     let mapped = tuple |> then\(pair => \(pair.0 + 1, pair.1 - 1\)\))' 12 TL (9     inspect\(mapped, content="\(2, 1\)"\))' 12 TL (10  })' T* 12 TL T* /F0 24 Tf (List) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (List) Tj /F0 12 Tf ( package provides an immutable linked list data structure with a variety) Tj T* ( of utility functions for functional programming.) Tj T* 12 TL T* /F0 20 Tf (Table of Contents) Tj 20 TL T* 12 TL T* ET
endstream
endobj
58 0 obj
<<
  /Type /Page  
  /Contents 57 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
59 0 obj
<<
  /Length 2946
>>
stream
 1 0 0 1 50 770 cm BT /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Overview) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Performance) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Usage) Tj T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Create) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Basic Operations) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Access Elements) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Iteration) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Advanced Operations) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Conversion) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Equality) Tj T* -10 0 Td -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Error Handling Best Practices) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Implementation Notes) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Comparison with Other Collections) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 20 Tf (Overview) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (List) Tj /F0 12 Tf ( is a functional, immutable data structure that supports efficient traversal) Tj T* (, transformation, and manipulation. It is particularly useful for recursive algo) Tj T* (rithms and scenarios where immutability is required.) Tj T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 20 Tf (Performance) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (prepend) Tj /F0 12 Tf (: O\(1\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (length) Tj /F0 12 Tf (: O\(n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (map/filter) Tj /F0 12 Tf (: O\(n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (concatenate) Tj /F0 12 Tf (: O\(n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (reverse) Tj /F0 12 Tf (: O\(n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (nth) Tj /F0 12 Tf (: O\(n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (sort) Tj /F0 12 Tf (: O\(n log n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (flatten) Tj /F0 12 Tf (: O\(n * m\), where ) Tj /F0 12 Tf (m) Tj /F0 12 Tf ( is the average inner list length) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (space complexity) Tj /F0 12 Tf (: O\(n\)) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 20 Tf (Usage) Tj 20 TL T* 12 TL T* /F0 16 Tf (Create) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can create an empty list or a list from an array.) Tj T* 12 TL T* ET
endstream
endobj
60 0 obj
<<
  /Type /Page  
  /Contents 59 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
61 0 obj
<<
  /Length 1636
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let empty_list : @list.List[Int] = @list.new\(\))' 12 TL (4     assert_true\(empty_list.is_empty\(\)\))' 12 TL (5     let list = @list.of\([1, 2, 3, 4, 5]\))' 12 TL (6     assert_eq\(list, @list.of\([1, 2, 3, 4, 5]\)\))' 12 TL (7   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 16 Tf (Basic Operations) Tj 16 TL T* 12 TL T* /F0 12 Tf (Prepend) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Add an element to the beginning of the list.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([2, 3, 4, 5]\).prepend\(1\))' 12 TL (4     assert_eq\(list, @list.of\([1, 2, 3, 4, 5]\)\))' 12 TL (5   })' T* 12 TL T* /F0 12 Tf (Length) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get the number of elements in the list.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(list.length\(\), 5\))' 12 TL (5   })' T* 12 TL T* /F0 12 Tf (Check if Empty) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Determine if the list is empty.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let empty_list : @list.List[Int] = @list.new\(\))' 12 TL (4     assert_eq\(empty_list.is_empty\(\), true\))' 12 TL (5   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 16 Tf (Access Elements) Tj 16 TL T* 12 TL T* /F0 12 Tf (Head) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get the first element of the list as an ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf (.) Tj T* 12 TL T* ET
endstream
endobj
62 0 obj
<<
  /Type /Page  
  /Contents 61 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
63 0 obj
<<
  /Length 1751
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(list.head\(\), Some\(1\)\))' 12 TL (5   })' T* 12 TL T* /F0 12 Tf (Tail) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get the list without its first element.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(list.unsafe_tail\(\), @list.of\([2, 3, 4, 5]\)\))' 12 TL (5   })' T* 12 TL T* /F0 12 Tf (Nth Element) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get the nth element of the list as an ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(list.nth\(2\), Some\(3\)\))' 12 TL (5   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 16 Tf (Iteration) Tj 16 TL T* 12 TL T* /F0 12 Tf (Each) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Iterate over the elements of the list.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let arr = [])' 12 TL (4     @list.of\([1, 2, 3, 4, 5]\).each\(x => arr.push\(x\)\))' 12 TL (5     assert_eq\(arr, [1, 2, 3, 4, 5]\))' 12 TL (6   })' T* 12 TL T* /F0 12 Tf (Map) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Transform each element of the list.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([1, 2, 3, 4, 5]\).map\(x => x * 2\))' 12 TL (4     assert_eq\(list, @list.of\([2, 4, 6, 8, 10]\)\))' 12 TL (5   })' T* 12 TL T* /F0 12 Tf (Filter) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Keep elements that satisfy a predicate.) Tj T* ET
endstream
endobj
64 0 obj
<<
  /Type /Page  
  /Contents 63 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
65 0 obj
<<
  /Length 1704
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([1, 2, 3, 4, 5]\).filter\(x => x % 2 == 0\))' 12 TL (4     assert_eq\(list, @list.of\([2, 4]\)\))' 12 TL (5   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 16 Tf (Advanced Operations) Tj 16 TL T* 12 TL T* /F0 12 Tf (Reverse) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Reverse the list.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([1, 2, 3, 4, 5]\).rev\(\))' 12 TL (4     assert_eq\(list, @list.of\([5, 4, 3, 2, 1]\)\))' 12 TL (5   })' T* 12 TL T* /F0 12 Tf (Concatenate) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Concatenate two lists.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([1, 2, 3]\).concat\(@list.of\([4, 5]\)\))' 12 TL (4     assert_eq\(list, @list.of\([1, 2, 3, 4, 5]\)\))' 12 TL (5   })' T* 12 TL T* /F0 12 Tf (Flatten) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Flatten a list of lists.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([@list.of\([1, 2]\), @list.of\([3, 4]\)]\).flatten\(\))' 12 TL (4     assert_eq\(list, @list.of\([1, 2, 3, 4]\)\))' 12 TL (5   })' T* 12 TL T* /F0 12 Tf (Sort) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Sort the list in ascending order.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([3, 1, 4, 1, 5, 9]\).sort\(\))' 12 TL (4     assert_eq\(list, @list.of\([1, 1, 3, 4, 5, 9]\)\))' 12 TL (5   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 16 Tf (Conversion) Tj 16 TL T* ET
endstream
endobj
66 0 obj
<<
  /Type /Page  
  /Contents 65 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
67 0 obj
<<
  /Length 1308
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F0 12 Tf (To Array) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Convert a list to an array.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.of\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(list.to_array\(\), [1, 2, 3, 4, 5]\))' 12 TL (5   })' T* 12 TL T* /F0 12 Tf (From Array) Tj 12 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Create a list from an array.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list = @list.from_array\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(list, @list.of\([1, 2, 3, 4, 5]\)\))' 12 TL (5   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 16 Tf (Equality) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Lists with the same elements in the same order are considered equal.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let list1 = @list.of\([1, 2, 3]\))' 12 TL (4     let list2 = @list.of\([1, 2, 3]\))' 12 TL (5     assert_eq\(list1 == list2, true\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 20 Tf (Error Handling Best Practices) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (When accessing elements that might not exist, use pattern matching for safety:) Tj T* 12 TL T* ET
endstream
endobj
68 0 obj
<<
  /Type /Page  
  /Contents 67 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
69 0 obj
<<
  /Length 2972
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   fn safe_head\(list : @list.List[Int]\) -> Int {)' 12 TL (3     match list.head\(\) {)' 12 TL (4       Some\(value\) => value)' 12 TL (5       None => 0 // Default value)' 12 TL (6     })' 12 TL (7   })' 12 TL (8   )' 12 TL (9   ///|)' 12 TL (10  test {)' 12 TL (11    let list = @list.of\([1, 2, 3]\))' 12 TL (12    assert_eq\(safe_head\(list\), 1\))' 12 TL (13    let empty_list : @list.List[Int] = @list.new\(\))' 12 TL (14    assert_eq\(safe_head\(empty_list\), 0\))' 12 TL (15  })' T* 12 TL T* /F0 16 Tf (Additional Error Cases) Tj 16 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (nth\(\)) Tj /F0 12 Tf ( on an empty list or out-of-bounds index) Tj /F0 12 Tf (: Returns ) Tj /F0 12 Tf (None) Tj /F0 12 Tf (.) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (tail\(\)) Tj /F0 12 Tf ( on an empty list) Tj /F0 12 Tf (: Returns ) Tj /F0 12 Tf (Empty) Tj /F0 12 Tf (.) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (sort\(\)) Tj /F0 12 Tf ( with non-comparable elements) Tj /F0 12 Tf (: Throws a runtime error.) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 20 Tf (Implementation Notes) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (List) Tj /F0 12 Tf ( is implemented as a singly linked list. Operations like ) Tj /F0 12 Tf (prepend) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (hea) Tj T* (d) Tj /F0 12 Tf ( are O\(1\), while operations like ) Tj /F0 12 Tf (length) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (map) Tj /F0 12 Tf ( are O\(n\).) Tj T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Key properties of the implementation:) Tj T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Immutable by design) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Recursive-friendly) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Optimized for functional programming patterns) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (---) Tj T* 12 TL T* /F0 20 Tf (Comparison with Other Collections) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (@array.T) Tj /F0 12 Tf (: Provides O\(1\) random access but is mutable; use when random access i) Tj T* (s required.) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (@list.T) Tj /F0 12 Tf (: Immutable and optimized for recursive operations; use when immutability) Tj T* ( and functional patterns are required.) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Choose ) Tj /F0 12 Tf (List) Tj /F0 12 Tf ( when you need:) Tj T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Immutable data structures) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Efficient prepend operations) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Functional programming patterns) Tj T* 12 TL T* -10 0 Td 12 TL T* ET
endstream
endobj
70 0 obj
<<
  /Type /Page  
  /Contents 69 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
71 0 obj
<<
  /Length 2495
>>
stream
 1 0 0 1 50 770 cm BT /F0 24 Tf (Priority Queue) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A priority queue is a data structure capable of maintaining maximum/minimum valu) Tj T* (es at front of the queue, which may have other names in other programming langua) Tj T* (ges \(C++ std::priority_queue / Rust BinaryHeap \). The priority queue here is i) Tj T* (mplemented as a pairing heap and has excellent performance.) Tj T* 12 TL T* /F0 24 Tf (Usage) Tj 24 TL T* 12 TL T* /F0 20 Tf (Create) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (new\(\)) Tj /F0 12 Tf ( or ) Tj /F0 12 Tf (of\(\)) Tj /F0 12 Tf ( to create a priority queue.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let queue1 : @priority_queue.T[Int] = @priority_queue.new\(\))' 12 TL (4     let queue2 = @priority_queue.of\([1, 2, 3]\))' 12 TL (5     @json.inspect\(queue1, content=[]\))' 12 TL (6     @json.inspect\(queue2, content=[3, 2, 1]\))' 12 TL (7   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Note, however, that the default priority queue created is greater-first; if you ) Tj T* (need to create a less-first queue, you can write a struct belongs to Compare tra) Tj T* (it to implement it.) Tj T* 12 TL T* /F0 20 Tf (Length) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (length\(\)) Tj /F0 12 Tf ( to get the number of elements in the current priority que) Tj T* (ue.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let pq = @priority_queue.of\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(pq.length\(\), 5\))' 12 TL (5   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Similarly, you can use the ) Tj /F0 12 Tf (is_empty) Tj /F0 12 Tf ( to determine whether the priority queue is e) Tj T* (mpty.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let pq : @priority_queue.T[Int] = @priority_queue.new\(\))' 12 TL (4     assert_eq\(pq.is_empty\(\), true\))' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Peek) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (peek\(\)) Tj /F0 12 Tf ( to look at the head element of a queue, which must be eithe) Tj T* (r the maximum or minimum value of an element in the queue, depending on the natu) Tj T* (re of the specification. The return value of ) Tj /F0 12 Tf (peek\(\)) Tj /F0 12 Tf ( is an Option, which means ) Tj T* (that the result will be ) Tj /F0 12 Tf (None) Tj /F0 12 Tf ( when the queue is empty.) Tj T* ET
endstream
endobj
72 0 obj
<<
  /Type /Page  
  /Contents 71 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
73 0 obj
<<
  /Length 1950
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let pq = @priority_queue.of\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(pq.peek\(\), Some\(5\)\))' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Push) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (push\(\)) Tj /F0 12 Tf ( to add elements to the priority queue.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let pq : @priority_queue.T[Int] = @priority_queue.new\(\))' 12 TL (4     pq.push\(1\))' 12 TL (5     pq.push\(2\))' 12 TL (6     assert_eq\(pq.peek\(\), Some\(2\)\))' 12 TL (7   })' T* 12 TL T* /F0 20 Tf (Pop) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (pop\(\)) Tj /F0 12 Tf ( to pop the element at the front of the priority queue, respe) Tj T* (ctively, and like ) Tj /F0 12 Tf (Peek) Tj /F0 12 Tf (, its return values are ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf (, loaded with the value of t) Tj T* (he element being popped.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let pq = @priority_queue.of\([5, 4, 3, 2, 1]\))' 12 TL (4     assert_eq\(pq.pop\(\), Some\(5\)\))' 12 TL (5   })' T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let pq = @priority_queue.of\([5, 4, 3, 2, 1]\))' 12 TL (4     assert_eq\(pq.length\(\), 5\))' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Clear) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (clear) Tj /F0 12 Tf ( to clear a priority queue.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let pq = @priority_queue.of\([1, 2, 3, 4, 5]\))' 12 TL (4     pq.clear\(\))' 12 TL (5     assert_eq\(pq.is_empty\(\), true\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Copy and Transfer) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can copy a priority queue using the ) Tj /F0 12 Tf (copy) Tj /F0 12 Tf ( method.) Tj T* 12 TL T* ET
endstream
endobj
74 0 obj
<<
  /Type /Page  
  /Contents 73 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
75 0 obj
<<
  /Length 2164
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let pq = @priority_queue.of\([1, 2, 3]\))' 12 TL (4     let _pq2 = pq.copy\(\))' 12 TL (5   )' 12 TL (6   })' T* 12 TL T* /F0 24 Tf (Array Package Documentation) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides array manipulation utilities for MoonBit, including fixed-) Tj T* (size arrays \() Tj /F0 12 Tf (FixedArray) Tj /F0 12 Tf (\), dynamic arrays \() Tj /F0 12 Tf (Array) Tj /F0 12 Tf (\), and array views \() Tj /F0 12 Tf (ArrayVie) Tj T* (w) Tj /F0 12 Tf (/) Tj /F0 12 Tf (View) Tj /F0 12 Tf (\).) Tj T* 12 TL T* /F0 20 Tf (Creating Arrays) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (There are several ways to create arrays in MoonBit:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "array creation" {)' 12 TL (3     // Using array literal)' 12 TL (4     let arr1 = [1, 2, 3])' 12 TL (5     inspect\(arr1, content="[1, 2, 3]"\))' 12 TL (6   )' 12 TL (7     // Creating with indices)' 12 TL (8     let arr2 = Array::makei\(3, i => i * 2\))' 12 TL (9     inspect\(arr2, content="[0, 2, 4]"\))' 12 TL (10  )' 12 TL (11    // Creating from iterator)' 12 TL (12    let arr3 = Array::from_iter\("hello".iter\(\)\))' 12 TL (13    inspect\(arr3, content="['h', 'e', 'l', 'l', 'o']"\))' 12 TL (14  })' T* 12 TL T* /F0 20 Tf (Array Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Common array operations include mapping, filtering, and folding:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "array operations" {)' 12 TL (3     let nums = [1, 2, 3, 4, 5])' 12 TL (4   )' 12 TL (5     // Filtering out odd numbers and negating the remaining)' 12 TL (6     let neg_evens = nums.filter_map\(x => if x % 2 == 0 { Some\(-x\) } else { None }\))' 12 TL (7     inspect\(neg_evens, content="[-2, -4]"\))' 12 TL (8   )' 12 TL (9     // Summing array)' 12 TL (10    let sum = nums.fold\(init=0, \(acc, x\) => acc + x\))' 12 TL (11    inspect\(sum, content="15"\))' 12 TL (12  )' 12 TL (13    // Finding last element)' 12 TL (14    let last = nums.last\(\))' 12 TL (15    inspect\(last, content="Some\(5\)"\))' 12 TL (16  })' T* ET
endstream
endobj
76 0 obj
<<
  /Type /Page  
  /Contents 75 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
77 0 obj
<<
  /Length 1839
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F0 20 Tf (Sorting) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The package provides various sorting utilities:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "sorting" {)' 12 TL (3     let arr = [3, 1, 4, 1, 5, 9, 2, 6])' 12 TL (4   )' 12 TL (5     // Basic sorting - creates new sorted array)' 12 TL (6     let sorted1 = arr.copy\(\))' 12 TL (7     sorted1.sort\(\))' 12 TL (8     inspect\(sorted1, content="[1, 1, 2, 3, 4, 5, 6, 9]"\))' 12 TL (9   )' 12 TL (10    // Custom comparison)' 12 TL (11    let strs = ["aa", "b", "ccc"])' 12 TL (12    let sorted2 = strs.copy\(\))' 12 TL (13    sorted2.sort_by\(\(a, b\) => a.length\(\).compare\(b.length\(\)\)\))' 12 TL (14    inspect\()' 12 TL (15      sorted2,)' 12 TL (16      content=\()' 12 TL (17        #|["b", "aa", "ccc"])' 12 TL (18      \),)' 12 TL (19    \))' 12 TL (20  )' 12 TL (21    // Sort by key)' 12 TL (22    let pairs = [\(2, "b"\), \(1, "a"\), \(3, "c"\)])' 12 TL (23    let sorted3 = pairs.copy\(\))' 12 TL (24    sorted3.sort_by_key\(p => p.0\))' 12 TL (25    inspect\()' 12 TL (26      sorted3,)' 12 TL (27      content=\()' 12 TL (28        #|[\(1, "a"\), \(2, "b"\), \(3, "c"\)])' 12 TL (29      \),)' 12 TL (30    \))' 12 TL (31  })' T* 12 TL T* /F0 20 Tf (Array Views) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Array views provide a lightweight way to work with array slices:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "array views" {)' 12 TL (3     let arr = [1, 2, 3, 4, 5])' 12 TL (4     let view = arr[1:4])' 12 TL (5     inspect\(view, content="[2, 3, 4]"\))' 12 TL (6   )' 12 TL (7     // Map view to new array)' 12 TL (8     let doubled = view.map\(x => x * 2\))' 12 TL (9     inspect\(doubled, content="[4, 6, 8]"\))' 12 TL (10  })' T* 12 TL T* /F0 20 Tf (Fixed Arrays) Tj 20 TL T* ET
endstream
endobj
78 0 obj
<<
  /Type /Page  
  /Contents 77 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
79 0 obj
<<
  /Length 1976
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Fixed arrays provide immutable array operations:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "fixed arrays" {)' 12 TL (3     let fixed : FixedArray[_] = [1, 2, 3])' 12 TL (4   )' 12 TL (5     // Concatenation creates new array)' 12 TL (6     let combined = fixed + [4, 5])' 12 TL (7     inspect\(combined, content="[1, 2, 3, 4, 5]"\))' 12 TL (8   )' 12 TL (9     // Check for containment)' 12 TL (10    let has_two = fixed.contains\(2\))' 12 TL (11    inspect\(has_two, content="true"\))' 12 TL (12  )' 12 TL (13    // Check if array starts/ends with sequence)' 12 TL (14    let starts = fixed.starts_with\([1, 2]\))' 12 TL (15    inspect\(starts, content="true"\))' 12 TL (16    let ends = fixed.ends_with\([2, 3]\))' 12 TL (17    inspect\(ends, content="true"\))' 12 TL (18  })' T* 12 TL T* /F0 20 Tf (Utilities) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Additional array utilities for common operations:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "utilities" {)' 12 TL (3     // Join string array)' 12 TL (4     let words = ["hello", "world"])' 12 TL (5     let joined = words.join\(" "\))' 12 TL (6     inspect\(joined, content="hello world"\))' 12 TL (7   )' 12 TL (8     // Random shuffling)' 12 TL (9     let nums = [1, 2, 3, 4, 5])' 12 TL (10    // Using deterministic `rand` function below for demonstration)' 12 TL (11    // NOTE: When using a normal `rand` function, the actual result may vary)' 12 TL (12    let shuffled = nums.shuffle\(rand=_ => 1\))' 12 TL (13    inspect\(shuffled, content="[1, 3, 4, 5, 2]"\))' 12 TL (14  })' T* 12 TL T* /F0 24 Tf (Sorted Set) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A mutable set backed by a red-black tree.) Tj T* 12 TL T* /F0 24 Tf (Usage) Tj 24 TL T* 12 TL T* /F0 20 Tf (Create) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can create an empty SortedSet or a SortedSet from other containers.) Tj T* 12 TL T* ET
endstream
endobj
80 0 obj
<<
  /Type /Page  
  /Contents 79 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
81 0 obj
<<
  /Length 1992
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let _set1 : @sorted_set.SortedSet[Int] = @sorted_set.new\(\))' 12 TL (4     let _set2 = @sorted_set.singleton\(1\))' 12 TL (5     let _set3 = @sorted_set.from_array\([1]\))' 12 TL (6   )' 12 TL (7   })' T* /F0 16 Tf (Container Operations) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Add an element to the SortedSet in place.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set4 = @sorted_set.from_array\([1, 2, 3, 4]\))' 12 TL (4     set4.add\(5\) // \(\))' 12 TL (5     let set6 = @sorted_set.from_array\([1, 2, 3, 4, 5]\))' 12 TL (6     assert_eq\(set6.to_array\(\), [1, 2, 3, 4, 5]\))' 12 TL (7   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Remove an element from the SortedSet in place.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set = @sorted_set.from_array\([3, 8, 1]\))' 12 TL (4     set.remove\(8\) // \(\) )' 12 TL (5     let set7 = @sorted_set.from_array\([1, 3]\))' 12 TL (6     assert_eq\(set7.to_array\(\), [1, 3]\))' 12 TL (7   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Whether an element is in the set.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set = @sorted_set.from_array\([1, 2, 3, 4]\))' 12 TL (4     assert_eq\(set.contains\(1\), true\))' 12 TL (5     assert_eq\(set.contains\(5\), false\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Iterates over the elements in the set.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let arr = [])' 12 TL (4     @sorted_set.from_array\([1, 2, 3, 4]\).each\(v => arr.push\(v\)\))' 12 TL (5     assert_eq\(arr, [1, 2, 3, 4]\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get the size of the set.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set = @sorted_set.from_array\([1, 2, 3, 4]\))' 12 TL (4     assert_eq\(set.size\(\), 4\))' 12 TL (5   })' T* ET
endstream
endobj
82 0 obj
<<
  /Type /Page  
  /Contents 81 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
83 0 obj
<<
  /Length 2153
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Whether the set is empty.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set : @sorted_set.SortedSet[Int] = @sorted_set.new\(\))' 12 TL (4     assert_eq\(set.is_empty\(\), true\))' 12 TL (5   })' T* 12 TL T* /F0 16 Tf (Set Operations) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Union, intersection and difference of two sets. They return a new set that does ) Tj T* (not overlap with the original sets in memory.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set1 = @sorted_set.from_array\([3, 4, 5]\))' 12 TL (4     let set2 = @sorted_set.from_array\([4, 5, 6]\))' 12 TL (5     let set3 = set1.union\(set2\))' 12 TL (6     assert_eq\(set3.to_array\(\), [3, 4, 5, 6]\))' 12 TL (7     let set4 = set1.intersection\(set2\))' 12 TL (8     assert_eq\(set4.to_array\(\), [4, 5]\))' 12 TL (9     let set5 = set1.difference\(set2\))' 12 TL (10    assert_eq\(set5.to_array\(\), [3]\))' 12 TL (11  })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Determine the inclusion and separation relationship between two sets.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set1 = @sorted_set.from_array\([1, 2, 3]\))' 12 TL (4     let set2 = @sorted_set.from_array\([7, 2, 9, 4, 5, 6, 3, 8, 1]\))' 12 TL (5     assert_eq\(set1.subset\(set2\), true\))' 12 TL (6     let set3 = @sorted_set.from_array\([4, 5, 6]\))' 12 TL (7     assert_eq\(set1.disjoint\(set3\), true\))' 12 TL (8   })' T* 12 TL T* /F0 16 Tf (Stringify) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (SortedSet implements to_string \(i.e. Show trait\), which allows you to directly) Tj T* ( output it.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set = @sorted_set.from_array\([1, 2, 3]\))' 12 TL (4     assert_eq\(set.to_string\(\), "@sorted_set.from_array\([1, 2, 3]\)"\))' 12 TL (5   })' T* 12 TL T* /F0 24 Tf (int) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (moonbitlang/core/int) Tj /F0 12 Tf ( package provides essential operations on 32-bit integer) Tj T* (s.) Tj T* 12 TL T* ET
endstream
endobj
84 0 obj
<<
  /Type /Page  
  /Contents 83 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
85 0 obj
<<
  /Length 1773
>>
stream
 1 0 0 1 50 770 cm BT /F0 20 Tf (Basic Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This section shows the basic operations available for integers:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "basic int operations" {)' 12 TL (3     // Get absolute value)' 12 TL (4     inspect\(@int.abs\(-42\), content="42"\))' 12 TL (5     inspect\(@int.abs\(42\), content="42"\))' 12 TL (6   )' 12 TL (7     // Access min/max values)' 12 TL (8     inspect\(@int.min_value, content="-2147483648"\))' 12 TL (9     inspect\(@int.max_value, content="2147483647"\))' 12 TL (10  })' T* 12 TL T* /F0 20 Tf (Byte Conversion) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The package provides methods to convert integers to their byte representation in) Tj T* ( both big-endian and little-endian formats:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "byte conversions" {)' 12 TL (3     let num = 258 // 0x0102 in hex)' 12 TL (4   )' 12 TL (5     // Big-endian conversion \(most significant byte first\))' 12 TL (6     let be_bytes = num.to_be_bytes\(\))' 12 TL (7     inspect\()' 12 TL (8       be_bytes.to_string\(\),)' 12 TL (9       content=\()' 12 TL (10        #|b"\\x00\\x00\\x01\\x02")' 12 TL (11      \),)' 12 TL (12    \))' 12 TL (13  )' 12 TL (14    // Little-endian conversion \(least significant byte first\))' 12 TL (15    let le_bytes = num.to_le_bytes\(\))' 12 TL (16    inspect\()' 12 TL (17      le_bytes.to_string\(\),)' 12 TL (18      content=\()' 12 TL (19        #|b"\\x02\\x01\\x00\\x00")' 12 TL (20      \),)' 12 TL (21    \))' 12 TL (22  })' T* 12 TL T* /F0 20 Tf (Method Syntax) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (All operations are also available using method syntax for better readability:) Tj T* 12 TL T* ET
endstream
endobj
86 0 obj
<<
  /Type /Page  
  /Contents 85 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
87 0 obj
<<
  /Length 2079
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "method syntax" {)' 12 TL (3     let n = -42)' 12 TL (4   )' 12 TL (5     // Using method syntax)' 12 TL (6     inspect\(n.abs\(\), content="42"\))' 12 TL (7   )' 12 TL (8     // Byte conversions using method syntax)' 12 TL (9     let be = n.to_be_bytes\(\))' 12 TL (10    let le = n.to_le_bytes\(\))' 12 TL (11    inspect\()' 12 TL (12      be.to_string\(\),)' 12 TL (13      content=\()' 12 TL (14        #|b"\\xff\\xff\\xff\\xd6")' 12 TL (15      \),)' 12 TL (16    \))' 12 TL (17    inspect\()' 12 TL (18      le.to_string\(\),)' 12 TL (19      content=\()' 12 TL (20        #|b"\\xd6\\xff\\xff\\xff")' 12 TL (21      \),)' 12 TL (22    \))' 12 TL (23  })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The package provides the foundations for 32-bit integer operations in MoonBit, e) Tj T* (ssential for any numeric computation.) Tj T* 12 TL T* /F0 24 Tf (int64) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides operations for working with 64-bit signed integers \() Tj /F0 12 Tf (Int64) Tj /F0 12 Tf () Tj T* (\) in MoonBit.) Tj T* 12 TL T* /F0 20 Tf (Basic Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Int64) Tj /F0 12 Tf ( values can be created from regular 32-bit integers using ) Tj /F0 12 Tf (from_int) Tj /F0 12 Tf (. The pac) Tj T* (kage also provides constants for the maximum and minimum values representable by) Tj T* ( ) Tj /F0 12 Tf (Int64) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "basic operations" {)' 12 TL (3     let i : Int64 = -12345L // Int64 literal)' 12 TL (4     // You can also convert from an `Int` like so:)' 12 TL (5     inspect\(@int64.from_int\(-12345\) == i, content="true"\))' 12 TL (6   )' 12 TL (7     // Max and min values)' 12 TL (8     inspect\(@int64.max_value, content="9223372036854775807"\))' 12 TL (9     inspect\(@int64.min_value, content="-9223372036854775808"\))' 12 TL (10  )' 12 TL (11    // Absolute value)' 12 TL (12    inspect\(@int64.abs\(i\), content="12345"\))' 12 TL (13  })' T* 12 TL T* ET
endstream
endobj
88 0 obj
<<
  /Type /Page  
  /Contents 87 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
89 0 obj
<<
  /Length 2106
>>
stream
 1 0 0 1 50 770 cm BT /F0 20 Tf (Binary Representation) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The package provides functions to convert ) Tj /F0 12 Tf (Int64) Tj /F0 12 Tf ( values to their binary represent) Tj T* (ation in both big-endian and little-endian byte order:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "binary conversion" {)' 12 TL (3     let x = 258L // Int64 value of 258)' 12 TL (4     let be_bytes = x.to_be_bytes\(\))' 12 TL (5     let le_bytes = x.to_le_bytes\(\))' 12 TL (6   )' 12 TL (7     // Convert to String for inspection)' 12 TL (8     inspect\()' 12 TL (9       be_bytes.to_string\(\),)' 12 TL (10      content=\()' 12 TL (11        #|b"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02")' 12 TL (12      \),)' 12 TL (13    \))' 12 TL (14    inspect\()' 12 TL (15      le_bytes.to_string\(\),)' 12 TL (16      content=\()' 12 TL (17        #|b"\\x02\\x01\\x00\\x00\\x00\\x00\\x00\\x00")' 12 TL (18      \),)' 12 TL (19    \))' 12 TL (20  )' 12 TL (21    // We can verify they represent the same number but in different byte orders)' 12 TL (22    let len = be_bytes.length\(\))' 12 TL (23    inspect\(len, content="8"\))' 12 TL (24  })' T* 12 TL T* /F0 20 Tf (Method-Style Usage) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (All operations are also available as methods on ) Tj /F0 12 Tf (Int64) Tj /F0 12 Tf ( values:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "method style" {)' 12 TL (3     let x = -42L)' 12 TL (4   )' 12 TL (5     // Using method syntax for absolute value)' 12 TL (6     inspect\(x.abs\(\), content="42"\))' 12 TL (7   )' 12 TL (8     // Binary conversions as methods)' 12 TL (9     inspect\()' 12 TL (10      x.to_be_bytes\(\),)' 12 TL (11      content=\()' 12 TL (12        #|b"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xd6")' 12 TL (13      \),)' 12 TL (14    \))' 12 TL (15  })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Note that ) Tj /F0 12 Tf (Int64) Tj /F0 12 Tf ( implements the ) Tj /F0 12 Tf (Hash) Tj /F0 12 Tf ( trait, allowing it to be used as keys in has) Tj T* (h maps and members of hash sets.) Tj T* 12 TL T* ET
endstream
endobj
90 0 obj
<<
  /Type /Page  
  /Contents 89 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
91 0 obj
<<
  /Length 2631
>>
stream
 1 0 0 1 50 770 cm BT /F0 24 Tf (unit) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (unit) Tj /F0 12 Tf ( package provides functionality for working with the singleton type ) Tj /F0 12 Tf (Unit) Tj /F0 12 Tf () Tj T* (, which represents computations that produce side effects but return no meaningf) Tj T* (ul value. This is a fundamental type in functional programming for operations li) Tj T* (ke I/O, logging, and state modifications.) Tj T* 12 TL T* /F0 20 Tf (Understanding Unit Type) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (Unit) Tj /F0 12 Tf ( type has exactly one value: ) Tj /F0 12 Tf (\(\)) Tj /F0 12 Tf (. This might seem trivial, but it serve) Tj T* (s important purposes in type systems:) Tj T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Side Effect Indication) Tj /F0 12 Tf (: Functions returning ) Tj /F0 12 Tf (Unit) Tj /F0 12 Tf ( signal they're called for side ) Tj T* (effects) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Placeholder Type) Tj /F0 12 Tf (: Used when a type parameter is needed but no meaningful value e) Tj T* (xists) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Functional Programming) Tj /F0 12 Tf (: Represents "no useful return value" without using ) Tj /F0 12 Tf (null) Tj /F0 12 Tf ( o) Tj T* (r exceptions) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Interface Consistency) Tj /F0 12 Tf (: Maintains uniform function signatures in generic contexts) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Unit Value Creation) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The unit value can be created in multiple ways:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "unit construction" {)' 12 TL (3     // Direct literal syntax)' 12 TL (4     let u1 = \(\))' 12 TL (5   )' 12 TL (6     // Via default constructor)' 12 TL (7     let u2 = @unit.default\(\))' 12 TL (8     fn println\(_ : String\) {)' 12 TL (9   )' 12 TL (10    })' 12 TL (11    // All unit values are identical)' 12 TL (12    inspect\(u1 == u2, content="true"\))' 12 TL (13  )' 12 TL (14    // Common pattern: functions that return unit)' 12 TL (15    fn log_message\(msg : String\) -> Unit {)' 12 TL (16      // In real code, this would write to a log)' 12 TL (17      println\(msg\))' 12 TL (18      \(\) // Explicit unit return)' 12 TL (19    })' 12 TL (20  )' 12 TL (21    let result = log_message\("Hello, world!"\))' 12 TL (22    inspect\(result, content="\(\)"\))' 12 TL (23  })' T* 12 TL T* /F0 20 Tf (Working with Side-Effect Functions) Tj 20 TL T* 12 TL T* ET
endstream
endobj
92 0 obj
<<
  /Type /Page  
  /Contents 91 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
93 0 obj
<<
  /Length 1989
>>
stream
 1 0 0 1 50 770 cm BT 12 TL /F0 12 Tf /F0 12 Tf (Functions that return ) Tj /F0 12 Tf (Unit) Tj /F0 12 Tf ( are typically called for their side effects:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "side effect patterns" {)' 12 TL (3     let numbers = [1, 2, 3, 4, 5])' 12 TL (4     fn println\(_ : Int\) {)' 12 TL (5   )' 12 TL (6     })' 12 TL (7     // Processing for side effects \(printing, logging, etc.\))' 12 TL (8     let processing_result = numbers.fold\(init=\(\), fn\(_acc, n\) {)' 12 TL (9       // Simulated side effect)' 12 TL (10      if n % 2 == 0 {)' 12 TL (11        // Would print or log in real code)' 12 TL (12        println\(n\))' 12 TL (13      })' 12 TL (14      \(\) // Return unit to continue fold)' 12 TL (15    }\))' 12 TL (16    inspect\(processing_result, content="\(\)"\))' 12 TL (17  )' 12 TL (18    // Using each for side effects \(more idiomatic\))' 12 TL (19    numbers.each\(fn\(n\) { if n % 2 == 0 { println\(n\) } }\))' 12 TL (20  })' T* 12 TL T* /F0 20 Tf (String Representation and Debugging) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Unit values have a standard string representation for debugging:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "unit string conversion" {)' 12 TL (3     let u = \(\))' 12 TL (4     inspect\(u.to_string\(\), content="\(\)"\))' 12 TL (5   )' 12 TL (6     // Useful for debugging function results)' 12 TL (7     fn perform_operation\(\) -> Unit {)' 12 TL (8       // Some side effect operation)' 12 TL (9       \(\))' 12 TL (10    })' 12 TL (11  )' 12 TL (12    let result = perform_operation\(\))' 12 TL (13    let debug_msg = "Operation completed: \\{result}")' 12 TL (14    inspect\(debug_msg, content="Operation completed: \(\)"\))' 12 TL (15  })' T* 12 TL T* /F0 20 Tf (Generic Programming with Unit) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Unit is particularly useful in generic contexts where you need to represent "no ) Tj T* (meaningful value":) Tj T* 12 TL T* ET
endstream
endobj
94 0 obj
<<
  /Type /Page  
  /Contents 93 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
95 0 obj
<<
  /Length 2051
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "generic unit usage" {)' 12 TL (3     // Simulating a function that processes data and optionally returns a result)' 12 TL (4     let items = [1, 2, 3, 4, 5])' 12 TL (5   )' 12 TL (6     // Process for side effects only)' 12 TL (7     items.each\(fn\(x\) {)' 12 TL (8       // Side effect: processing each item)' 12 TL (9       let processed = x * 2)' 12 TL (10      assert_true\(processed > 0\) // Simulated processing validation)' 12 TL (11    }\))' 12 TL (12  )' 12 TL (13    // Unit represents successful completion without meaningful return value)' 12 TL (14    let completion_status = \(\))' 12 TL (15    inspect\(completion_status, content="\(\)"\))' 12 TL (16  )' 12 TL (17    // Unit is useful in Result types for operations that succeed but return nothing)' 12 TL (18    let operation_result : Result[Unit, String] = Ok\(\(\)\))' 12 TL (19    inspect\(operation_result, content="Ok\(\(\)\)"\))' 12 TL (20  })' T* 12 TL T* /F0 20 Tf (Built-in Trait Implementations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Unit implements essential traits for seamless integration with MoonBit's type sy) Tj T* (stem:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "unit trait implementations" {)' 12 TL (3     let u1 = \(\))' 12 TL (4     let u2 = \(\))' 12 TL (5   )' 12 TL (6     // Equality: all unit values are equal)' 12 TL (7     inspect\(u1 == u2, content="true"\))' 12 TL (8   )' 12 TL (9     // Comparison: all unit values compare as equal)' 12 TL (10    inspect\(u1.compare\(u2\), content="0"\))' 12 TL (11  )' 12 TL (12    // Hashing: consistent hash values)' 12 TL (13    let h1 = u1.hash\(\))' 12 TL (14    let h2 = u2.hash\(\))' 12 TL (15    inspect\(h1 == h2, content="true"\))' 12 TL (16  )' 12 TL (17    // Default instance)' 12 TL (18    let u3 = Unit::default\(\))' 12 TL (19    inspect\(u3 == u1, content="true"\))' 12 TL (20  })' T* 12 TL T* /F0 20 Tf (Practical Use Cases) Tj 20 TL T* 12 TL T* /F0 16 Tf (Result Accumulation) Tj 16 TL T* 12 TL T* ET
endstream
endobj
96 0 obj
<<
  /Type /Page  
  /Contents 95 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
97 0 obj
<<
  /Length 2326
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "result accumulation" {)' 12 TL (3     // Accumulating side effects without meaningful return values)' 12 TL (4     let operations = [)' 12 TL (5       fn\(\) { \(\) }, // Operation 1)' 12 TL (6       fn\(\) { \(\) }, // Operation 2)' 12 TL (7       fn\(\) { \(\) },)' 12 TL (8     ] // Operation 3)' 12 TL (9     let final_result = operations.fold\(init=\(\), fn\(acc, operation\) {)' 12 TL (10      operation\(\) // Execute the operation)' 12 TL (11      acc // Accumulate unit values)' 12 TL (12    }\))' 12 TL (13    inspect\(final_result, content="\(\)"\))' 12 TL (14  })' T* 12 TL T* /F0 16 Tf (Builder Pattern Termination) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "builder pattern" {)' 12 TL (3     // Simulating a builder pattern where build\(\) returns Unit)' 12 TL (4     let settings = ["debug=true", "timeout=30"])' 12 TL (5   )' 12 TL (6     // Build operation returns Unit after applying configuration)' 12 TL (7     fn apply_config\(config_list : Array[String]\) -> Unit {)' 12 TL (8       // In real code: apply configuration settings)' 12 TL (9       let _has_settings = config_list.length\(\) > 0)' 12 TL (10      \(\) // Unit indicates successful completion)' 12 TL (11    })' 12 TL (12  )' 12 TL (13    let result = apply_config\(settings\))' 12 TL (14    inspect\(result, content="\(\)"\))' 12 TL (15  })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (Unit) Tj /F0 12 Tf ( type provides essential functionality for representing "no meaningful r) Tj T* (eturn value" in a type-safe way, enabling clean functional programming patterns ) Tj T* (and consistent interfaces across MoonBit code.) Tj T* 12 TL T* /F0 24 Tf (BigInt Package Documentation) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides arbitrary-precision integer arithmetic through the ) Tj /F0 12 Tf (BigInt) Tj /F0 12 Tf ( ) Tj T* (type. BigInt allows you to work with integers of unlimited size, making it perfe) Tj T* (ct for cryptographic operations, mathematical computations, and any scenario whe) Tj T* (re standard integer types are insufficient.) Tj T* 12 TL T* /F0 20 Tf (Creating BigInt Values) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (There are several ways to create BigInt values:) Tj T* 12 TL T* ET
endstream
endobj
98 0 obj
<<
  /Type /Page  
  /Contents 97 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
99 0 obj
<<
  /Length 1183
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "creating bigint values" {)' 12 TL (3     // From integer literals with 'N' suffix)' 12 TL (4     let big1 = 12345678901234567890N)' 12 TL (5     inspect\(big1, content="12345678901234567890"\))' 12 TL (6   )' 12 TL (7     // From regular integers)' 12 TL (8     let big2 = @bigint.BigInt::from_int\(42\))' 12 TL (9     inspect\(big2, content="42"\))' 12 TL (10  )' 12 TL (11    // From Int64 values)' 12 TL (12    let big3 = @bigint.BigInt::from_int64\(9223372036854775807L\))' 12 TL (13    inspect\(big3, content="9223372036854775807"\))' 12 TL (14  )' 12 TL (15    // From strings)' 12 TL (16    let big4 = @bigint.BigInt::from_string\("123456789012345678901234567890"\))' 12 TL (17    inspect\(big4, content="123456789012345678901234567890"\))' 12 TL (18  )' 12 TL (19    // From hexadecimal strings)' 12 TL (20    let big5 = @bigint.BigInt::from_hex\("1a2b3c4d5e6f"\))' 12 TL (21    inspect\(big5, content="28772997619311"\))' 12 TL (22  })' T* 12 TL T* /F0 20 Tf (Basic Arithmetic Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (BigInt supports all standard arithmetic operations:) Tj T* 12 TL T* ET
endstream
endobj
100 0 obj
<<
  /Type /Page  
  /Contents 99 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
101 0 obj
<<
  /Length 2327
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "arithmetic operations" {)' 12 TL (3     let a = 123456789012345678901234567890N)' 12 TL (4     let b = 987654321098765432109876543210N)' 12 TL (5   )' 12 TL (6     // Addition)' 12 TL (7     let sum = a + b)' 12 TL (8     inspect\(sum, content="1111111110111111111011111111100"\))' 12 TL (9   )' 12 TL (10    // Subtraction)' 12 TL (11    let diff = b - a)' 12 TL (12    inspect\(diff, content="864197532086419753208641975320"\))' 12 TL (13  )' 12 TL (14    // Multiplication)' 12 TL (15    let product = @bigint.BigInt::from_int\(123\) * @bigint.BigInt::from_int\(456\))' 12 TL (16    inspect\(product, content="56088"\))' 12 TL (17  )' 12 TL (18    // Division)' 12 TL (19    let quotient = @bigint.BigInt::from_int\(1000\) / @bigint.BigInt::from_int\(7\))' 12 TL (20    inspect\(quotient, content="142"\))' 12 TL (21  )' 12 TL (22    // Modulo)' 12 TL (23    let remainder = @bigint.BigInt::from_int\(1000\) % @bigint.BigInt::from_int\(7\))' 12 TL (24    inspect\(remainder, content="6"\))' 12 TL (25  )' 12 TL (26    // Negation)' 12 TL (27    let neg = -a)' 12 TL (28    inspect\(neg, content="-123456789012345678901234567890"\))' 12 TL (29  })' T* 12 TL T* /F0 20 Tf (Comparison Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Compare BigInt values with each other and with regular integers:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "comparisons" {)' 12 TL (3     let big = 12345N)' 12 TL (4     let small = 123N)' 12 TL (5   )' 12 TL (6     // BigInt to BigInt comparison)' 12 TL (7     inspect\(big > small, content="true"\))' 12 TL (8     inspect\(big == small, content="false"\))' 12 TL (9     inspect\(small < big, content="true"\))' 12 TL (10  )' 12 TL (11    // BigInt to Int comparison)' 12 TL (12    inspect\(big.equal_int\(12345\), content="true"\))' 12 TL (13    inspect\(big.compare_int\(12345\), content="0"\))' 12 TL (14    inspect\(big.compare_int\(1000\), content="1"\) // greater than)' 12 TL (15    inspect\(small.compare_int\(200\), content="-1"\) // less than)' 12 TL (16  )' 12 TL (17    // BigInt to Int64 comparison)' 12 TL (18    let big64 = @bigint.BigInt::from_int64\(9223372036854775807L\))' 12 TL (19    inspect\(big64.equal_int64\(9223372036854775807L\), content="true"\))' 12 TL (20  })' T* ET
endstream
endobj
102 0 obj
<<
  /Type /Page  
  /Contents 101 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
103 0 obj
<<
  /Length 1349
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F0 20 Tf (Bitwise Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (BigInt supports bitwise operations for bit manipulation:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "bitwise operations" {)' 12 TL (3     let a = 0b11110000N // 240 in decimal)' 12 TL (4     let b = 0b10101010N // 170 in decimal)' 12 TL (5   )' 12 TL (6     // Bitwise AND)' 12 TL (7     let and_result = a & b)' 12 TL (8     inspect\(and_result, content="160"\) // 0b10100000)' 12 TL (9   )' 12 TL (10    // Bitwise OR)' 12 TL (11    let or_result = a | b)' 12 TL (12    inspect\(or_result, content="250"\) // 0b11111010)' 12 TL (13  )' 12 TL (14    // Bitwise XOR)' 12 TL (15    let xor_result = a ^ b)' 12 TL (16    inspect\(xor_result, content="90"\) // 0b01011010)' 12 TL (17  )' 12 TL (18    // Bit length)' 12 TL (19    let big_num = 255N)' 12 TL (20    inspect\(big_num.bit_length\(\), content="8"\))' 12 TL (21  )' 12 TL (22    // Count trailing zeros)' 12 TL (23    let with_zeros = 1000N // Has trailing zeros in binary)' 12 TL (24    let ctz = with_zeros.ctz\(\))' 12 TL (25    inspect\(ctz >= 0, content="true"\))' 12 TL (26  })' T* 12 TL T* /F0 20 Tf (Power and Modular Arithmetic) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (BigInt provides efficient power and modular exponentiation:) Tj T* 12 TL T* ET
endstream
endobj
104 0 obj
<<
  /Type /Page  
  /Contents 103 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
105 0 obj
<<
  /Length 2198
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "power operations" {)' 12 TL (3     // Basic power)' 12 TL (4     let base = 2N)' 12 TL (5     let exponent = 10N)' 12 TL (6     let power = base.pow\(exponent\))' 12 TL (7     inspect\(power, content="1024"\))' 12 TL (8   )' 12 TL (9     // Modular exponentiation \(useful for cryptography\))' 12 TL (10    let base2 = 3N)' 12 TL (11    let exp2 = 5N)' 12 TL (12    let modulus = 7N)' 12 TL (13    let mod_power = base2.pow\(exp2, modulus~\))' 12 TL (14    inspect\(mod_power, content="5"\) // \(3^5\) % 7 = 243 % 7 = 5)' 12 TL (15  )' 12 TL (16    // Large modular exponentiation \(optimized for speed\))' 12 TL (17    let large_base = 123N)' 12 TL (18    let large_exp = 20N)' 12 TL (19    let large_mod = 1000007N)' 12 TL (20    let result = large_base.pow\(large_exp, modulus=large_mod\))' 12 TL (21    inspect\(result, content="378446"\) // \(123^20\) % 1000007)' 12 TL (22  })' T* 12 TL T* /F0 20 Tf (String and Hexadecimal Conversion) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Convert BigInt to and from various string representations:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "string conversions" {)' 12 TL (3     let big = 255N)' 12 TL (4   )' 12 TL (5     // Decimal string)' 12 TL (6     let decimal = big.to_string\(\))' 12 TL (7     inspect\(decimal, content="255"\))' 12 TL (8   )' 12 TL (9     // Hexadecimal \(lowercase\))' 12 TL (10    let hex_lower = big.to_hex\(\))' 12 TL (11    inspect\(hex_lower, content="FF"\))' 12 TL (12  )' 12 TL (13    // Hexadecimal \(uppercase\))' 12 TL (14    let hex_upper = big.to_hex\(uppercase=true\))' 12 TL (15    inspect\(hex_upper, content="FF"\))' 12 TL (16  )' 12 TL (17    // Parse from hex)' 12 TL (18    let from_hex = @bigint.BigInt::from_hex\("deadbeef"\))' 12 TL (19    inspect\(from_hex, content="3735928559"\))' 12 TL (20  )' 12 TL (21    // Round-trip conversion)' 12 TL (22    let original = 98765432109876543210N)' 12 TL (23    let as_string = original.to_string\(\))' 12 TL (24    let parsed_back = @bigint.BigInt::from_string\(as_string\))' 12 TL (25    inspect\(original == parsed_back, content="true"\))' 12 TL (26  })' T* 12 TL T* ET
endstream
endobj
106 0 obj
<<
  /Type /Page  
  /Contents 105 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
107 0 obj
<<
  /Length 1372
>>
stream
 1 0 0 1 50 770 cm BT /F0 20 Tf (Byte Array Conversion) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Convert BigInt to and from byte arrays:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "byte conversions" {)' 12 TL (3     let big = 0x123456789abcdefN)' 12 TL (4   )' 12 TL (5     // Convert to bytes)' 12 TL (6     let bytes = big.to_octets\(\))' 12 TL (7     inspect\(bytes.length\(\) > 0, content="true"\))' 12 TL (8   )' 12 TL (9     // Convert from bytes \(positive number\))' 12 TL (10    let from_bytes = @bigint.BigInt::from_octets\(bytes\))' 12 TL (11    inspect\(from_bytes == big, content="true"\))' 12 TL (12  )' 12 TL (13    // Convert with specific length)' 12 TL (14    let fixed_length = @bigint.BigInt::from_int\(255\).to_octets\(length=4\))' 12 TL (15    inspect\(fixed_length.length\(\), content="4"\))' 12 TL (16  )' 12 TL (17    // Negative numbers)' 12 TL (18    // let negative = -big)' 12 TL (19    // let neg_bytes = negative.to_octets\(\))' 12 TL (20    // to_octets does not accept negative numbers)' 12 TL (21    // let neg_from_bytes = @bigint.BigInt::from_octets\(neg_bytes, signum=-1\))' 12 TL (22    // inspect\(neg_from_bytes == negative, content="true"\))' 12 TL (23  })' T* 12 TL T* /F0 20 Tf (Type Conversions) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Convert BigInt to standard integer types:) Tj T* 12 TL T* ET
endstream
endobj
108 0 obj
<<
  /Type /Page  
  /Contents 107 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
109 0 obj
<<
  /Length 1817
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "type conversions" {)' 12 TL (3     let big = 12345N)' 12 TL (4   )' 12 TL (5     // To Int \(truncates if too large\))' 12 TL (6     let as_int = big.to_int\(\))' 12 TL (7     inspect\(as_int, content="12345"\))' 12 TL (8   )' 12 TL (9     // To Int64)' 12 TL (10    let as_int64 = big.to_int64\(\))' 12 TL (11    inspect\(as_int64, content="12345"\))' 12 TL (12  )' 12 TL (13    // To UInt)' 12 TL (14    let as_uint = big.to_uint\(\))' 12 TL (15    inspect\(as_uint, content="12345"\))' 12 TL (16  )' 12 TL (17    // To smaller types)' 12 TL (18    let small = 255N)' 12 TL (19    let as_int16 = small.to_int16\(\))' 12 TL (20    inspect\(as_int16, content="255"\))' 12 TL (21    let as_uint16 = small.to_uint16\(\))' 12 TL (22    inspect\(as_uint16, content="255"\))' 12 TL (23  })' T* 12 TL T* /F0 20 Tf (JSON Serialization) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (BigInt values can be serialized to and from JSON:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "json serialization" {)' 12 TL (3     let big = 12345678901234567890N)' 12 TL (4   )' 12 TL (5     // Convert to JSON \(as string to preserve precision\))' 12 TL (6     let json = big.to_json\(\))' 12 TL (7     inspect\(json, content="String\(\\"12345678901234567890\\"\)"\))' 12 TL (8   )' 12 TL (9     // Large numbers that exceed JavaScript's safe integer range)' 12 TL (10    let very_big = @bigint.BigInt::from_string\("123456789012345678901234567890"\))' 12 TL (11    let big_json = very_big.to_json\(\))' 12 TL (12    inspect\(big_json, content="String\(\\"123456789012345678901234567890\\"\)"\))' 12 TL (13  })' T* 12 TL T* /F0 20 Tf (Utility Functions) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Check properties of BigInt values:) Tj T* 12 TL T* ET
endstream
endobj
110 0 obj
<<
  /Type /Page  
  /Contents 109 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
111 0 obj
<<
  /Length 3319
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "utility functions" {)' 12 TL (3     let zero = 0N)' 12 TL (4     let positive = 42N)' 12 TL (5     let negative = -42N)' 12 TL (6   )' 12 TL (7     // Check if zero)' 12 TL (8     inspect\(zero.is_zero\(\), content="true"\))' 12 TL (9     inspect\(positive.is_zero\(\), content="false"\))' 12 TL (10  )' 12 TL (11    // Sign testing through comparison)' 12 TL (12    inspect\(positive > zero, content="true"\))' 12 TL (13    inspect\(negative < zero, content="true"\))' 12 TL (14    inspect\(zero == zero, content="true"\))' 12 TL (15  })' T* 12 TL T* /F0 20 Tf (Use Cases and Applications) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (BigInt is particularly useful for:) Tj T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Cryptography) Tj /F0 12 Tf (: RSA encryption, digital signatures, and key generation) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Mathematical computations) Tj /F0 12 Tf (: Factorial calculations, Fibonacci sequences, prime nu) Tj T* (mber testing) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Financial calculations) Tj /F0 12 Tf (: High-precision monetary computations) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Scientific computing) Tj /F0 12 Tf (: Large integer calculations in physics and chemistry) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Data processing) Tj /F0 12 Tf (: Handling large numeric IDs and checksums) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Performance Considerations) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (BigInt operations are slower than regular integer operations due to arbitrary pr) Tj T* (ecision) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Addition and subtraction are generally fast) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Multiplication and division become slower with larger numbers) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Modular exponentiation is optimized for cryptographic use cases) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (String conversions can be expensive for very large numbers) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Best Practices) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Use regular integers when possible) Tj /F0 12 Tf (: Only use BigInt when you need arbitrary prec) Tj T* (ision) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Cache string representations) Tj /F0 12 Tf (: If you need to display the same BigInt multiple ti) Tj T* (mes) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Use modular arithmetic) Tj /F0 12 Tf (: For cryptographic applications, always use modular expon) Tj T* (entiation) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Be careful with conversions) Tj /F0 12 Tf (: Converting very large BigInt to regular integers wi) Tj T* (ll truncate) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Consider memory usage) Tj /F0 12 Tf (: Very large BigInt values consume more memory) Tj T* 12 TL T* -10 0 Td 12 TL T* ET
endstream
endobj
112 0 obj
<<
  /Type /Page  
  /Contents 111 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
113 0 obj
<<
  /Length 1319
>>
stream
 1 0 0 1 50 770 cm BT /F0 24 Tf (Bench Package Documentation) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides benchmarking utilities for measuring the performance of Mo) Tj T* (onBit code. It includes functions for timing code execution, collecting statisti) Tj T* (cs, and generating performance reports.) Tj T* 12 TL T* /F0 20 Tf (Basic Benchmarking) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use the ) Tj /F0 12 Tf (single_bench) Tj /F0 12 Tf ( function to benchmark individual operations:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   #skip\("slow tests"\))' 12 TL (3   test "basic benchmarking" {)' 12 TL (4     fn simple_calc\(n : Int\) -> Int {)' 12 TL (5       n * 2 + 1)' 12 TL (6     })' 12 TL (7     // Benchmark a simple computation)' 12 TL (8     let summary = @bench.single_bench\(name="simple_calc", fn\(\) {)' 12 TL (9       ignore\(simple_calc\(5\)\))' 12 TL (10    }\))' 12 TL (11  )' 12 TL (12    // The benchmark ran successfully \(we can't inspect exact timing\))' 12 TL (13    inspect\(summary.to_json\(\).stringify\(\).length\(\) > 0, content="true"\))' 12 TL (14  })' T* 12 TL T* /F0 20 Tf (Benchmark Collection) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use the ) Tj /F0 12 Tf (T) Tj /F0 12 Tf ( type to collect multiple benchmarks:) Tj T* 12 TL T* ET
endstream
endobj
114 0 obj
<<
  /Type /Page  
  /Contents 113 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
115 0 obj
<<
  /Length 1067
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   #skip\("slow tests"\))' 12 TL (3   test "benchmark collection" {)' 12 TL (4     let bencher = @bench.new\(\))' 12 TL (5   )' 12 TL (6     // Add multiple benchmarks to the collection)' 12 TL (7     bencher.bench\(name="array_creation", fn\(\) {)' 12 TL (8       let arr = Array::new\(\))' 12 TL (9       for i in 0..<5 {)' 12 TL (10        arr.push\(i\))' 12 TL (11      })' 12 TL (12    }\))' 12 TL (13    bencher.bench\(name="array_iteration", fn\(\) {)' 12 TL (14      let arr = [1, 2, 3, 4, 5])' 12 TL (15      let mut sum = 0)' 12 TL (16      for x in arr {)' 12 TL (17        sum = sum + x)' 12 TL (18      })' 12 TL (19    }\))' 12 TL (20  )' 12 TL (21    // Generate benchmark report)' 12 TL (22    let report = bencher.dump_summaries\(\))' 12 TL (23    inspect\(report.length\(\) > 0, content="true"\))' 12 TL (24  })' T* 12 TL T* /F0 20 Tf (Benchmarking Different Algorithms) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Compare the performance of different implementations:) Tj T* 12 TL T* ET
endstream
endobj
116 0 obj
<<
  /Type /Page  
  /Contents 115 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
117 0 obj
<<
  /Length 1212
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   #skip\("slow tests"\))' 12 TL (3   test "algorithm comparison" {)' 12 TL (4     let bencher = @bench.new\(\))' 12 TL (5   )' 12 TL (6     // Benchmark linear search)' 12 TL (7     bencher.bench\(name="linear_search", fn\(\) {)' 12 TL (8       let arr = [1, 2, 3, 4, 5])' 12 TL (9       let target = 3)' 12 TL (10      let mut found = false)' 12 TL (11      for x in arr {)' 12 TL (12        if x == target {)' 12 TL (13          found = true)' 12 TL (14          break)' 12 TL (15        })' 12 TL (16      })' 12 TL (17      ignore\(found\))' 12 TL (18    }\))' 12 TL (19  )' 12 TL (20    // Benchmark using built-in contains \(likely optimized\))' 12 TL (21    bencher.bench\(name="builtin_contains", fn\(\) {)' 12 TL (22      let arr = [1, 2, 3, 4, 5])' 12 TL (23      ignore\(arr.contains\(3\)\))' 12 TL (24    }\))' 12 TL (25    let results = bencher.dump_summaries\(\))' 12 TL (26    inspect\(results.length\(\) > 10, content="true"\) // Should have benchmark data)' 12 TL (27  })' T* 12 TL T* /F0 20 Tf (Data Structure Benchmarks) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Benchmark different data structure operations:) Tj T* 12 TL T* ET
endstream
endobj
118 0 obj
<<
  /Type /Page  
  /Contents 117 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
119 0 obj
<<
  /Length 2076
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   #skip\("slow tests"\))' 12 TL (3   test "data structure benchmarks" {)' 12 TL (4     let bencher = @bench.new\(\))' 12 TL (5   )' 12 TL (6     // Benchmark Array operations)' 12 TL (7     bencher.bench\(name="array_append", fn\(\) {)' 12 TL (8       let arr = Array::new\(\))' 12 TL (9       for i in 0..<5 {)' 12 TL (10        arr.push\(i\))' 12 TL (11      })' 12 TL (12    }\))' 12 TL (13  )' 12 TL (14    // Benchmark FixedArray access)' 12 TL (15    bencher.bench\(name="fixedarray_access", fn\(\) {)' 12 TL (16      let arr = [0, 1, 2, 3, 4])' 12 TL (17      let mut sum = 0)' 12 TL (18      for i in 0..<arr.length\(\) {)' 12 TL (19        sum = sum + arr[i])' 12 TL (20      })' 12 TL (21      ignore\(sum\))' 12 TL (22    }\))' 12 TL (23    let report = bencher.dump_summaries\(\))' 12 TL (24    inspect\(report.length\(\) > 50, content="true"\) // Should have benchmark data)' 12 TL (25  })' T* 12 TL T* /F0 20 Tf (String Operations Benchmarking) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Measure string manipulation performance:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   #skip\("slow tests"\))' 12 TL (3   test "string benchmarks" {)' 12 TL (4     let bencher = @bench.new\(\))' 12 TL (5   )' 12 TL (6     // Benchmark string concatenation)' 12 TL (7     bencher.bench\(name="string_concat", fn\(\) {)' 12 TL (8       let mut result = "")' 12 TL (9       for i in 0..<5 {)' 12 TL (10        result = result + "x")' 12 TL (11      })' 12 TL (12    }\))' 12 TL (13  )' 12 TL (14    // Benchmark StringBuilder \(should be faster\))' 12 TL (15    bencher.bench\(name="stringbuilder", fn\(\) {)' 12 TL (16      let builder = StringBuilder::new\(\))' 12 TL (17      for i in 0..<5 {)' 12 TL (18        builder.write_string\("x"\))' 12 TL (19      })' 12 TL (20      ignore\(builder.to_string\(\)\))' 12 TL (21    }\))' 12 TL (22    let results = bencher.dump_summaries\(\))' 12 TL (23    inspect\(results.length\(\) > 50, content="true"\) // Should have benchmark data)' 12 TL (24  })' T* ET
endstream
endobj
120 0 obj
<<
  /Type /Page  
  /Contents 119 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
121 0 obj
<<
  /Length 2103
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F0 20 Tf (Memory Usage Prevention) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use ) Tj /F0 12 Tf (keep) Tj /F0 12 Tf ( to prevent compiler optimizations from eliminating benchmarked code:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   #skip\("slow tests"\))' 12 TL (3   test "preventing optimization" {)' 12 TL (4     let bencher = @bench.new\(\))' 12 TL (5     bencher.bench\(name="with_keep", fn\(\) {)' 12 TL (6       let result = Array::makei\(5, fn\(i\) { i * i }\))' 12 TL (7       // Prevent the compiler from optimizing away the computation)' 12 TL (8       bencher.keep\(result\))' 12 TL (9     }\))' 12 TL (10    let report = bencher.dump_summaries\(\))' 12 TL (11    inspect\(report.length\(\) > 30, content="true"\) // Should have benchmark data)' 12 TL (12  })' T* 12 TL T* /F0 20 Tf (Iteration Count Control) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Control the number of benchmark iterations:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   #skip\("slow tests"\))' 12 TL (3   test "iteration control" {)' 12 TL (4     let bencher = @bench.new\(\))' 12 TL (5   )' 12 TL (6     // Run with more iterations for more stable results)' 12 TL (7     bencher.bench\()' 12 TL (8       name="stable_benchmark",)' 12 TL (9       fn\(\) {)' 12 TL (10        let arr = [1, 2, 3, 4, 5])' 12 TL (11        let sum = arr.fold\(init=0, fn\(acc, x\) { acc + x }\))' 12 TL (12        ignore\(sum\))' 12 TL (13      },)' 12 TL (14      count=20,)' 12 TL (15    \))' 12 TL (16  )' 12 TL (17    // Run with fewer iterations for quick testing)' 12 TL (18    bencher.bench\()' 12 TL (19      name="quick_benchmark",)' 12 TL (20      fn\(\) {)' 12 TL (21        let mut result = 0)' 12 TL (22        for i in 0..<10 {)' 12 TL (23          result = result + i)' 12 TL (24        })' 12 TL (25        ignore\(result\))' 12 TL (26      },)' 12 TL (27      count=2,)' 12 TL (28    \))' 12 TL (29    let results = bencher.dump_summaries\(\))' 12 TL (30    inspect\(results.length\(\) > 50, content="true"\) // Should have benchmark data)' 12 TL (31  })' T* ET
endstream
endobj
122 0 obj
<<
  /Type /Page  
  /Contents 121 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
123 0 obj
<<
  /Length 1946
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F0 20 Tf (Benchmarking Best Practices) Tj 20 TL T* 12 TL T* /F0 16 Tf (1. Isolate What You're Measuring) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   #skip\("slow tests"\))' 12 TL (3   test "isolation example" {)' 12 TL (4     let bencher = @bench.new\(\))' 12 TL (5   )' 12 TL (6     // Good: Measure only the operation of interest)' 12 TL (7     let data = Array::makei\(10, fn\(i\) { i }\) // Setup outside benchmark)' 12 TL (8     bencher.bench\(name="array_sum", fn\(\) {)' 12 TL (9       let mut sum = 0)' 12 TL (10      for x in data {)' 12 TL (11        sum = sum + x)' 12 TL (12      })' 12 TL (13      bencher.keep\(sum\) // Prevent optimization)' 12 TL (14    }\))' 12 TL (15    let results = bencher.dump_summaries\(\))' 12 TL (16    inspect\(results.length\(\) > 0, content="true"\))' 12 TL (17  })' T* 12 TL T* /F0 16 Tf (2. Warm Up Before Measuring) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   #skip\("slow tests"\))' 12 TL (3   test "warmup example" {)' 12 TL (4     let bencher = @bench.new\(\))' 12 TL (5     fn expensive_operation\(\) -> Int {)' 12 TL (6       let mut result = 0)' 12 TL (7       for i in 0..<5 {)' 12 TL (8         result = result + i * i)' 12 TL (9       })' 12 TL (10      result)' 12 TL (11    })' 12 TL (12  )' 12 TL (13    // Warm up the function \(not measured\))' 12 TL (14    for _ in 0..<5 {)' 12 TL (15      ignore\(expensive_operation\(\)\))' 12 TL (16    })' 12 TL (17  )' 12 TL (18    // Now benchmark the warmed-up function)' 12 TL (19    bencher.bench\(name="warmed_up", fn\(\) {)' 12 TL (20      let result = expensive_operation\(\))' 12 TL (21      bencher.keep\(result\))' 12 TL (22    }\))' 12 TL (23    let report = bencher.dump_summaries\(\))' 12 TL (24    inspect\(report.length\(\) > 30, content="true"\) // Should have benchmark data)' 12 TL (25  })' T* 12 TL T* /F0 16 Tf (3. Use Meaningful Names) Tj 16 TL T* 12 TL T* ET
endstream
endobj
124 0 obj
<<
  /Type /Page  
  /Contents 123 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
125 0 obj
<<
  /Length 1870
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   #skip\("slow tests"\))' 12 TL (3   test "meaningful names" {)' 12 TL (4     let bencher = @bench.new\(\))' 12 TL (5   )' 12 TL (6     // Good: Descriptive names that explain what's being measured)' 12 TL (7     bencher.bench\(name="array_insert_10_items", fn\(\) {)' 12 TL (8       let arr = Array::new\(\))' 12 TL (9       for i in 0..<10 {)' 12 TL (10        arr.push\(i * 2\))' 12 TL (11      })' 12 TL (12      bencher.keep\(arr\))' 12 TL (13    }\))' 12 TL (14    bencher.bench\(name="array_search_sorted_10", fn\(\) {)' 12 TL (15      let arr = Array::makei\(10, fn\(i\) { i }\))' 12 TL (16      let result = arr.contains\(5\) // Linear search in this case)' 12 TL (17      bencher.keep\(result\))' 12 TL (18    }\))' 12 TL (19    let results = bencher.dump_summaries\(\))' 12 TL (20    inspect\(results.length\(\) > 50, content="true"\) // Should have benchmark data)' 12 TL (21  })' T* 12 TL T* /F0 20 Tf (Performance Analysis) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The benchmark results include statistical information:) Tj T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Timing measurements) Tj /F0 12 Tf (: Microsecond precision timing) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Statistical analysis) Tj /F0 12 Tf (: Median, percentiles, and outlier detection) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Batch sizing) Tj /F0 12 Tf (: Automatic adjustment for stable measurements) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (JSON output) Tj /F0 12 Tf (: Machine-readable results for analysis) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Integration with Testing) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Benchmarks can be integrated into your testing workflow:) Tj T* 12 TL T* ET
endstream
endobj
126 0 obj
<<
  /Type /Page  
  /Contents 125 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
127 0 obj
<<
  /Length 3040
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   #skip\("slow tests"\))' 12 TL (3   test "performance regression test" {)' 12 TL (4     let bencher = @bench.new\(\))' 12 TL (5   )' 12 TL (6     // Benchmark a critical path)' 12 TL (7     bencher.bench\(name="critical_algorithm", fn\(\) {)' 12 TL (8       let data = [5, 2, 8, 1, 9, 3, 7, 4, 6])' 12 TL (9       let sorted = Array::new\(\))' 12 TL (10      for x in data {)' 12 TL (11        sorted.push\(x\))' 12 TL (12      })' 12 TL (13      sorted.sort\(\))' 12 TL (14      bencher.keep\(sorted\))' 12 TL (15    }\))' 12 TL (16    let results = bencher.dump_summaries\(\))' 12 TL (17    // In a real scenario, you might parse results and assert performance bounds)' 12 TL (18    inspect\(results.length\(\) > 50, content="true"\) // Should have substantial data)' 12 TL (19  })' T* 12 TL T* /F0 20 Tf (Common Benchmarking Patterns) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Before/After comparisons) Tj /F0 12 Tf (: Benchmark code before and after optimizations) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Algorithm comparison) Tj /F0 12 Tf (: Compare different implementations of the same functionalit) Tj T* (y) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Scaling analysis) Tj /F0 12 Tf (: Benchmark with different input sizes) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Memory vs. speed tradeoffs) Tj /F0 12 Tf (: Compare memory-efficient vs. speed-optimized approac) Tj T* (hes) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Platform differences) Tj /F0 12 Tf (: Compare performance across different targets \(JS, WASM, n) Tj T* (ative\)) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Tips for Accurate Benchmarks) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Run benchmarks multiple times and look for consistency) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Be aware of system load and other processes affecting timing) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Use appropriate iteration counts \(more for stable results, fewer for quick feed) Tj T* (back\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Measure what matters to your use case) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Consider both average case and worst case performance) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Profile memory usage separately if memory performance is important) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The bench package provides essential tools for performance analysis and optimiza) Tj T* (tion in MoonBit applications.) Tj T* 12 TL T* /F0 24 Tf (cmp) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides utility functions for comparing values.) Tj T* 12 TL T* /F0 20 Tf (Generic Comparison Functions) Tj 20 TL T* 12 TL T* ET
endstream
endobj
128 0 obj
<<
  /Type /Page  
  /Contents 127 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
129 0 obj
<<
  /Length 2401
>>
stream
 1 0 0 1 50 770 cm BT 12 TL /F0 12 Tf /F0 12 Tf (The library provides generic comparison functions that work with any type implem) Tj T* (enting the ) Tj /F0 12 Tf (Compare) Tj /F0 12 Tf ( trait:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "generic comparison" {)' 12 TL (3     // Works with numbers)' 12 TL (4     inspect\(@cmp.maximum\(3, 4\), content="4"\))' 12 TL (5     inspect\(@cmp.minimum\(3, 4\), content="3"\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Comparison by Key) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (With ) Tj /F0 12 Tf (@cmp.maximum_by_key\(\)) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (@cmp.minimum_by_key\(\)) Tj /F0 12 Tf (, it is possible to comp) Tj T* (are values based on arbitrary keys derived from the them. This is particularly u) Tj T* (seful when you need to compare complex objects based on some specific aspect or ) Tj T* (field.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "cmp_by_key" {)' 12 TL (3     struct Person {)' 12 TL (4       name : String)' 12 TL (5       age : Int)' 12 TL (6     } derive\(Show\))' 12 TL (7   )' 12 TL (8     // Compare strings by their length)' 12 TL (9     let s1 = "hello")' 12 TL (10    let s2 = "hi")' 12 TL (11    let longer = @cmp.maximum_by_key\(s1, s2, String::length\))' 12 TL (12    inspect\(longer, content="hello"\))' 12 TL (13  )' 12 TL (14    // Compare structs by a specific field)' 12 TL (15    let alice = { name: "Alice", age: 25 })' 12 TL (16    let bob = { name: "Bob", age: 30 })' 12 TL (17    let younger = @cmp.minimum_by_key\(alice, bob, p => p.age\))' 12 TL (18    inspect\(younger, content="{name: \\"Alice\\", age: 25}"\))' 12 TL (19  )' 12 TL (20    // When keys are equal, the first argument is considered the minimum)' 12 TL (21    let p1 = \("first", 1\))' 12 TL (22    let p2 = \("second", 1\))' 12 TL (23    let snd = \(p : \(_, _\)\) => p.1)' 12 TL (24    assert_eq\(@cmp.minimum_by_key\(p1, p2, snd\), p1\))' 12 TL (25    assert_eq\(@cmp.maximum_by_key\(p1, p2, snd\), p2\))' 12 TL (26  })' T* 12 TL T* /F0 24 Tf (math) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This library provides common mathematical functions for floating-point arithmeti) Tj T* (c, trigonometry, and general numeric comparisons.) Tj T* 12 TL T* /F0 20 Tf (Constants) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (MoonBit math library provides the mathematical constant \300\003:) Tj T* ET
endstream
endobj
130 0 obj
<<
  /Type /Page  
  /Contents 129 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
131 0 obj
<<
  /Length 2096
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "mathematical constants" {)' 12 TL (3     inspect\(@math.PI, content="3.141592653589793"\))' 12 TL (4   })' T* 12 TL T* /F0 20 Tf (Basic Arithmetic Functions) Tj 20 TL T* 12 TL T* /F0 16 Tf (Rounding Functions) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Several functions are available for rounding numbers in different ways:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "rounding functions" {)' 12 TL (3     // Round to nearest integer)' 12 TL (4     inspect\(@math.round\(3.7\), content="4"\))' 12 TL (5     inspect\(@math.round\(-3.7\), content="-4"\))' 12 TL (6   )' 12 TL (7     // Ceiling \(round up\))' 12 TL (8     inspect\(@math.ceil\(3.2\), content="4"\))' 12 TL (9     inspect\(@math.ceil\(-3.2\), content="-3"\))' 12 TL (10  )' 12 TL (11    // Floor \(round down\))' 12 TL (12    inspect\(@math.floor\(3.7\), content="3"\))' 12 TL (13    inspect\(@math.floor\(-3.7\), content="-4"\))' 12 TL (14  )' 12 TL (15    // Truncate \(round toward zero\))' 12 TL (16    inspect\(@math.trunc\(3.7\), content="3"\))' 12 TL (17    inspect\(@math.trunc\(-3.7\), content="-3"\))' 12 TL (18  })' T* 12 TL T* /F0 16 Tf (Exponential and Logarithmic Functions) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The library provides standard exponential and logarithmic operations:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "exponential and logarithmic" {)' 12 TL (3     // Exponential functions)' 12 TL (4     inspect\(@math.exp\(1.0\), content="2.718281828459045"\))' 12 TL (5     inspect\(@math.expm1\(1.0\), content="1.718281828459045"\))' 12 TL (6   )' 12 TL (7     // Natural logarithm)' 12 TL (8     inspect\(@math.ln\(2.718281828459045\), content="1"\))' 12 TL (9     inspect\(@math.ln_1p\(1.718281828459045\), content="1"\))' 12 TL (10  )' 12 TL (11    // Other logarithm bases)' 12 TL (12    inspect\(@math.log2\(8.0\), content="3"\))' 12 TL (13    inspect\(@math.log10\(100.0\), content="2"\))' 12 TL (14  })' T* 12 TL T* /F0 20 Tf (Trigonometric Functions) Tj 20 TL T* 12 TL T* ET
endstream
endobj
132 0 obj
<<
  /Type /Page  
  /Contents 131 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
133 0 obj
<<
  /Length 2343
>>
stream
 1 0 0 1 50 770 cm BT /F0 16 Tf (Basic Trigonometric Functions) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Standard trigonometric functions operating in radians:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "basic trigonometry" {)' 12 TL (3     // Basic trig functions)' 12 TL (4     inspect\(@math.sin\(@math.PI / 2.0\), content="1"\))' 12 TL (5     inspect\(@math.cos\(0.0\), content="1"\))' 12 TL (6     inspect\(@math.tan\(@math.PI / 4.0\), content="0.9999999999999999"\))' 12 TL (7   )' 12 TL (8     // Inverse trig functions)' 12 TL (9     inspect\(@math.asin\(1.0\), content="1.5707963267948966"\))' 12 TL (10    inspect\(@math.acos\(1.0\), content="0"\))' 12 TL (11    inspect\(@math.atan\(1.0\), content="0.7853981633974483"\))' 12 TL (12  })' T* 12 TL T* /F0 16 Tf (Hyperbolic Functions) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The library also includes hyperbolic functions and their inverses:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "hyperbolic functions" {)' 12 TL (3     // Hyperbolic functions)' 12 TL (4     inspect\(@math.sinh\(1.0\), content="1.1752011936438014"\))' 12 TL (5     inspect\(@math.cosh\(1.0\), content="1.5430806348152437"\))' 12 TL (6     inspect\(@math.tanh\(1.0\), content="0.7615941559557649"\))' 12 TL (7   )' 12 TL (8     // Inverse hyperbolic functions)' 12 TL (9     inspect\(@math.asinh\(1.0\), content="0.881373587019543"\))' 12 TL (10    inspect\(@math.acosh\(2.0\), content="1.3169578969248166"\))' 12 TL (11    inspect\(@math.atanh\(0.5\), content="0.5493061443340548"\))' 12 TL (12  })' T* 12 TL T* /F0 20 Tf (Special Functions) Tj 20 TL T* 12 TL T* /F0 16 Tf (Two-argument Functions) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Some special mathematical functions taking two arguments:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "special functions" {)' 12 TL (3     // atan2 gives the angle in radians between the positive x-axis and the ray to point \(x,y\))' 12 TL (4     inspect\(@math.atan2\(1.0, 1.0\), content="0.7853981633974483"\))' 12 TL (5   )' 12 TL (6     // hypot computes sqrt\(x*x + y*y\) without intermediate overflow)' 12 TL (7     inspect\(@math.hypot\(3.0, 4.0\), content="5"\))' 12 TL (8   )' 12 TL (9     // Cube root)' 12 TL (10    inspect\(@math.cbrt\(8.0\), content="2"\))' 12 TL (11  })' T* 12 TL T* ET
endstream
endobj
134 0 obj
<<
  /Type /Page  
  /Contents 133 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
135 0 obj
<<
  /Length 2047
>>
stream
 1 0 0 1 50 770 cm BT /F0 24 Tf (ref) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides functionality for working with mutable references, allowin) Tj T* (g you to create sharable mutable values that can be modified safely.) Tj T* 12 TL T* /F0 20 Tf (Creating and Accessing References) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (References can be created using ) Tj /F0 12 Tf (@ref.new\(\)) Tj /F0 12 Tf (. The reference value can be accesse) Tj T* (d through the ) Tj /F0 12 Tf (val) Tj /F0 12 Tf ( field:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "creating and accessing refs" {)' 12 TL (3     let r1 = @ref.new\(42\))' 12 TL (4     inspect\(r1.val, content="42"\))' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Updating Reference Values) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (update) Tj /F0 12 Tf ( function allows modifying the contained value using a transformation ) Tj T* (function:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "updating refs" {)' 12 TL (3     let counter = @ref.new\(0\))' 12 TL (4     counter.update\(x => x + 1\))' 12 TL (5     inspect\(counter.val, content="1"\))' 12 TL (6     counter.update\(x => x * 2\))' 12 TL (7     inspect\(counter.val, content="2"\))' 12 TL (8   })' T* 12 TL T* /F0 20 Tf (Mapping References) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (map) Tj /F0 12 Tf ( function transforms a reference while preserving the reference wrapper:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "mapping refs" {)' 12 TL (3     let num = @ref.new\(10\))' 12 TL (4     let doubled = num.map\(x => x * 2\))' 12 TL (5     inspect\(doubled.val, content="20"\))' 12 TL (6     let squared = num.map\(x => x * x\))' 12 TL (7     inspect\(squared.val, content="100"\))' 12 TL (8   })' T* 12 TL T* /F0 20 Tf (Swapping Reference Values) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can exchange the values of two references using the ) Tj /F0 12 Tf (swap) Tj /F0 12 Tf ( function:) Tj T* 12 TL T* ET
endstream
endobj
136 0 obj
<<
  /Type /Page  
  /Contents 135 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
137 0 obj
<<
  /Length 1689
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "swapping refs" {)' 12 TL (3     let r1 = @ref.new\("first"\))' 12 TL (4     let r2 = @ref.new\("second"\))' 12 TL (5     @ref.swap\(r1, r2\))' 12 TL (6     inspect\(r1.val, content="second"\))' 12 TL (7     inspect\(r2.val, content="first"\))' 12 TL (8   })' T* 12 TL T* /F0 20 Tf (Temporary Value Protection) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (protect) Tj /F0 12 Tf ( function temporarily sets a reference to a value and restores it aft) Tj T* (er executing a block:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "protected updates" {)' 12 TL (3     let state = @ref.new\(100\))' 12 TL (4     let mut middle = 0)' 12 TL (5     let result = state.protect\(50, \(\) => {)' 12 TL (6       middle = state.val)' 12 TL (7       42)' 12 TL (8     }\))' 12 TL (9     inspect\(middle, content="50"\))' 12 TL (10    inspect\(result, content="42"\))' 12 TL (11    inspect\(state.val, content="100"\))' 12 TL (12  })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This is useful for temporarily modifying state that needs to be restored afterwa) Tj T* (rds.) Tj T* 12 TL T* /F0 24 Tf (bytes) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides utilities for working with sequences of bytes, offering bo) Tj T* (th mutable \() Tj /F0 12 Tf (Bytes) Tj /F0 12 Tf (\) and immutable \() Tj /F0 12 Tf (View) Tj /F0 12 Tf (\) representations.) Tj T* 12 TL T* /F0 20 Tf (Creating Bytes) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can create ) Tj /F0 12 Tf (Bytes) Tj /F0 12 Tf ( from various sources including arrays, fixed arrays, and it) Tj T* (erators:) Tj T* 12 TL T* ET
endstream
endobj
138 0 obj
<<
  /Type /Page  
  /Contents 137 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
139 0 obj
<<
  /Length 1452
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "bytes creation" {)' 12 TL (3     // Create from array of bytes)' 12 TL (4     let arr = [b'h', b'e', b'l', b'l', b'o'])' 12 TL (5     let bytes1 = @bytes.from_array\(arr\))' 12 TL (6     inspect\()' 12 TL (7       bytes1,)' 12 TL (8       content=\()' 12 TL (9         #|b"\\x68\\x65\\x6c\\x6c\\x6f")' 12 TL (10      \),)' 12 TL (11    \))' 12 TL (12  )' 12 TL (13    // Create from fixed array)' 12 TL (14    let fixed = FixedArray::make\(3, b'a'\))' 12 TL (15    let bytes2 = @bytes.of\(fixed\))' 12 TL (16    inspect\()' 12 TL (17      bytes2,)' 12 TL (18      content=\()' 12 TL (19        #|b"\\x61\\x61\\x61")' 12 TL (20      \),)' 12 TL (21    \))' 12 TL (22  )' 12 TL (23    // Create empty bytes)' 12 TL (24    let empty = @bytes.default\(\))' 12 TL (25    inspect\()' 12 TL (26      empty,)' 12 TL (27      content=\()' 12 TL (28        #|b"")' 12 TL (29      \),)' 12 TL (30    \))' 12 TL (31  )' 12 TL (32    // Create from iterator)' 12 TL (33    let iter_bytes = @bytes.from_iter\(arr.iter\(\)\))' 12 TL (34    inspect\()' 12 TL (35      iter_bytes,)' 12 TL (36      content=\()' 12 TL (37        #|b"\\x68\\x65\\x6c\\x6c\\x6f")' 12 TL (38      \),)' 12 TL (39    \))' 12 TL (40  })' T* 12 TL T* /F0 20 Tf (Converting Between Formats) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Bytes) Tj /F0 12 Tf ( can be converted to and from different formats:) Tj T* 12 TL T* ET
endstream
endobj
140 0 obj
<<
  /Type /Page  
  /Contents 139 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
141 0 obj
<<
  /Length 2072
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "bytes conversion" {)' 12 TL (3     let original = [b'x', b'y', b'z'])' 12 TL (4     let bytes = @bytes.from_array\(original\))' 12 TL (5   )' 12 TL (6     // Convert to array)' 12 TL (7     let array = bytes.to_array\(\))' 12 TL (8     inspect\(array, content="[b'\\\\x78', b'\\\\x79', b'\\\\x7A']"\))' 12 TL (9   )' 12 TL (10    // Convert to fixed array)' 12 TL (11    let fixed = bytes.to_fixedarray\(\))' 12 TL (12    inspect\(fixed, content="[b'\\\\x78', b'\\\\x79', b'\\\\x7A']"\))' 12 TL (13  )' 12 TL (14    // Convert to iterator and collect back)' 12 TL (15    let collected = bytes.iter\(\).to_array\(\))' 12 TL (16    inspect\(collected, content="[b'\\\\x78', b'\\\\x79', b'\\\\x7A']"\))' 12 TL (17  })' T* 12 TL T* /F0 20 Tf (Working with Views) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Views provide a way to work with portions of bytes and interpret them as various) Tj T* ( numeric types:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "bytes view operations" {)' 12 TL (3     // Create bytes with numeric data)' 12 TL (4     let num_bytes = @bytes.from_array\([0x12, 0x34, 0x56, 0x78]\))' 12 TL (5   )' 12 TL (6     // Create a view)' 12 TL (7     let view = num_bytes[:])' 12 TL (8   )' 12 TL (9     // Get individual bytes)' 12 TL (10    inspect\(view[0], content="b'\\\\x12'"\))' 12 TL (11  )' 12 TL (12    // Interpret as integers \(big-endian\))' 12 TL (13    inspect\(view.to_int_be\(\), content="305419896"\))' 12 TL (14  )' 12 TL (15    // Interpret as integers \(little-endian\))' 12 TL (16    inspect\(view.to_int_le\(\), content="2018915346"\))' 12 TL (17  )' 12 TL (18    // Create a sub-view)' 12 TL (19    let sub_view = view[1:3])' 12 TL (20    inspect\(sub_view.length\(\), content="2"\))' 12 TL (21  })' T* 12 TL T* /F0 20 Tf (Binary Data Interpretation) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Views provide methods to interpret byte sequences as various numeric types in bo) Tj T* (th little-endian and big-endian formats:) Tj T* 12 TL T* ET
endstream
endobj
142 0 obj
<<
  /Type /Page  
  /Contents 141 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
143 0 obj
<<
  /Length 1823
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "numeric interpretation" {)' 12 TL (3     // Create test data)' 12 TL (4     let int64_bytes = @bytes.from_array\([)' 12 TL (5       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42,)' 12 TL (6     ]\))' 12 TL (7     let int64_view = int64_bytes[:])' 12 TL (8     inspect\(int64_view.to_int64_be\(\), content="66"\))' 12 TL (9     inspect\(int64_view.to_uint64_le\(\), content="4755801206503243776"\))' 12 TL (10  })' T* 12 TL T* /F0 20 Tf (Concatenation and Comparison) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Bytes can be concatenated and compared:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "bytes operations" {)' 12 TL (3     let b1 = @bytes.from_array\([b'a', b'b']\))' 12 TL (4     let b2 = @bytes.from_array\([b'c', b'd']\))' 12 TL (5   )' 12 TL (6     // Concatenation)' 12 TL (7     let combined = b1 + b2)' 12 TL (8     inspect\()' 12 TL (9       combined,)' 12 TL (10      content=\()' 12 TL (11        #|b"\\x61\\x62\\x63\\x64")' 12 TL (12      \),)' 12 TL (13    \))' 12 TL (14  )' 12 TL (15    // Comparison)' 12 TL (16    let same = @bytes.from_array\([b'a', b'b']\))' 12 TL (17    let different = @bytes.from_array\([b'x', b'y']\))' 12 TL (18    inspect\(b1 == same, content="true"\))' 12 TL (19    inspect\(b1 == different, content="false"\))' 12 TL (20    inspect\(b1 < b2, content="true"\))' 12 TL (21  })' T* 12 TL T* /F0 24 Tf (char) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides a set of utilities for working with characters, focusing o) Tj T* (n character classification and validation.) Tj T* 12 TL T* /F0 20 Tf (Basic ASCII Classification) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Functions for determining if a character belongs to various ASCII categories.) Tj T* 12 TL T* ET
endstream
endobj
144 0 obj
<<
  /Type /Page  
  /Contents 143 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
145 0 obj
<<
  /Length 2141
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "ascii classification" {)' 12 TL (3     // Basic ASCII checks)' 12 TL (4     inspect\('A'.is_ascii\(\), content="true"\))' 12 TL (5     inspect\('?'.is_ascii\(\), content="false"\))' 12 TL (6   )' 12 TL (7     // Letter classification)' 12 TL (8     inspect\('Z'.is_ascii_alphabetic\(\), content="true"\))' 12 TL (9     inspect\('1'.is_ascii_alphabetic\(\), content="false"\))' 12 TL (10  )' 12 TL (11    // Case classification)' 12 TL (12    inspect\('A'.is_ascii_uppercase\(\), content="true"\))' 12 TL (13    inspect\('a'.is_ascii_uppercase\(\), content="false"\))' 12 TL (14    inspect\('a'.is_ascii_lowercase\(\), content="true"\))' 12 TL (15    inspect\('A'.is_ascii_lowercase\(\), content="false"\))' 12 TL (16  })' T* 12 TL T* /F0 20 Tf (Number Classification) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Functions for identifying digits in different number bases.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "number classification" {)' 12 TL (3     // Decimal digits)' 12 TL (4     inspect\('5'.is_ascii_digit\(\), content="true"\))' 12 TL (5     inspect\('x'.is_ascii_digit\(\), content="false"\))' 12 TL (6   )' 12 TL (7     // Hexadecimal digits)' 12 TL (8     inspect\('F'.is_ascii_hexdigit\(\), content="true"\))' 12 TL (9     inspect\('G'.is_ascii_hexdigit\(\), content="false"\))' 12 TL (10  )' 12 TL (11    // Octal digits)' 12 TL (12    inspect\('7'.is_ascii_octdigit\(\), content="true"\))' 12 TL (13    inspect\('8'.is_ascii_octdigit\(\), content="false"\))' 12 TL (14  )' 12 TL (15    // Custom base digits)' 12 TL (16    inspect\('5'.is_digit\(6U\), content="true"\))' 12 TL (17    inspect\('6'.is_digit\(6U\), content="false"\))' 12 TL (18  )' 12 TL (19    // General numeric characters)' 12 TL (20    inspect\('1'.is_numeric\(\), content="true"\))' 12 TL (21    inspect\('A'.is_numeric\(\), content="false"\))' 12 TL (22  })' T* 12 TL T* /F0 20 Tf (Special Characters) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Functions for identifying whitespace, control characters and other special chara) Tj T* (cters.) Tj T* 12 TL T* ET
endstream
endobj
146 0 obj
<<
  /Type /Page  
  /Contents 145 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
147 0 obj
<<
  /Length 2208
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "special characters" {)' 12 TL (3     // Whitespace characters)' 12 TL (4     inspect\(' '.is_ascii_whitespace\(\), content="true"\))' 12 TL (5     inspect\('\\n'.is_whitespace\(\), content="true"\))' 12 TL (6   )' 12 TL (7     // Control characters)' 12 TL (8     inspect\('\\u0000'.is_ascii_control\(\), content="true"\))' 12 TL (9     inspect\('\\u007F'.is_control\(\), content="true"\))' 12 TL (10  )' 12 TL (11    // Graphic and punctuation characters)' 12 TL (12    inspect\('!'.is_ascii_graphic\(\), content="true"\))' 12 TL (13    inspect\(' '.is_ascii_graphic\(\), content="false"\))' 12 TL (14    inspect\(','.is_ascii_punctuation\(\), content="true"\))' 12 TL (15  })' T* 12 TL T* /F0 20 Tf (Method Style Usage) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (All character classification functions can also be called as methods directly on) Tj T* ( characters.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "method style" {)' 12 TL (3     // Letter methods)' 12 TL (4     let c = 'A')' 12 TL (5     inspect\(c.is_ascii\(\), content="true"\))' 12 TL (6     inspect\(c.is_ascii_alphabetic\(\), content="true"\))' 12 TL (7     inspect\(c.is_ascii_uppercase\(\), content="true"\))' 12 TL (8   )' 12 TL (9     // Digit methods)' 12 TL (10    let d = '7')' 12 TL (11    inspect\(d.is_ascii_digit\(\), content="true"\))' 12 TL (12    inspect\(d.is_digit\(8U\), content="true"\))' 12 TL (13    inspect\(d.is_ascii_hexdigit\(\), content="true"\))' 12 TL (14  )' 12 TL (15    // Special character methods)' 12 TL (16    let s = ' ')' 12 TL (17    inspect\(s.is_ascii_whitespace\(\), content="true"\))' 12 TL (18    inspect\(s.is_whitespace\(\), content="true"\))' 12 TL (19  })' T* 12 TL T* /F0 24 Tf (Deque) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Deque is a double-ended queue implemented as a round-robin queue, supporting O\() Tj T* (1\) head or tail insertion and querying, just like double-ended queues in other ) Tj T* (languages\(C++ std::deque / Rust VecDeque\), here deque also supports random acc) Tj T* (ess.) Tj T* 12 TL T* /F0 24 Tf (Usage) Tj 24 TL T* 12 TL T* /F0 20 Tf (Create) Tj 20 TL T* 12 TL T* ET
endstream
endobj
148 0 obj
<<
  /Type /Page  
  /Contents 147 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
149 0 obj
<<
  /Length 2372
>>
stream
 1 0 0 1 50 770 cm BT 12 TL /F0 12 Tf /F0 12 Tf (You can create a deque manually via the ) Tj /F0 12 Tf (new\(\)) Tj /F0 12 Tf ( or construct it using the ) Tj /F0 12 Tf (of\(\)) Tj /F0 12 Tf () Tj T* (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let _dv : @deque.Deque[Int] = @deque.new\(\))' 12 TL (4     let _dv = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (5   )' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (If you want to set the length at creation time to minimize expansion consumption) Tj T* (, you can add parameter ) Tj /F0 12 Tf (capacity) Tj /F0 12 Tf ( to the ) Tj /F0 12 Tf (new\(\)) Tj /F0 12 Tf ( function.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let _dv : @deque.Deque[Int] = @deque.new\(capacity=10\))' 12 TL (4   )' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Length & Capacity) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A deque is an indefinite-length, auto-expandable datatype. You can use ) Tj /F0 12 Tf (length\(\) Tj T* ()) Tj /F0 12 Tf ( to get the number of elements in the current queue, or ) Tj /F0 12 Tf (capacity\(\)) Tj /F0 12 Tf ( to get the) Tj T* ( current capacity.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(dv.length\(\), 5\))' 12 TL (5     assert_eq\(dv.capacity\(\), 5\))' 12 TL (6   })' T* 12 TL /F0 12 Tf /F0 12 Tf (Similarly, you can use the ) Tj /F0 12 Tf (is_empty) Tj /F0 12 Tf ( to determine whether the queue is empty.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv : @deque.Deque[Int] = @deque.new\(\))' 12 TL (4     assert_eq\(dv.is_empty\(\), true\))' 12 TL (5   })' T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (reserve_capacity) Tj /F0 12 Tf ( to reserve capacity, ensures that it can hold at le) Tj T* (ast the number of elements) Tj /F0 12 Tf ( ) Tj /F0 12 Tf (specified by the ) Tj /F0 12 Tf (capacity) Tj /F0 12 Tf ( argument.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.of\([1]\))' 12 TL (4     dv.reserve_capacity\(10\))' 12 TL (5     assert_eq\(dv.capacity\(\), 10\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Also, you can use ) Tj /F0 12 Tf (shrink_to_fit) Tj /F0 12 Tf ( to shrink the capacity of the deque.) Tj T* 12 TL T* ET
endstream
endobj
150 0 obj
<<
  /Type /Page  
  /Contents 149 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
151 0 obj
<<
  /Length 2288
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.new\(capacity=10\))' 12 TL (4     dv.push_back\(1\))' 12 TL (5     dv.push_back\(2\))' 12 TL (6     dv.push_back\(3\))' 12 TL (7     assert_eq\(dv.capacity\(\), 10\))' 12 TL (8     dv.shrink_to_fit\(\))' 12 TL (9     assert_eq\(dv.capacity\(\), 3\))' 12 TL (10  })' T* 12 TL T* /F0 20 Tf (Front & Back & Get) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (front\(\)) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (back\(\)) Tj /F0 12 Tf ( to get the head and tail elements of the queu) Tj T* (e, respectively. Since the queue may be empty, their return values are both ) Tj /F0 12 Tf (Opti) Tj T* (on) Tj /F0 12 Tf (, or ) Tj /F0 12 Tf (None) Tj /F0 12 Tf ( if the queue is empty.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(dv.front\(\), Some\(1\)\))' 12 TL (5     assert_eq\(dv.back\(\), Some\(5\)\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can also use ) Tj /F0 12 Tf (get) Tj /F0 12 Tf ( to access elements of the queue directly, but be careful no) Tj T* (t to cross the boundaries!) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(dv[0], 1\))' 12 TL (5     assert_eq\(dv[4], 5\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Push & Set) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Since the queue is bi-directional, you can use ) Tj /F0 12 Tf (push_front\(\)) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (push_back\(\)) Tj /F0 12 Tf ( ) Tj T* (to add values to the head or tail of the queue, respectively.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (4     dv.push_front\(6\))' 12 TL (5     dv.push_front\(7\))' 12 TL (6     dv.push_back\(8\))' 12 TL (7     dv.push_back\(9\))' 12 TL (8     //now: 6 7 1 2 3 4 5 8 9)' 12 TL (9   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can also use ) Tj /F0 12 Tf (Deque::set) Tj /F0 12 Tf ( or operator ) Tj /F0 12 Tf (_[_]=_) Tj /F0 12 Tf (to set elements of the queue direc) Tj T* (tly, but be careful not to cross the boundaries!) Tj T* 12 TL T* ET
endstream
endobj
152 0 obj
<<
  /Type /Page  
  /Contents 151 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
153 0 obj
<<
  /Length 2237
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (4     dv[0] = 5)' 12 TL (5     assert_eq\(dv[0], 5\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Pop) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (pop_front\(\)) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (pop_back\(\)) Tj /F0 12 Tf ( to pop the element at the head or tai) Tj T* (l of the queue, respectively, and like [Front & Back]\(#Front & Back & Get\), th) Tj T* (eir return values are ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf (, loaded with the value of the element being popped.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (4     let _back = dv.pop_back\(\) // Some\(5\))' 12 TL (5     assert_eq\(dv.back\(\), Some\(4\)\))' 12 TL (6     let _front = dv.pop_front\(\) //Some\(1\))' 12 TL (7     assert_eq\(dv.front\(\), Some\(2\)\))' 12 TL (8     assert_eq\(dv.length\(\), 3\))' 12 TL (9   })' T* 12 TL /F0 12 Tf /F0 12 Tf (If you only want to pop an element without getting the return value, you can use) Tj T* ( ) Tj /F0 12 Tf (unsafe_pop_front\(\)) Tj /F0 12 Tf ( with ) Tj /F0 12 Tf (unsafe_pop_back\(\)) Tj /F0 12 Tf (. These two functions will panic i) Tj T* (f the queue is empty.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (4     dv.unsafe_pop_front\(\))' 12 TL (5     assert_eq\(dv.front\(\), Some\(2\)\))' 12 TL (6     dv.unsafe_pop_back\(\))' 12 TL (7     assert_eq\(dv.back\(\), Some\(4\)\))' 12 TL (8   })' T* 12 TL T* /F0 20 Tf (Clear) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (clear) Tj /F0 12 Tf ( to clear a deque. But note that the memory it already occupies) Tj T* ( does not change.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (4     dv.clear\(\))' 12 TL (5     assert_eq\(dv.is_empty\(\), true\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Equal) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (deque supports comparing them directly using ) Tj /F0 12 Tf (equal) Tj /F0 12 Tf (.) Tj T* 12 TL T* ET
endstream
endobj
154 0 obj
<<
  /Type /Page  
  /Contents 153 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
155 0 obj
<<
  /Length 2351
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dqa = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (4     let dqb = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (5     assert_eq\(dqa, dqb\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Iter & Map) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (deque supports vector-like ) Tj /F0 12 Tf (iter/iteri/map/mapi) Tj /F0 12 Tf ( functions and their inverse forms) Tj T* (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (4     let arr = [])' 12 TL (5     dv.each\(elem => arr.push\(elem\)\))' 12 TL (6     assert_eq\(arr, [1, 2, 3, 4, 5]\))' 12 TL (7     let arr2 = [])' 12 TL (8     dv.eachi\(\(i, _elem\) => arr2.push\(i\)\))' 12 TL (9     assert_eq\(arr2, [0, 1, 2, 3, 4]\))' 12 TL (10    let arr3 = [])' 12 TL (11    let _ = dv.map\(elem => arr3.push\(elem + 1\)\))' 12 TL (12    assert_eq\(arr3, [2, 3, 4, 5, 6]\))' 12 TL (13    let arr4 = [])' 12 TL (14    let _ = dv.mapi\(\(i, elem\) => arr4.push\(elem + i\)\))' 12 TL (15    assert_eq\(arr4, [1, 3, 5, 7, 9]\))' 12 TL (16  })' T* 12 TL T* /F0 20 Tf (Search & Contains) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (contains\(\)) Tj /F0 12 Tf ( to find out if a value is in the deque, or ) Tj /F0 12 Tf (search\(\)) Tj /F0 12 Tf ( t) Tj T* (o find its index in the deque.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dv = @deque.of\([1, 2, 3, 4, 5]\))' 12 TL (4     assert_eq\(dv.contains\(1\), true\))' 12 TL (5     assert_eq\(dv.contains\(6\), false\))' 12 TL (6     assert_eq\(dv.search\(1\), Some\(0\)\))' 12 TL (7     assert_eq\(dv.search\(6\), None\))' 12 TL (8   })' T* 12 TL T* /F0 24 Tf (Error Package Documentation) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides utilities for working with MoonBit's error handling system) Tj T* (, including implementations of ) Tj /F0 12 Tf (Show) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (ToJson) Tj /F0 12 Tf ( traits for the built-in ) Tj /F0 12 Tf (Error) Tj /F0 12 Tf ( typ) Tj T* (e.) Tj T* 12 TL T* /F0 20 Tf (Basic Error Usage) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (MoonBit uses a structured error system with ) Tj /F0 12 Tf (raise) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (try) Tj /F0 12 Tf ( constructs:) Tj T* ET
endstream
endobj
156 0 obj
<<
  /Type /Page  
  /Contents 155 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
157 0 obj
<<
  /Length 872
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "basic error handling" {)' 12 TL (3     fn divide\(a : Int, b : Int\) -> Int raise {)' 12 TL (4       if b == 0 {)' 12 TL (5         raise Failure\("Division by zero"\))' 12 TL (6       } else {)' 12 TL (7         a / b)' 12 TL (8       })' 12 TL (9     })' 12 TL (10  )' 12 TL (11    // Successful operation)' 12 TL (12    let result1 = try! divide\(10, 2\))' 12 TL (13    inspect\(result1, content="5"\))' 12 TL (14  )' 12 TL (15    // Handle error with try?)' 12 TL (16    let result2 = try? divide\(10, 0\))' 12 TL (17    inspect\(result2, content="Err\(Failure\(\\"Division by zero\\"\)\)"\))' 12 TL (18  })' T* 12 TL T* /F0 20 Tf (Custom Error Types) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Define custom error types using ) Tj /F0 12 Tf (suberror) Tj /F0 12 Tf (:) Tj T* 12 TL T* ET
endstream
endobj
158 0 obj
<<
  /Type /Page  
  /Contents 157 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
159 0 obj
<<
  /Length 1703
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   suberror ValidationError String)' 12 TL (3   )' 12 TL (4   ///|)' 12 TL (5   suberror NetworkError String)' 12 TL (6   )' 12 TL (7   ///|)' 12 TL (8   test "custom errors" {)' 12 TL (9     fn validate_email\(email : String\) -> String raise ValidationError {)' 12 TL (10      if email.length\(\) > 5 { // Simple validation without string methods)' 12 TL (11        email)' 12 TL (12      } else {)' 12 TL (13        raise ValidationError\("Invalid email format"\))' 12 TL (14      })' 12 TL (15    })' 12 TL (16  )' 12 TL (17    fn fetch_data\(url : String\) -> String raise NetworkError {)' 12 TL (18      if url.length\(\) > 10 { // Simple validation)' 12 TL (19        "data")' 12 TL (20      } else {)' 12 TL (21        raise NetworkError\("Invalid URL"\))' 12 TL (22      })' 12 TL (23    })' 12 TL (24  )' 12 TL (25    // Test validation error)' 12 TL (26    let email_result = try? validate_email\("short"\))' 12 TL (27    match email_result {)' 12 TL (28      Ok\(_\) => inspect\(false, content="true"\))' 12 TL (29      Err\(_\) => inspect\(true, content="true"\))' 12 TL (30    })' 12 TL (31  )' 12 TL (32    // Test network error  )' 12 TL (33    let data_result = try? fetch_data\("short"\))' 12 TL (34    match data_result {)' 12 TL (35      Ok\(_\) => inspect\(false, content="true"\))' 12 TL (36      Err\(_\) => inspect\(true, content="true"\))' 12 TL (37    })' 12 TL (38  })' T* 12 TL T* /F0 20 Tf (Error Display and JSON Conversion) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The error package provides ) Tj /F0 12 Tf (Show) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (ToJson) Tj /F0 12 Tf ( implementations:) Tj T* 12 TL T* ET
endstream
endobj
160 0 obj
<<
  /Type /Page  
  /Contents 159 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
161 0 obj
<<
  /Length 1985
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   suberror MyError Int derive\(ToJson\))' 12 TL (3   )' 12 TL (4   ///|)' 12 TL (5   test "error display and json" {)' 12 TL (6     let error : Error = MyError\(42\))' 12 TL (7   )' 12 TL (8     // Error can be displayed as string)' 12 TL (9     let error_string = error.to_string\(\))' 12 TL (10    inspect\(error_string.length\(\) > 0, content="true"\))' 12 TL (11  )' 12 TL (12    // Error can be converted to JSON)' 12 TL (13    let error_json = error.to_json\(\))' 12 TL (14    inspect\(error_json, content="Array\([String\(\\"MyError\\"\), Number\(42\)]\)"\))' 12 TL (15  })' T* 12 TL T* /F0 20 Tf (Error Propagation and Handling) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Handle errors at different levels of your application:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   suberror ParseError String)' 12 TL (3   )' 12 TL (4   ///|)' 12 TL (5   suberror FileError String)' 12 TL (6   )' 12 TL (7   ///|)' 12 TL (8   test "error propagation" {)' 12 TL (9     fn parse_number\(s : String\) -> Int raise ParseError {)' 12 TL (10      if s == "42" {)' 12 TL (11        42)' 12 TL (12      } else {)' 12 TL (13        raise ParseError\("Invalid number: " + s\))' 12 TL (14      })' 12 TL (15    })' 12 TL (16  )' 12 TL (17    fn read_and_parse\(content : String\) -> Int raise {)' 12 TL (18      parse_number\(content\) catch {)' 12 TL (19        ParseError\(msg\) => raise FileError\("Parse failed: " + msg\))' 12 TL (20      })' 12 TL (21    })' 12 TL (22  )' 12 TL (23    // Success case)' 12 TL (24    let result1 = try! read_and_parse\("42"\))' 12 TL (25    inspect\(result1, content="42"\))' 12 TL (26  )' 12 TL (27    // Error propagation)' 12 TL (28    let result2 = try? read_and_parse\("invalid"\))' 12 TL (29    match result2 {)' 12 TL (30      Ok\(_\) => inspect\(false, content="true"\))' 12 TL (31      Err\(_\) => inspect\(true, content="true"\))' 12 TL (32    })' 12 TL (33  })' T* 12 TL T* ET
endstream
endobj
162 0 obj
<<
  /Type /Page  
  /Contents 161 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
163 0 obj
<<
  /Length 1312
>>
stream
 1 0 0 1 50 770 cm BT /F0 20 Tf (Resource Management with Finally) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use ) Tj /F0 12 Tf (protect) Tj /F0 12 Tf ( functions for resource cleanup:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   suberror ResourceError String)' 12 TL (3   )' 12 TL (4   ///|)' 12 TL (5   test "resource management" {)' 12 TL (6     fn risky_operation\(\) -> String raise ResourceError {)' 12 TL (7       raise ResourceError\("Something went wrong"\))' 12 TL (8     })' 12 TL (9   )' 12 TL (10    // Simple resource management pattern)' 12 TL (11    fn use_resource\(\) -> String raise {)' 12 TL (12      // Acquire resource \(simulated\))' 12 TL (13      risky_operation\(\) catch {)' 12 TL (14        ResourceError\(_\) =>)' 12 TL (15          // Cleanup happens here)' 12 TL (16          raise Failure\("Operation failed after cleanup"\))' 12 TL (17      })' 12 TL (18    })' 12 TL (19  )' 12 TL (20    let result = try? use_resource\(\))' 12 TL (21    match result {)' 12 TL (22      Ok\(_\) => inspect\(false, content="true"\))' 12 TL (23      Err\(_\) => inspect\(true, content="true"\))' 12 TL (24    })' 12 TL (25  })' T* 12 TL T* /F0 20 Tf (Error Composition) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Combine multiple error-producing operations:) Tj T* 12 TL T* ET
endstream
endobj
164 0 obj
<<
  /Type /Page  
  /Contents 163 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
165 0 obj
<<
  /Length 2830
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   suberror ConfigError String)' 12 TL (3   )' 12 TL (4   ///|)' 12 TL (5   suberror DatabaseError String)' 12 TL (6   )' 12 TL (7   ///|)' 12 TL (8   test "error composition" {)' 12 TL (9     fn load_config\(\) -> String raise ConfigError {)' 12 TL (10      if true {)' 12 TL (11        "config_data")' 12 TL (12      } else {)' 12 TL (13        raise ConfigError\("Config not found"\))' 12 TL (14      })' 12 TL (15    })' 12 TL (16  )' 12 TL (17    fn connect_database\(config : String\) -> String raise DatabaseError {)' 12 TL (18      if config == "config_data" {)' 12 TL (19        "connected")' 12 TL (20      } else {)' 12 TL (21        raise DatabaseError\("Invalid config"\))' 12 TL (22      })' 12 TL (23    })' 12 TL (24  )' 12 TL (25    fn initialize_app\(\) -> String raise {)' 12 TL (26      let config = load_config\(\) catch {)' 12 TL (27        ConfigError\(msg\) => raise Failure\("Config error: " + msg\))' 12 TL (28      })' 12 TL (29      let db = connect_database\(config\) catch {)' 12 TL (30        DatabaseError\(msg\) => raise Failure\("Database error: " + msg\))' 12 TL (31      })' 12 TL (32      "App initialized with " + db)' 12 TL (33    })' 12 TL (34  )' 12 TL (35    let app_result = try! initialize_app\(\))' 12 TL (36    inspect\(app_result, content="App initialized with connected"\))' 12 TL (37  })' T* 12 TL T* /F0 20 Tf (Best Practices) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Use specific error types) Tj /F0 12 Tf (: Create custom ) Tj /F0 12 Tf (suberror) Tj /F0 12 Tf ( types for different error categ) Tj T* (ories) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Provide meaningful messages) Tj /F0 12 Tf (: Include context and actionable information in error) Tj T* ( messages) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Handle errors at appropriate levels) Tj /F0 12 Tf (: Don't catch errors too early; let them prop) Tj T* (agate to where they can be properly handled) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Use ) Tj /F0 12 Tf (try!) Tj /F0 12 Tf ( for operations that should not fail) Tj /F0 12 Tf (: This will panic if an error occurs) Tj T* (, making failures visible during development) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Use ) Tj /F0 12 Tf (try?) Tj /F0 12 Tf ( for recoverable errors) Tj /F0 12 Tf (: This returns a ) Tj /F0 12 Tf (Result) Tj /F0 12 Tf ( type that can be pattern ) Tj T* (matched) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Implement proper cleanup) Tj /F0 12 Tf (: Use the ) Tj /F0 12 Tf (protect) Tj /F0 12 Tf ( pattern or similar constructs for reso) Tj T* (urce management) Tj T* -10 0 Td 12 TL T* ET
endstream
endobj
166 0 obj
<<
  /Type /Page  
  /Contents 165 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
167 0 obj
<<
  /Length 2089
>>
stream
 1 0 0 1 50 770 cm BT /F0 20 Tf (Performance Notes) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Error handling in MoonBit is zero-cost when no errors occur) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Error propagation is efficient and doesn't require heap allocation for the error) Tj T* ( path) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Custom error types with ) Tj /F0 12 Tf (derive\(ToJson\)) Tj /F0 12 Tf ( automatically generate efficient JSON s) Tj T* (erialization) Tj T* 12 TL T* -10 0 Td 12 TL T* /F0 24 Tf (HashSet) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A mutable hash set based on a Robin Hood hash table.) Tj T* 12 TL T* /F0 24 Tf (Usage) Tj 24 TL T* 12 TL T* /F0 20 Tf (Create) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can create an empty set using ) Tj /F0 12 Tf (new\(\)) Tj /F0 12 Tf ( or construct it using ) Tj /F0 12 Tf (from_array\(\)) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let _set1 = @hashset.of\([1, 2, 3, 4, 5]\))' 12 TL (4     let _set2 : @hashset.HashSet[String] = @hashset.new\(\))' 12 TL (5   )' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Insert & Contain) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (insert\(\)) Tj /F0 12 Tf ( to add a key to the set, and ) Tj /F0 12 Tf (contains\(\)) Tj /F0 12 Tf ( to check whethe) Tj T* (r a key exists.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set : @hashset.HashSet[String] = @hashset.new\(\))' 12 TL (4     set.add\("a"\))' 12 TL (5     assert_eq\(set.contains\("a"\), true\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Remove) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (remove\(\)) Tj /F0 12 Tf ( to remove a key.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set = @hashset.of\(["a", "b", "c"]\))' 12 TL (4     set.remove\("a"\))' 12 TL (5     assert_eq\(set.contains\("a"\), false\))' 12 TL (6   })' T* 12 TL T* ET
endstream
endobj
168 0 obj
<<
  /Type /Page  
  /Contents 167 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
169 0 obj
<<
  /Length 2130
>>
stream
 1 0 0 1 50 770 cm BT /F0 20 Tf (Size & Capacity) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (size\(\)) Tj /F0 12 Tf ( to get the number of keys in the set, or ) Tj /F0 12 Tf (capacity\(\)) Tj /F0 12 Tf ( to ge) Tj T* (t the current capacity.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set = @hashset.of\(["a", "b", "c"]\))' 12 TL (4     assert_eq\(set.size\(\), 3\))' 12 TL (5     assert_eq\(set.capacity\(\), 8\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Similarly, you can use ) Tj /F0 12 Tf (is_empty\(\)) Tj /F0 12 Tf ( to check whether the set is empty.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set : @hashset.HashSet[Int] = @hashset.new\(\))' 12 TL (4     assert_eq\(set.is_empty\(\), true\))' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Clear) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (clear) Tj /F0 12 Tf ( to remove all keys from the set, but the allocated memory will) Tj T* ( not change.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set = @hashset.of\(["a", "b", "c"]\))' 12 TL (4     set.clear\(\))' 12 TL (5     assert_eq\(set.is_empty\(\), true\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Iteration) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (each\(\)) Tj /F0 12 Tf ( or ) Tj /F0 12 Tf (eachi\(\)) Tj /F0 12 Tf ( to iterate through all keys.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let set = @hashset.of\(["a", "b", "c"]\))' 12 TL (4     let arr = [])' 12 TL (5     set.each\(k => arr.push\(k\)\))' 12 TL (6     let arr2 = [])' 12 TL (7     set.eachi\(\(i, k\) => arr2.push\(\(i, k\)\)\))' 12 TL (8   })' T* 12 TL T* /F0 20 Tf (Set Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can use ) Tj /F0 12 Tf (union\(\)) Tj /F0 12 Tf (, ) Tj /F0 12 Tf (intersection\(\)) Tj /F0 12 Tf (, ) Tj /F0 12 Tf (difference\(\)) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (symmetric_difference) Tj T* (\(\)) Tj /F0 12 Tf ( to perform set operations.) Tj T* 12 TL T* ET
endstream
endobj
170 0 obj
<<
  /Type /Page  
  /Contents 169 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
171 0 obj
<<
  /Length 3122
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let m1 = @hashset.of\(["a", "b", "c"]\))' 12 TL (4     let m2 = @hashset.of\(["b", "c", "d"]\))' 12 TL (5     fn to_sorted_array\(set : @hashset.HashSet[String]\) {)' 12 TL (6       let arr = set.to_array\(\))' 12 TL (7       arr.sort\(\))' 12 TL (8       arr)' 12 TL (9     })' 12 TL (10  )' 12 TL (11    assert_eq\(m1.union\(m2\) |> to_sorted_array, ["a", "b", "c", "d"]\))' 12 TL (12    assert_eq\(m1.intersection\(m2\) |> to_sorted_array, ["b", "c"]\))' 12 TL (13    assert_eq\(m1.difference\(m2\) |> to_sorted_array, ["a"]\))' 12 TL (14    assert_eq\(m1.symmetric_difference\(m2\) |> to_sorted_array, ["a", "d"]\))' 12 TL (15  })' T* 12 TL T* /F0 24 Tf (Rational \(DEPRECATED\)) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (\240\046\017\376 ) Tj /F1 12 Tf (This module is deprecated. Use ) Tj /F0 12 Tf (@rational) Tj /F0 12 Tf ( in module ) Tj /F0 12 Tf (moonbitlang/) Tj T* (x) Tj /F0 12 Tf ( instead. Note that you need to rename ) Tj /F0 12 Tf (Rational) Tj /F0 12 Tf ( to ) Tj /F0 12 Tf (Rational64) Tj /F0 12 Tf (.) Tj T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (Rational) Tj /F0 12 Tf ( type represents a rational number, which is a number that can be ex) Tj T* (pressed as a fraction ) Tj /F0 12 Tf (a/b) Tj /F0 12 Tf ( where ) Tj /F0 12 Tf (a) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (b) Tj /F0 12 Tf ( are integers and ) Tj /F0 12 Tf (b) Tj /F0 12 Tf ( is not zero.) Tj T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (All tests and examples have been removed. Please refer to the new ) Tj /F0 12 Tf (moonbitlang/x) Tj /F0 12 Tf ( ) Tj T* (module for updated ) Tj /F0 12 Tf (documentation) Tj /F0 12 Tf ( and examples.) Tj T* 12 TL T* /F0 24 Tf (bool) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides utility functions for working with boolean values in MoonB) Tj T* (it, primarily focused on type conversions that are useful in systems programming) Tj T* (, bitwise operations, and numerical computations.) Tj T* 12 TL T* /F0 20 Tf (Overview) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Boolean values in MoonBit can be seamlessly converted to numeric types, followin) Tj T* (g the standard convention where ) Tj /F0 12 Tf (true) Tj /F0 12 Tf ( maps to ) Tj /F0 12 Tf (1) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (false) Tj /F0 12 Tf ( maps to ) Tj /F0 12 Tf (0) Tj /F0 12 Tf (. This is part) Tj T* (icularly useful for:) Tj T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Conditional arithmetic and accumulation) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Interfacing with C libraries or low-level code) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Implementing boolean algebra with numeric operations) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Converting logical results to flags or indices) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Basic Integer Conversion) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Convert boolean values to standard integers for arithmetic operations:) Tj T* 12 TL T* ET
endstream
endobj
172 0 obj
<<
  /Type /Page  
  /Contents 171 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
173 0 obj
<<
  /Length 1858
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "bool to integer conversions" {)' 12 TL (3     // Basic conversions)' 12 TL (4     inspect\(true.to_int\(\), content="1"\))' 12 TL (5     inspect\(false.to_int\(\), content="0"\))' 12 TL (6   )' 12 TL (7     // Useful for conditional arithmetic)' 12 TL (8     let score = 100)' 12 TL (9     let bonus_applied = true)' 12 TL (10    let final_score = score + bonus_applied.to_int\(\) * 50)' 12 TL (11    inspect\(final_score, content="150"\))' 12 TL (12  )' 12 TL (13    // Accumulating boolean conditions)' 12 TL (14    let conditions = [true, false, true, true, false])' 12 TL (15    let count = conditions.fold\(init=0, fn\(acc, cond\) { acc + cond.to_int\(\) }\))' 12 TL (16    inspect\(count, content="3"\))' 12 TL (17  })' T* 12 TL T* /F0 20 Tf (Specialized Integer Types) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (For specific use cases requiring different integer widths and signedness:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "bool to specialized integer types" {)' 12 TL (3     let flag = true)' 12 TL (4     let no_flag = false)' 12 TL (5   )' 12 TL (6     // UInt - useful for bit manipulation and flags)' 12 TL (7     inspect\(flag.to_uint\(\), content="1"\))' 12 TL (8     inspect\(no_flag.to_uint\(\), content="0"\))' 12 TL (9   )' 12 TL (10    // Int64 - for large computations and compatibility)' 12 TL (11    inspect\(flag.to_int64\(\), content="1"\))' 12 TL (12    inspect\(no_flag.to_int64\(\), content="0"\))' 12 TL (13  )' 12 TL (14    // UInt64 - for unsigned 64-bit operations)' 12 TL (15    inspect\(flag.to_uint64\(\), content="1"\))' 12 TL (16    inspect\(no_flag.to_uint64\(\), content="0"\))' 12 TL (17  })' T* 12 TL T* /F0 20 Tf (Practical Use Cases) Tj 20 TL T* 12 TL T* /F0 16 Tf (Boolean Indexing and Selection) Tj 16 TL T* 12 TL T* ET
endstream
endobj
174 0 obj
<<
  /Type /Page  
  /Contents 173 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
175 0 obj
<<
  /Length 2650
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "boolean indexing" {)' 12 TL (3     // Use boolean conversion for array indexing)' 12 TL (4     let options = ["default", "enhanced"])' 12 TL (5     let use_enhanced = true)' 12 TL (6     let selected = options[use_enhanced.to_int\(\)])' 12 TL (7     inspect\(selected, content="enhanced"\))' 12 TL (8   )' 12 TL (9     // Conditional selection without branching)' 12 TL (10    let base_value = 10)' 12 TL (11    let multiplier = 2)' 12 TL (12    let apply_multiplier = false)' 12 TL (13    let result = base_value * \(1 + apply_multiplier.to_int\(\) * \(multiplier - 1\)\))' 12 TL (14    inspect\(result, content="10"\) // 10 * \(1 + 0 * 1\) = 10)' 12 TL (15  })' T* 12 TL T* /F0 16 Tf (Bit Manipulation and Flags) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "flags and bit operations" {)' 12 TL (3     // Convert booleans to create bit flags)' 12 TL (4     let read_permission = true)' 12 TL (5     let write_permission = false)' 12 TL (6     let execute_permission = true)' 12 TL (7     let permissions = \(read_permission.to_uint\(\) << 2\) |)' 12 TL (8       \(write_permission.to_uint\(\) << 1\) |)' 12 TL (9       execute_permission.to_uint\(\))' 12 TL (10    inspect\(permissions, content="5"\) // Binary: 101 \(read + execute\))' 12 TL (11  })' T* 12 TL T* /F0 16 Tf (Statistical and Mathematical Operations) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "statistical operations" {)' 12 TL (3     // Calculate success rate from boolean results)' 12 TL (4     let test_results = [true, true, false, true, false, true, true])' 12 TL (5     let successes = test_results.fold\(init=0, fn\(acc, result\) {)' 12 TL (6       acc + result.to_int\(\))' 12 TL (7     }\))' 12 TL (8     let total = test_results.length\(\))' 12 TL (9     let success_rate = successes.to_double\(\) / total.to_double\(\))' 12 TL (10    inspect\(success_rate > 0.7, content="true"\))' 12 TL (11  )' 12 TL (12    // Boolean to numeric conversion for weighted calculations)' 12 TL (13    let feature_enabled = [true, false, true])' 12 TL (14    let weights = [0.6, 0.3, 0.1])' 12 TL (15  )' 12 TL (16    // Calculate weighted score manually to avoid zip complexity)' 12 TL (17    let score1 = feature_enabled[0].to_int\(\).to_double\(\) * weights[0])' 12 TL (18    let score2 = feature_enabled[1].to_int\(\).to_double\(\) * weights[1])' 12 TL (19    let score3 = feature_enabled[2].to_int\(\).to_double\(\) * weights[2])' 12 TL (20    let weighted_score = score1 + score2 + score3)' 12 TL (21    inspect\(weighted_score == 0.7, content="true"\))' 12 TL (22  })' T* ET
endstream
endobj
176 0 obj
<<
  /Type /Page  
  /Contents 175 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
177 0 obj
<<
  /Length 1696
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides the essential bridge between MoonBit's boolean logic and n) Tj T* (umeric computations, enabling elegant solutions for conditional arithmetic, flag) Tj T* ( operations, and data processing workflows.) Tj T* 12 TL T* /F0 24 Tf (Coverage Package Documentation) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides code coverage tracking utilities for MoonBit programs. It ) Tj T* (includes tools for measuring which parts of your code are executed during testin) Tj T* (g and generating coverage reports.) Tj T* 12 TL T* /F0 20 Tf (Coverage Counter) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The core component for tracking code execution:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "coverage counter basics" {)' 12 TL (3     // Create a coverage counter for tracking 5 code points)' 12 TL (4     let counter = CoverageCounter::new\(5\))' 12 TL (5   )' 12 TL (6     // Initially all counters should be zero)' 12 TL (7     inspect\(counter.to_string\(\), content="[0, 0, 0, 0, 0]"\))' 12 TL (8   )' 12 TL (9     // Increment specific tracking points)' 12 TL (10    counter.incr\(0\) // First code point executed once)' 12 TL (11    counter.incr\(2\) // Third code point executed once)' 12 TL (12    counter.incr\(0\) // First code point executed again)' 12 TL (13  )' 12 TL (14    // Check the updated counters)' 12 TL (15    inspect\(counter.to_string\(\), content="[2, 0, 1, 0, 0]"\))' 12 TL (16  })' T* 12 TL T* /F0 20 Tf (Tracking Code Execution) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use coverage counters to track which code paths are executed:) Tj T* 12 TL T* ET
endstream
endobj
178 0 obj
<<
  /Type /Page  
  /Contents 177 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
179 0 obj
<<
  /Length 1330
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "tracking execution paths" {)' 12 TL (3     let counter = CoverageCounter::new\(3\))' 12 TL (4     fn conditional_function\(x : Int, coverage : CoverageCounter\) -> String {)' 12 TL (5       if x > 0 {)' 12 TL (6         coverage.incr\(0\) // Positive path)' 12 TL (7         "positive")' 12 TL (8       } else if x < 0 {)' 12 TL (9         coverage.incr\(1\) // Negative path  )' 12 TL (10        "negative")' 12 TL (11      } else {)' 12 TL (12        coverage.incr\(2\) // Zero path)' 12 TL (13        "zero")' 12 TL (14      })' 12 TL (15    })' 12 TL (16  )' 12 TL (17    // Test different paths)' 12 TL (18    let result1 = conditional_function\(5, counter\))' 12 TL (19    inspect\(result1, content="positive"\))' 12 TL (20    let result2 = conditional_function\(-3, counter\))' 12 TL (21    inspect\(result2, content="negative"\))' 12 TL (22    let result3 = conditional_function\(0, counter\))' 12 TL (23    inspect\(result3, content="zero"\))' 12 TL (24  )' 12 TL (25    // All paths should have been executed once)' 12 TL (26    inspect\(counter.to_string\(\), content="[1, 1, 1]"\))' 12 TL (27  })' T* 12 TL T* /F0 20 Tf (Loop Coverage Tracking) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Track coverage in loops and iterations:) Tj T* 12 TL T* ET
endstream
endobj
180 0 obj
<<
  /Type /Page  
  /Contents 179 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
181 0 obj
<<
  /Length 1365
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "loop coverage" {)' 12 TL (3     let counter = CoverageCounter::new\(2\))' 12 TL (4     fn process_array\(arr : Array[Int], coverage : CoverageCounter\) -> Int {)' 12 TL (5       let mut sum = 0)' 12 TL (6       for x in arr {)' 12 TL (7         if x % 2 == 0 {)' 12 TL (8           coverage.incr\(0\) // Even number processing)' 12 TL (9           sum = sum + x)' 12 TL (10        } else {)' 12 TL (11          coverage.incr\(1\) // Odd number processing)' 12 TL (12          sum = sum + x * 2)' 12 TL (13        })' 12 TL (14      })' 12 TL (15      sum)' 12 TL (16    })' 12 TL (17  )' 12 TL (18    let test_data = [1, 2, 3, 4, 5] // Mix of even and odd)' 12 TL (19    let result = process_array\(test_data, counter\))' 12 TL (20  )' 12 TL (21    // Should have processed both even and odd numbers)' 12 TL (22    inspect\(result, content="24"\) // 1*2 + 2 + 3*2 + 4 + 5*2 = 2 + 2 + 6 + 4 + 10 = 24)' 12 TL (23  )' 12 TL (24    // Both branches should have been executed)' 12 TL (25    let coverage_str = counter.to_string\(\))' 12 TL (26    inspect\(coverage_str.length\(\) > 5, content="true"\) // Should show execution counts)' 12 TL (27  })' T* 12 TL T* /F0 20 Tf (Function Coverage) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Track coverage across different functions:) Tj T* 12 TL T* ET
endstream
endobj
182 0 obj
<<
  /Type /Page  
  /Contents 181 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
183 0 obj
<<
  /Length 1732
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "function coverage" {)' 12 TL (3     let counter = CoverageCounter::new\(4\))' 12 TL (4     fn math_operations\()' 12 TL (5       a : Int,)' 12 TL (6       b : Int,)' 12 TL (7       op : String,)' 12 TL (8       coverage : CoverageCounter,)' 12 TL (9     \) -> Int {)' 12 TL (10      match op {)' 12 TL (11        "add" => {)' 12 TL (12          coverage.incr\(0\))' 12 TL (13          a + b)' 12 TL (14        })' 12 TL (15        "sub" => {)' 12 TL (16          coverage.incr\(1\))' 12 TL (17          a - b)' 12 TL (18        })' 12 TL (19        "mul" => {)' 12 TL (20          coverage.incr\(2\))' 12 TL (21          a * b)' 12 TL (22        })' 12 TL (23        _ => {)' 12 TL (24          coverage.incr\(3\))' 12 TL (25          0 // Unknown operation)' 12 TL (26        })' 12 TL (27      })' 12 TL (28    })' 12 TL (29  )' 12 TL (30    // Test different operations)' 12 TL (31    let add_result = math_operations\(10, 5, "add", counter\))' 12 TL (32    inspect\(add_result, content="15"\))' 12 TL (33    let sub_result = math_operations\(10, 5, "sub", counter\))' 12 TL (34    inspect\(sub_result, content="5"\))' 12 TL (35    let unknown_result = math_operations\(10, 5, "unknown", counter\))' 12 TL (36    inspect\(unknown_result, content="0"\))' 12 TL (37  )' 12 TL (38    // Check that three of four branches were executed)' 12 TL (39    let final_coverage = counter.to_string\(\))' 12 TL (40    inspect\(final_coverage, content="[1, 1, 0, 1]"\) // add, sub, not mul, unknown)' 12 TL (41  })' T* 12 TL T* /F0 20 Tf (Coverage Analysis) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Analyze coverage data to understand code execution:) Tj T* 12 TL T* ET
endstream
endobj
184 0 obj
<<
  /Type /Page  
  /Contents 183 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
185 0 obj
<<
  /Length 1799
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "coverage analysis" {)' 12 TL (3     let counter = CoverageCounter::new\(6\))' 12 TL (4     fn complex_function\(input : Int, coverage : CoverageCounter\) -> String {)' 12 TL (5       coverage.incr\(0\) // Function entry)' 12 TL (6       if input < 0 {)' 12 TL (7         coverage.incr\(1\) // Negative branch)' 12 TL (8         return "negative")' 12 TL (9       })' 12 TL (10      coverage.incr\(2\) // Non-negative path)' 12 TL (11      if input == 0 {)' 12 TL (12        coverage.incr\(3\) // Zero branch)' 12 TL (13        return "zero")' 12 TL (14      })' 12 TL (15      coverage.incr\(4\) // Positive path)' 12 TL (16      if input > 100 {)' 12 TL (17        coverage.incr\(5\) // Large number branch)' 12 TL (18        "large")' 12 TL (19      } else {)' 12 TL (20        "small")' 12 TL (21      })' 12 TL (22    })' 12 TL (23  )' 12 TL (24    // Test various inputs)' 12 TL (25    let result1 = complex_function\(-5, counter\))' 12 TL (26    inspect\(result1, content="negative"\))' 12 TL (27    let result2 = complex_function\(0, counter\))' 12 TL (28    inspect\(result2, content="zero"\))' 12 TL (29    let result3 = complex_function\(50, counter\))' 12 TL (30    inspect\(result3, content="small"\))' 12 TL (31  )' 12 TL (32    // Analyze coverage: which paths were taken)' 12 TL (33    let coverage = counter.to_string\(\))' 12 TL (34    // Should show: [3, 1, 2, 1, 1, 0] - entry\(3\), negative\(1\), non-negative\(2\), zero\(1\), positive\(1\), large\(0\))' 12 TL (35    inspect\(coverage.length\(\) > 10, content="true"\))' 12 TL (36  })' T* 12 TL T* /F0 20 Tf (Integration with Testing) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Coverage tracking integrates with MoonBit's testing system:) Tj T* 12 TL T* ET
endstream
endobj
186 0 obj
<<
  /Type /Page  
  /Contents 185 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
187 0 obj
<<
  /Length 1319
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "testing integration" {)' 12 TL (3     // In real usage, coverage counters are typically generated automatically)' 12 TL (4     // by the compiler for coverage analysis)' 12 TL (5   )' 12 TL (6     fn test_function_with_coverage\(\) -> Bool {)' 12 TL (7       // This would normally have auto-generated coverage tracking)' 12 TL (8       let counter = CoverageCounter::new\(2\))' 12 TL (9       fn helper\(condition : Bool, cov : CoverageCounter\) -> String {)' 12 TL (10        if condition {)' 12 TL (11          cov.incr\(0\))' 12 TL (12          "true_branch")' 12 TL (13        } else {)' 12 TL (14          cov.incr\(1\))' 12 TL (15          "false_branch")' 12 TL (16        })' 12 TL (17      })' 12 TL (18  )' 12 TL (19      // Test both branches)' 12 TL (20      let result1 = helper\(true, counter\))' 12 TL (21      let result2 = helper\(false, counter\))' 12 TL (22      result1 == "true_branch" && result2 == "false_branch")' 12 TL (23    })' 12 TL (24  )' 12 TL (25    let test_passed = test_function_with_coverage\(\))' 12 TL (26    inspect\(test_passed, content="true"\))' 12 TL (27  })' T* 12 TL T* /F0 20 Tf (Coverage Reporting) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Generate and analyze coverage reports:) Tj T* 12 TL T* ET
endstream
endobj
188 0 obj
<<
  /Type /Page  
  /Contents 187 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
189 0 obj
<<
  /Length 2205
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "coverage reporting" {)' 12 TL (3     let counter = CoverageCounter::new\(3\))' 12 TL (4   )' 12 TL (5     // Simulate some code execution)' 12 TL (6     counter.incr\(0\) // Line 1 executed)' 12 TL (7     counter.incr\(0\) // Line 1 executed again)' 12 TL (8     counter.incr\(2\) // Line 3 executed)' 12 TL (9     // Line 2 \(index 1\) never executed)' 12 TL (10  )' 12 TL (11    let report = counter.to_string\(\))' 12 TL (12    inspect\(report, content="[2, 0, 1]"\))' 12 TL (13  )' 12 TL (14    // In real usage, you might analyze this data:)' 12 TL (15    fn analyze_coverage\(_coverage_str : String\) -> \(Int, Int\) {)' 12 TL (16      // This would parse the coverage data and return \(covered, total\))' 12 TL (17      // For demonstration, we'll return mock values)' 12 TL (18      \(2, 3\) // 2 out of 3 lines covered)' 12 TL (19    })' 12 TL (20  )' 12 TL (21    let \(covered, total\) = analyze_coverage\(report\))' 12 TL (22    inspect\(covered, content="2"\))' 12 TL (23    inspect\(total, content="3"\))' 12 TL (24  })' T* 12 TL T* /F0 20 Tf (Best Practices) Tj 20 TL T* 12 TL T* /F0 16 Tf (1. Automatic Coverage Generation) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (In real applications, coverage tracking is typically generated automatically:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   ///  This is conceptual - actual coverage is compiler-generated)' 12 TL (3   fn example_function\(x : Int\) -> String {)' 12 TL (4     // Compiler automatically inserts: coverage.incr\(0\))' 12 TL (5     if x > 0 {)' 12 TL (6       // Compiler automatically inserts: coverage.incr\(1\))' 12 TL (7       "positive")' 12 TL (8     } else {)' 12 TL (9       // Compiler automatically inserts: coverage.incr\(2\))' 12 TL (10      "non-positive")' 12 TL (11    })' 12 TL (12    // Compiler automatically inserts: coverage.incr\(3\))' 12 TL (13  })' 12 TL (14  )' 12 TL (15  ///|)' 12 TL (16  test "automatic coverage concept" {)' 12 TL (17    let result = example_function\(5\))' 12 TL (18    inspect\(result, content="positive"\))' 12 TL (19  })' T* 12 TL T* /F0 16 Tf (2. Coverage-Driven Testing) Tj 16 TL T* 12 TL T* ET
endstream
endobj
190 0 obj
<<
  /Type /Page  
  /Contents 189 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
191 0 obj
<<
  /Length 3228
>>
stream
 1 0 0 1 50 770 cm BT 12 TL /F0 12 Tf /F0 12 Tf (Use coverage information to improve test quality:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "coverage driven testing" {)' 12 TL (3     // Write tests to ensure all code paths are covered)' 12 TL (4     fn multi_branch_function\(a : Int, b : Int\) -> String {)' 12 TL (5       if a > b {)' 12 TL (6         "greater")' 12 TL (7       } else if a < b {)' 12 TL (8         "less")' 12 TL (9       } else {)' 12 TL (10        "equal")' 12 TL (11      })' 12 TL (12    })' 12 TL (13  )' 12 TL (14    // Test all branches)' 12 TL (15    inspect\(multi_branch_function\(5, 3\), content="greater"\))' 12 TL (16    inspect\(multi_branch_function\(2, 7\), content="less"\))' 12 TL (17    inspect\(multi_branch_function\(4, 4\), content="equal"\))' 12 TL (18  )' 12 TL (19    // This ensures 100% branch coverage)' 12 TL (20  })' T* 12 TL T* /F0 20 Tf (Integration with Build System) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Coverage tracking integrates with MoonBit's build tools:) Tj T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Use ) Tj /F0 12 Tf (moon test) Tj /F0 12 Tf ( to run tests with coverage tracking) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Use ) Tj /F0 12 Tf (moon coverage analyze) Tj /F0 12 Tf ( to generate coverage reports) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Coverage data helps identify untested code paths) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Supports both line coverage and branch coverage analysis) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Performance Considerations) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Coverage tracking adds minimal runtime overhead) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Counters use efficient fixed arrays for storage) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Coverage instrumentation is typically removed in release builds) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Use coverage data to optimize test suite performance) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Common Use Cases) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Test Quality Assessment) Tj /F0 12 Tf (: Ensure comprehensive test coverage) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Dead Code Detection) Tj /F0 12 Tf (: Find unused code paths) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Regression Testing) Tj /F0 12 Tf (: Verify that tests exercise the same code paths) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Performance Analysis) Tj /F0 12 Tf (: Identify frequently executed code for optimization) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Code Review) Tj /F0 12 Tf (: Understand which parts of code are well-tested) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The coverage package provides essential tools for maintaining high-quality, well) Tj T* (-tested MoonBit code through comprehensive coverage analysis.) Tj T* 12 TL T* ET
endstream
endobj
192 0 obj
<<
  /Type /Page  
  /Contents 191 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
193 0 obj
<<
  /Length 1798
>>
stream
 1 0 0 1 50 770 cm BT /F0 24 Tf (MoonBit Float Package Documentation) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides operations on 32-bit floating-point numbers \() Tj /F0 12 Tf (Float) Tj /F0 12 Tf (\). It ) Tj T* (includes basic arithmetic, trigonometric functions, exponential and logarithmic ) Tj T* (functions, as well as utility functions for rounding and conversion.) Tj T* 12 TL T* /F0 20 Tf (Special Values) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The package defines several special floating-point values:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "special float values" {)' 12 TL (3     // Infinity values)' 12 TL (4     inspect\(@float.infinity, content="Infinity"\))' 12 TL (5     inspect\(@float.neg_infinity, content="-Infinity"\))' 12 TL (6   )' 12 TL (7     // Not a Number)' 12 TL (8     inspect\(@float.not_a_number, content="NaN"\))' 12 TL (9   )' 12 TL (10    // Bounds)' 12 TL (11    inspect\(@float.max_value, content="3.4028234663852886e+38"\))' 12 TL (12    inspect\(@float.min_value, content="-3.4028234663852886e+38"\))' 12 TL (13    inspect\(@float.min_positive, content="1.1754943508222875e-38"\))' 12 TL (14  })' 12 TL (15  )' 12 TL (16  ///|)' 12 TL (17  test "checking special values" {)' 12 TL (18    // Testing for special values)' 12 TL (19    inspect\(@float.infinity.is_inf\(\), content="true"\))' 12 TL (20    inspect\(@float.neg_infinity.is_neg_inf\(\), content="true"\))' 12 TL (21    inspect\(@float.infinity.is_pos_inf\(\), content="true"\))' 12 TL (22    inspect\(@float.not_a_number.is_nan\(\), content="true"\))' 12 TL (23  })' T* 12 TL T* /F0 20 Tf (Rounding Functions) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The package provides various ways to round floating-point numbers:) Tj T* 12 TL T* ET
endstream
endobj
194 0 obj
<<
  /Type /Page  
  /Contents 193 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
195 0 obj
<<
  /Length 2065
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "rounding functions" {)' 12 TL (3     // Ceiling - rounds up)' 12 TL (4     inspect\(@float.ceil\(3.2\), content="4"\))' 12 TL (5     inspect\(@float.ceil\(-3.2\), content="-3"\))' 12 TL (6   )' 12 TL (7     // Floor - rounds down)' 12 TL (8     inspect\(@float.floor\(3.2\), content="3"\))' 12 TL (9     inspect\(@float.floor\(-3.2\), content="-4"\))' 12 TL (10  )' 12 TL (11    // Round - rounds to nearest integer)' 12 TL (12    inspect\(@float.round\(3.7\), content="4"\))' 12 TL (13    inspect\(@float.round\(3.2\), content="3"\))' 12 TL (14  )' 12 TL (15    // Truncate - removes decimal part)' 12 TL (16    inspect\(@float.trunc\(3.7\), content="3"\))' 12 TL (17    inspect\(@float.trunc\(-3.7\), content="-3"\))' 12 TL (18  })' T* 12 TL T* /F0 20 Tf (Utility Functions) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Other useful operations on floats:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "utility functions" {)' 12 TL (3     // Absolute value)' 12 TL (4     inspect\(@float.abs\(-3.14\), content="3.140000104904175"\))' 12 TL (5   )' 12 TL (6     // Conversion to integer)' 12 TL (7     inspect\(3.14.to_int\(\), content="3"\))' 12 TL (8   )' 12 TL (9     // Default value)' 12 TL (10    inspect\(@float.default\(\), content="0"\))' 12 TL (11  })' T* 12 TL T* /F0 20 Tf (Byte Representation) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Functions to convert floats to their byte representation:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "byte representation" {)' 12 TL (3     let x : Float = 3.14)' 12 TL (4     // Big-endian bytes)' 12 TL (5     let be_bytes = x.to_be_bytes\(\))' 12 TL (6     // Little-endian bytes)' 12 TL (7     let le_bytes = x.to_le_bytes\(\))' 12 TL (8     inspect\(be_bytes.length\(\), content="4"\))' 12 TL (9     inspect\(le_bytes.length\(\), content="4"\))' 12 TL (10  })' T* 12 TL T* /F0 20 Tf (Method Style) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (All functions can also be called in method style:) Tj T* ET
endstream
endobj
196 0 obj
<<
  /Type /Page  
  /Contents 195 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
197 0 obj
<<
  /Length 2057
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "method style calls" {)' 12 TL (3     let x : Float = 3.14)' 12 TL (4     inspect\(x.floor\(\), content="3"\))' 12 TL (5     inspect\(x.ceil\(\), content="4"\))' 12 TL (6     inspect\(x.round\(\), content="3"\))' 12 TL (7     let y : Float = 2.0)' 12 TL (8     inspect\(y.pow\(3.0\), content="8"\))' 12 TL (9   })' T* 12 TL T* /F0 24 Tf (int16) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides a fixed-width 16-bit signed integer type.) Tj T* 12 TL T* /F0 20 Tf (Range and Constants) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (Int16) Tj /F0 12 Tf ( type represents values from -32768 to 32767 \(inclusive\). The package) Tj T* ( provides these boundary values as constants:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "int16 range" {)' 12 TL (3     inspect\(@int16.min_value, content="-32768"\))' 12 TL (4     inspect\(@int16.max_value, content="32767"\))' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Arithmetic Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (Int16) Tj /F0 12 Tf ( type supports standard arithmetic operations:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "int16 arithmetic" {)' 12 TL (3     let a : Int16 = 100)' 12 TL (4     let b : Int16 = 50)' 12 TL (5   )' 12 TL (6     // Basic arithmetic)' 12 TL (7     inspect\(a + b, content="150"\))' 12 TL (8     inspect\(a - b, content="50"\))' 12 TL (9     inspect\(a * b, content="5000"\))' 12 TL (10    inspect\(a / b, content="2"\))' 12 TL (11  )' 12 TL (12    // Overflow behavior)' 12 TL (13    let max = @int16.max_value)' 12 TL (14    let min = @int16.min_value)' 12 TL (15    inspect\(max + 1, content="-32768"\) // Wraps around to min_value)' 12 TL (16    inspect\(min - 1, content="32767"\) // Wraps around to max_value)' 12 TL (17  })' T* 12 TL T* /F0 20 Tf (Bitwise Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Int16) Tj /F0 12 Tf ( supports standard bitwise operations:) Tj T* 12 TL T* ET
endstream
endobj
198 0 obj
<<
  /Type /Page  
  /Contents 197 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
199 0 obj
<<
  /Length 2101
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "int16 bitwise" {)' 12 TL (3     let a : Int16 = 0b1100)' 12 TL (4     let b : Int16 = 0b1010)' 12 TL (5   )' 12 TL (6     // Bitwise AND, OR, XOR)' 12 TL (7     inspect\(a & b, content="8"\) // 0b1000)' 12 TL (8     inspect\(a | b, content="14"\) // 0b1110)' 12 TL (9     inspect\(a ^ b, content="6"\) // 0b0110)' 12 TL (10  )' 12 TL (11    // Bit shifts)' 12 TL (12    let x : Int16 = 8)' 12 TL (13    inspect\(x << 1, content="16"\) // Left shift)' 12 TL (14    inspect\(x >> 1, content="4"\) // Right shift)' 12 TL (15  })' T* 12 TL T* /F0 20 Tf (Comparison Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Int16) Tj /F0 12 Tf ( implements the ) Tj /F0 12 Tf (Compare) Tj /F0 12 Tf ( trait for total ordering:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "int16 comparison" {)' 12 TL (3     let a : Int16 = 100)' 12 TL (4     let b : Int16 = 50)' 12 TL (5     let c : Int16 = 100)' 12 TL (6   )' 12 TL (7     // Equality)' 12 TL (8     inspect\(a == b, content="false"\))' 12 TL (9     inspect\(a == c, content="true"\))' 12 TL (10  )' 12 TL (11    // Ordering)' 12 TL (12    inspect\(a > b, content="true"\))' 12 TL (13    inspect\(b < c, content="true"\))' 12 TL (14  )' 12 TL (15    // Compare function returns -1, 0, or 1)' 12 TL (16    inspect\(a.compare\(b\), content="1"\))' 12 TL (17    inspect\(b.compare\(c\), content="-1"\))' 12 TL (18    inspect\(a.compare\(c\), content="0"\))' 12 TL (19  })' T* 12 TL T* /F0 20 Tf (Default Value) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Int16) Tj /F0 12 Tf ( implements the ) Tj /F0 12 Tf (Default) Tj /F0 12 Tf ( trait, with 0 as its default value:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "int16 default" {)' 12 TL (3     let x = Int16::default\(\))' 12 TL (4     inspect\(x, content="0"\))' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Type Coercion and Conversion) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Integer literals can be coerced to ) Tj /F0 12 Tf (Int16) Tj /F0 12 Tf ( when the type is explicitly specified:) Tj T* ET
endstream
endobj
200 0 obj
<<
  /Type /Page  
  /Contents 199 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
201 0 obj
<<
  /Length 2119
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "int16 coercion" {)' 12 TL (3     let a : Int16 = 42 // Coercion from integer literal)' 12 TL (4     let b : Int16 = 0xFF // Hexadecimal literal)' 12 TL (5     let c : Int16 = 0b1111 // Binary literal)' 12 TL (6     inspect\(a, content="42"\))' 12 TL (7     inspect\(b, content="255"\))' 12 TL (8     inspect\(c, content="15"\))' 12 TL (9   })' T* 12 TL T* /F0 24 Tf (Set Package Documentation) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides a hash-based set data structure that maintains insertion o) Tj T* (rder. The ) Tj /F0 12 Tf (Set[K]) Tj /F0 12 Tf ( type stores unique elements and provides efficient membership t) Tj T* (esting, insertion, and deletion operations.) Tj T* 12 TL T* /F0 20 Tf (Creating Sets) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (There are several ways to create sets:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "creating sets" {)' 12 TL (3     // Empty set)' 12 TL (4     let empty_set : @set.Set[Int] = @set.Set::new\(\))' 12 TL (5     inspect\(empty_set.size\(\), content="0"\))' 12 TL (6     inspect\(empty_set.is_empty\(\), content="true"\))' 12 TL (7   )' 12 TL (8     // Set with initial capacity)' 12 TL (9     let set_with_capacity : @set.Set[Int] = @set.Set::new\(capacity=16\))' 12 TL (10    inspect\(set_with_capacity.capacity\(\), content="16"\))' 12 TL (11  )' 12 TL (12    // From array)' 12 TL (13    let from_array = @set.Set::from_array\([1, 2, 3, 2, 1]\) // Duplicates are removed)' 12 TL (14    inspect\(from_array.size\(\), content="3"\))' 12 TL (15  )' 12 TL (16    // From fixed array)' 12 TL (17    let from_fixed = @set.Set::of\([10, 20, 30]\))' 12 TL (18    inspect\(from_fixed.size\(\), content="3"\))' 12 TL (19  )' 12 TL (20    // From iterator)' 12 TL (21    let from_iter = @set.Set::from_iter\([1, 2, 3, 4, 5].iter\(\)\))' 12 TL (22    inspect\(from_iter.size\(\), content="5"\))' 12 TL (23  })' T* 12 TL T* /F0 20 Tf (Basic Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Add, remove, and check membership:) Tj T* 12 TL T* ET
endstream
endobj
202 0 obj
<<
  /Type /Page  
  /Contents 201 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
203 0 obj
<<
  /Length 1638
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "basic operations" {)' 12 TL (3     let set = @set.Set::new\(\))' 12 TL (4   )' 12 TL (5     // Adding elements)' 12 TL (6     set.add\("apple"\))' 12 TL (7     set.add\("banana"\))' 12 TL (8     set.add\("cherry"\))' 12 TL (9     inspect\(set.size\(\), content="3"\))' 12 TL (10  )' 12 TL (11    // Adding duplicate \(no effect\))' 12 TL (12    set.add\("apple"\))' 12 TL (13    inspect\(set.size\(\), content="3"\) // Still 3)' 12 TL (14  )' 12 TL (15    // Check membership)' 12 TL (16    inspect\(set.contains\("apple"\), content="true"\))' 12 TL (17    inspect\(set.contains\("orange"\), content="false"\))' 12 TL (18  )' 12 TL (19    // Remove elements)' 12 TL (20    set.remove\("banana"\))' 12 TL (21    inspect\(set.contains\("banana"\), content="false"\))' 12 TL (22    inspect\(set.size\(\), content="2"\))' 12 TL (23  )' 12 TL (24    // Check if addition/removal was successful)' 12 TL (25    let was_added = set.add_and_check\("date"\))' 12 TL (26    inspect\(was_added, content="true"\))' 12 TL (27    let was_added_again = set.add_and_check\("date"\))' 12 TL (28    inspect\(was_added_again, content="false"\) // Already exists)' 12 TL (29    let was_removed = set.remove_and_check\("cherry"\))' 12 TL (30    inspect\(was_removed, content="true"\))' 12 TL (31    let was_removed_again = set.remove_and_check\("cherry"\))' 12 TL (32    inspect\(was_removed_again, content="false"\) // Doesn't exist)' 12 TL (33  })' T* 12 TL T* /F0 20 Tf (Set Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Perform mathematical set operations:) Tj T* 12 TL T* ET
endstream
endobj
204 0 obj
<<
  /Type /Page  
  /Contents 203 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
205 0 obj
<<
  /Length 2179
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "set operations" {)' 12 TL (3     let set1 = @set.Set::from_array\([1, 2, 3, 4]\))' 12 TL (4     let set2 = @set.Set::from_array\([3, 4, 5, 6]\))' 12 TL (5   )' 12 TL (6     // Union \(all elements from both sets\))' 12 TL (7     let union_set = set1.union\(set2\))' 12 TL (8     let union_array = union_set.to_array\(\))' 12 TL (9     inspect\(union_array.length\(\), content="6"\) // [1, 2, 3, 4, 5, 6])' 12 TL (10  )' 12 TL (11    // Alternative union syntax)' 12 TL (12    let union_alt = set1 | set2)' 12 TL (13    inspect\(union_alt.size\(\), content="6"\))' 12 TL (14  )' 12 TL (15    // Intersection \(common elements\))' 12 TL (16    let intersection_set = set1.intersection\(set2\))' 12 TL (17    let intersection_array = intersection_set.to_array\(\))' 12 TL (18    inspect\(intersection_array.length\(\), content="2"\) // [3, 4])' 12 TL (19  )' 12 TL (20    // Alternative intersection syntax)' 12 TL (21    let intersection_alt = set1 & set2)' 12 TL (22    inspect\(intersection_alt.size\(\), content="2"\))' 12 TL (23  )' 12 TL (24    // Difference \(elements in first but not second\))' 12 TL (25    let difference_set = set1.difference\(set2\))' 12 TL (26    let difference_array = difference_set.to_array\(\))' 12 TL (27    inspect\(difference_array.length\(\), content="2"\) // [1, 2])' 12 TL (28  )' 12 TL (29    // Alternative difference syntax)' 12 TL (30    let difference_alt = set1 - set2)' 12 TL (31    inspect\(difference_alt.size\(\), content="2"\))' 12 TL (32  )' 12 TL (33    // Symmetric difference \(elements in either but not both\))' 12 TL (34    let sym_diff_set = set1.symmetric_difference\(set2\))' 12 TL (35    let sym_diff_array = sym_diff_set.to_array\(\))' 12 TL (36    inspect\(sym_diff_array.length\(\), content="4"\) // [1, 2, 5, 6])' 12 TL (37  )' 12 TL (38    // Alternative symmetric difference syntax)' 12 TL (39    let sym_diff_alt = set1 ^ set2)' 12 TL (40    inspect\(sym_diff_alt.size\(\), content="4"\))' 12 TL (41  })' T* 12 TL T* /F0 20 Tf (Set Relationships) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Test relationships between sets:) Tj T* 12 TL T* ET
endstream
endobj
206 0 obj
<<
  /Type /Page  
  /Contents 205 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
207 0 obj
<<
  /Length 1338
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "set relationships" {)' 12 TL (3     let small_set = @set.Set::from_array\([1, 2]\))' 12 TL (4     let large_set = @set.Set::from_array\([1, 2, 3, 4]\))' 12 TL (5     let disjoint_set = @set.Set::from_array\([5, 6, 7]\))' 12 TL (6   )' 12 TL (7     // Subset testing)' 12 TL (8     inspect\(small_set.is_subset\(large_set\), content="true"\))' 12 TL (9     inspect\(large_set.is_subset\(small_set\), content="false"\))' 12 TL (10  )' 12 TL (11    // Superset testing)' 12 TL (12    inspect\(large_set.is_superset\(small_set\), content="true"\))' 12 TL (13    inspect\(small_set.is_superset\(large_set\), content="false"\))' 12 TL (14  )' 12 TL (15    // Disjoint testing \(no common elements\))' 12 TL (16    inspect\(small_set.is_disjoint\(disjoint_set\), content="true"\))' 12 TL (17    inspect\(small_set.is_disjoint\(large_set\), content="false"\))' 12 TL (18  )' 12 TL (19    // Equal sets)' 12 TL (20    let set1 = @set.Set::from_array\([1, 2, 3]\))' 12 TL (21    let set2 = @set.Set::from_array\([3, 2, 1]\) // Order doesn't matter)' 12 TL (22    inspect\(set1 == set2, content="true"\))' 12 TL (23  })' T* 12 TL T* /F0 20 Tf (Iteration and Conversion) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Iterate over sets and convert to other types:) Tj T* 12 TL T* ET
endstream
endobj
208 0 obj
<<
  /Type /Page  
  /Contents 207 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
209 0 obj
<<
  /Length 2072
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "iteration and conversion" {)' 12 TL (3     let set = @set.Set::from_array\(["first", "second", "third"]\))' 12 TL (4   )' 12 TL (5     // Convert to array \(maintains insertion order\))' 12 TL (6     let array = set.to_array\(\))' 12 TL (7     inspect\(array.length\(\), content="3"\))' 12 TL (8   )' 12 TL (9     // Iterate over elements)' 12 TL (10    let mut count = 0)' 12 TL (11    set.each\(fn\(_element\) { count = count + 1 }\))' 12 TL (12    inspect\(count, content="3"\))' 12 TL (13  )' 12 TL (14    // Iterate with index)' 12 TL (15    let mut indices_sum = 0)' 12 TL (16    set.eachi\(fn\(i, _element\) { indices_sum = indices_sum + i }\))' 12 TL (17    inspect\(indices_sum, content="3"\) // 0 + 1 + 2 = 3)' 12 TL (18  )' 12 TL (19    // Use iterator)' 12 TL (20    let elements = set.iter\(\).collect\(\))' 12 TL (21    inspect\(elements.length\(\), content="3"\))' 12 TL (22  )' 12 TL (23    // Copy a set)' 12 TL (24    let copied_set = set.copy\(\))' 12 TL (25    inspect\(copied_set.size\(\), content="3"\))' 12 TL (26    inspect\(copied_set == set, content="true"\))' 12 TL (27  })' T* 12 TL T* /F0 20 Tf (Modifying Sets) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Clear and modify existing sets:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "modifying sets" {)' 12 TL (3     let set = @set.Set::from_array\([10, 20, 30, 40, 50]\))' 12 TL (4     inspect\(set.size\(\), content="5"\))' 12 TL (5   )' 12 TL (6     // Clear all elements)' 12 TL (7     set.clear\(\))' 12 TL (8     inspect\(set.size\(\), content="0"\))' 12 TL (9     inspect\(set.is_empty\(\), content="true"\))' 12 TL (10  )' 12 TL (11    // Add elements back)' 12 TL (12    set.add\(100\))' 12 TL (13    set.add\(200\))' 12 TL (14    inspect\(set.size\(\), content="2"\))' 12 TL (15    inspect\(set.contains\(100\), content="true"\))' 12 TL (16  })' T* 12 TL T* /F0 20 Tf (JSON Serialization) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Sets can be serialized to JSON as arrays:) Tj T* 12 TL T* ET
endstream
endobj
210 0 obj
<<
  /Type /Page  
  /Contents 209 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
211 0 obj
<<
  /Length 2091
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "json serialization" {)' 12 TL (3     let set = @set.Set::from_array\([1, 2, 3]\))' 12 TL (4     let json = set.to_json\(\))' 12 TL (5   )' 12 TL (6     // JSON representation is an array)' 12 TL (7     inspect\(json, content="Array\([Number\(1\), Number\(2\), Number\(3\)]\)"\))' 12 TL (8   )' 12 TL (9     // String set)' 12 TL (10    let string_set = @set.Set::from_array\(["a", "b", "c"]\))' 12 TL (11    let string_json = string_set.to_json\(\))' 12 TL (12    inspect\()' 12 TL (13      string_json,)' 12 TL (14      content="Array\([String\(\\"a\\"\), String\(\\"b\\"\), String\(\\"c\\"\)]\)",)' 12 TL (15    \))' 12 TL (16  })' T* 12 TL T* /F0 20 Tf (Working with Different Types) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Sets work with any type that implements ) Tj /F0 12 Tf (Hash) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (Eq) Tj /F0 12 Tf (:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "different types" {)' 12 TL (3     // Integer set)' 12 TL (4     let int_set = @set.Set::from_array\([1, 2, 3, 4, 5]\))' 12 TL (5     inspect\(int_set.contains\(3\), content="true"\))' 12 TL (6   )' 12 TL (7     // String set)' 12 TL (8     let string_set = @set.Set::from_array\(["hello", "world", "moonbit"]\))' 12 TL (9     inspect\(string_set.contains\("world"\), content="true"\))' 12 TL (10  )' 12 TL (11    // Note: Char and Bool types don't implement Hash in this version)' 12 TL (12    // So we use Int codes for demonstration)' 12 TL (13    let char_codes = @set.Set::from_array\([97, 98, 99]\) // ASCII codes for 'a', 'b', 'c')' 12 TL (14    inspect\(char_codes.contains\(98\), content="true"\) // 'b' = 98)' 12 TL (15  )' 12 TL (16    // Integer set representing boolean values)' 12 TL (17    let bool_codes = @set.Set::from_array\([1, 0, 1]\) // 1=true, 0=false)' 12 TL (18    inspect\(bool_codes.size\(\), content="2"\) // Only 1 and 0)' 12 TL (19  })' T* 12 TL T* /F0 20 Tf (Performance Examples) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Demonstrate efficient operations:) Tj T* 12 TL T* ET
endstream
endobj
212 0 obj
<<
  /Type /Page  
  /Contents 211 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
213 0 obj
<<
  /Length 2703
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "performance examples" {)' 12 TL (3     // Large set operations)' 12 TL (4     let large_set = @set.Set::new\(capacity=1000\))' 12 TL (5   )' 12 TL (6     // Add many elements)' 12 TL (7     for i in 0..<100 {)' 12 TL (8       large_set.add\(i\))' 12 TL (9     })' 12 TL (10    inspect\(large_set.size\(\), content="100"\))' 12 TL (11  )' 12 TL (12    // Fast membership testing)' 12 TL (13    inspect\(large_set.contains\(50\), content="true"\))' 12 TL (14    inspect\(large_set.contains\(150\), content="false"\))' 12 TL (15  )' 12 TL (16    // Efficient set operations on large sets)' 12 TL (17    let another_set = @set.Set::new\(\))' 12 TL (18    for i in 50..<150 {)' 12 TL (19      another_set.add\(i\))' 12 TL (20    })' 12 TL (21    let intersection = large_set.intersection\(another_set\))' 12 TL (22    inspect\(intersection.size\(\), content="50"\) // Elements 50-99)' 12 TL (23  })' T* 12 TL T* /F0 20 Tf (Use Cases) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Sets are particularly useful for:) Tj T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Removing duplicates) Tj /F0 12 Tf (: Convert arrays to sets and back to remove duplicates) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Membership testing) Tj /F0 12 Tf (: Fast O\(1\) average-case lookups) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Mathematical operations) Tj /F0 12 Tf (: Union, intersection, difference operations) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Unique collections) Tj /F0 12 Tf (: Maintaining collections of unique items) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Algorithm implementation) Tj /F0 12 Tf (: Graph algorithms, caching, etc.) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Performance Characteristics) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Insertion) Tj /F0 12 Tf (: O\(1\) average case, O\(n\) worst case) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Removal) Tj /F0 12 Tf (: O\(1\) average case, O\(n\) worst case) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Lookup) Tj /F0 12 Tf (: O\(1\) average case, O\(n\) worst case) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Space complexity) Tj /F0 12 Tf (: O\(n\) where n is the number of elements) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Iteration order) Tj /F0 12 Tf (: Maintains insertion order \(linked hash set\)) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Best Practices) Tj 20 TL T* 12 TL T* ET
endstream
endobj
214 0 obj
<<
  /Type /Page  
  /Contents 213 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
215 0 obj
<<
  /Length 2401
>>
stream
 1 0 0 1 50 770 cm BT /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Pre-size when possible) Tj /F0 12 Tf (: Use ) Tj /F0 12 Tf (@set.Set::new\(capacity=n\)) Tj /F0 12 Tf ( if you know the approxim) Tj T* (ate size) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Use appropriate types) Tj /F0 12 Tf (: Ensure your key type has good ) Tj /F0 12 Tf (Hash) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (Eq) Tj /F0 12 Tf ( implementations) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Prefer set operations) Tj /F0 12 Tf (: Use built-in union, intersection, etc. instead of manual ) Tj T* (loops) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Check return values) Tj /F0 12 Tf (: Use ) Tj /F0 12 Tf (add_and_check) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (remove_and_check) Tj /F0 12 Tf ( when you need to kno) Tj T* (w if the operation succeeded) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Consider memory usage) Tj /F0 12 Tf (: Sets have overhead compared to arrays for small collectio) Tj T* (ns) Tj T* 12 TL T* -10 0 Td 12 TL T* /F0 24 Tf (buffer) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The buffer package provides a flexible byte buffer implementation for efficient ) Tj T* (binary data handling and serialization.) Tj T* 12 TL T* /F0 20 Tf (Basic Usage) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Create a new buffer and write basic data:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "basic buffer operations" {)' 12 TL (3     let buf = @buffer.new\(\))' 12 TL (4   )' 12 TL (5     // Write some bytes)' 12 TL (6     buf..write_byte\(b'H'\)..write_byte\(b'i'\))' 12 TL (7   )' 12 TL (8     // Check contents)' 12 TL (9     inspect\(buf.is_empty\(\), content="false"\))' 12 TL (10    inspect\(buf.length\(\), content="2"\))' 12 TL (11  )' 12 TL (12    // Get contents as bytes)' 12 TL (13    let bytes = buf.contents\(\))' 12 TL (14    inspect\()' 12 TL (15      bytes,)' 12 TL (16      content=\()' 12 TL (17        #|b"\\x48\\x69")' 12 TL (18      \),)' 12 TL (19    \))' 12 TL (20  )' 12 TL (21    // Reset buffer)' 12 TL (22    buf.reset\(\))' 12 TL (23    inspect\(buf.is_empty\(\), content="true"\))' 12 TL (24  })' T* 12 TL T* /F0 20 Tf (Writing Numbers) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Write numbers in different encodings:) Tj T* 12 TL T* ET
endstream
endobj
216 0 obj
<<
  /Type /Page  
  /Contents 215 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
217 0 obj
<<
  /Length 1720
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "number serialization" {)' 12 TL (3     inspect\()' 12 TL (4       @buffer.new\(\))' 12 TL (5       // Write integers in different byte orders)' 12 TL (6       ..write_int_be\(42\))' 12 TL (7       ..write_int_le\(42\))' 12 TL (8       .to_bytes\(\),)' 12 TL (9       content=\()' 12 TL (10        #|b"\\x00\\x00\\x00\\x2a\\x2a\\x00\\x00\\x00")' 12 TL (11      \),)' 12 TL (12    \))' 12 TL (13    inspect\()' 12 TL (14      @buffer.new\(\))' 12 TL (15      // Write floating point numbers)' 12 TL (16      ..write_float_be\(3.14\))' 12 TL (17      ..write_float_le\(3.14\))' 12 TL (18      .to_bytes\(\),)' 12 TL (19      content=\()' 12 TL (20        #|b"\\x40\\x48\\xf5\\xc3\\xc3\\xf5\\x48\\x40")' 12 TL (21      \),)' 12 TL (22    \))' 12 TL (23    inspect\()' 12 TL (24      @buffer.new\(\))' 12 TL (25      // Write 64-bit integers)' 12 TL (26      ..write_int64_be\(0xAABBCCDDEEL\))' 12 TL (27      ..write_int64_le\(0xAABBCCDDEEL\))' 12 TL (28      .to_bytes\(\),)' 12 TL (29      content=\()' 12 TL (30        #|b"\\x00\\x00\\x00\\xaa\\xbb\\xcc\\xdd\\xee\\xee\\xdd\\xcc\\xbb\\xaa\\x00\\x00\\x00")' 12 TL (31      \),)' 12 TL (32    \))' 12 TL (33    inspect\()' 12 TL (34      @buffer.new\(\))' 12 TL (35      // Write unsigned integers)' 12 TL (36      ..write_uint_be\(0x2077U\))' 12 TL (37      ..write_uint_le\(0x2077U\))' 12 TL (38      .to_bytes\(\),)' 12 TL (39      content=\()' 12 TL (40        #|b"\\x00\\x00\\x20\\x77\\x77\\x20\\x00\\x00")' 12 TL (41      \),)' 12 TL (42    \))' 12 TL (43  })' T* 12 TL T* /F0 20 Tf (Writing Byte Sequences) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Write sequences of bytes:) Tj T* 12 TL T* ET
endstream
endobj
218 0 obj
<<
  /Type /Page  
  /Contents 217 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
219 0 obj
<<
  /Length 1426
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "byte sequence writing" {)' 12 TL (3     let buf = @buffer.new\(\))' 12 TL (4   )' 12 TL (5     // Write byte array)' 12 TL (6     let bytes = b"Hello")' 12 TL (7     buf.write_bytes\(bytes\))' 12 TL (8   )' 12 TL (9     // Write byte iterator)' 12 TL (10    buf.write_iter\(bytes.iter\(\)\))' 12 TL (11    let contents = buf.to_bytes\(\))' 12 TL (12    inspect\()' 12 TL (13      contents,)' 12 TL (14      content=\()' 12 TL (15        #|b"\\x48\\x65\\x6c\\x6c\\x6f\\x48\\x65\\x6c\\x6c\\x6f")' 12 TL (16      \),)' 12 TL (17    \) // "Hello" written twice)' 12 TL (18  })' T* 12 TL T* /F0 20 Tf (Writing Structured Data) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Write structured data that implements Show:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "object writing" {)' 12 TL (3     let buf = @buffer.new\(\))' 12 TL (4   )' 12 TL (5     // Write int as object)' 12 TL (6     buf.write_object\(42\))' 12 TL (7   )' 12 TL (8     // Contents will be "42" as bytes)' 12 TL (9     let contents = buf.contents\(\))' 12 TL (10    inspect\()' 12 TL (11      contents,)' 12 TL (12      content=\()' 12 TL (13        #|b"\\x34\\x00\\x32\\x00")' 12 TL (14      \),)' 12 TL (15    \))' 12 TL (16  })' T* 12 TL T* /F0 20 Tf (Size Hints) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Provide size hints for better performance:) Tj T* 12 TL T* ET
endstream
endobj
220 0 obj
<<
  /Type /Page  
  /Contents 219 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
221 0 obj
<<
  /Length 1769
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "buffer with size hint" {)' 12 TL (3     // Create buffer with initial capacity hint)' 12 TL (4     let buf = @buffer.new\(size_hint=1024\))' 12 TL (5   )' 12 TL (6     // Write some data)' 12 TL (7     for i in 0..<100 {)' 12 TL (8       buf.write_int_le\(i\))' 12 TL (9     })' 12 TL (10  )' 12 TL (11    // Each integer takes 4 bytes)' 12 TL (12    inspect\(buf.length\(\), content="400"\))' 12 TL (13  })' T* 12 TL T* /F0 20 Tf (Buffer as Logger) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The buffer implements the Logger trait for Show:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "buffer as logger" {)' 12 TL (3     let buf = @buffer.new\(\))' 12 TL (4     let array = [1, 2, 3])' 12 TL (5   )' 12 TL (6     // Use buffer to log array)' 12 TL (7     array.output\(buf\))' 12 TL (8     let contents = buf.contents\(\))' 12 TL (9     inspect\()' 12 TL (10      contents,)' 12 TL (11      content=\()' 12 TL (12        #|b"\\x5b\\x00\\x31\\x00\\x2c\\x00\\x20\\x00\\x32\\x00\\x2c\\x00\\x20\\x00\\x33\\x00\\x5d\\x00")' 12 TL (13      \),)' 12 TL (14    \))' 12 TL (15  })' T* 12 TL T* /F0 20 Tf (Converting to String/Bytes) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Methods for converting buffer contents:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "buffer conversion" {)' 12 TL (3     let buf = @buffer.new\(\))' 12 TL (4     buf.write_byte\(b'a'\))' 12 TL (5     buf.write_byte\(b'b'\))' 12 TL (6     buf.write_byte\(b'c'\))' 12 TL (7     let bytes = buf.to_bytes\(\))' 12 TL (8     inspect\()' 12 TL (9       bytes,)' 12 TL (10      content=\()' 12 TL (11        #|b"\\x61\\x62\\x63")' 12 TL (12      \),)' 12 TL (13    \))' 12 TL (14  })' T* 12 TL T* ET
endstream
endobj
222 0 obj
<<
  /Type /Page  
  /Contents 221 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
223 0 obj
<<
  /Length 1313
>>
stream
 1 0 0 1 50 770 cm BT /F0 20 Tf (Binary Viewing) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Support for viewing subsets of bytes:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "byte view writing" {)' 12 TL (3     let buf = @buffer.new\(\))' 12 TL (4     let bytes = b"Hello World")' 12 TL (5   )' 12 TL (6     // Write a view of the bytes)' 12 TL (7     buf.write_bytesview\(bytes[0:5]\) // Write "Hello")' 12 TL (8     let contents = buf.to_bytes\(\))' 12 TL (9     inspect\()' 12 TL (10      contents,)' 12 TL (11      content=\()' 12 TL (12        #|b"\\x48\\x65\\x6c\\x6c\\x6f")' 12 TL (13      \),)' 12 TL (14    \))' 12 TL (15  })' T* 12 TL T* /F0 24 Tf (Random) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This is an efficient random number generation function based on the paper ) Tj /F0 12 Tf (Fast R) Tj T* (andom Integer Generation in an Interval) Tj /F0 12 Tf ( by Daniel Lemire, as well as the Golang') Tj T* (s ) Tj /F0 12 Tf (rand/v2) Tj /F0 12 Tf ( package.) Tj T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Internally, it uses the ) Tj /F0 12 Tf (Chacha8) Tj /F0 12 Tf ( cipher to generate random numbers. It is a crypt) Tj T* (ographically secure pseudo-random number generator \(CSPRNG\) that is also very ) Tj T* (fast.) Tj T* 12 TL T* /F0 24 Tf (Usage) Tj 24 TL T* 12 TL T* ET
endstream
endobj
224 0 obj
<<
  /Type /Page  
  /Contents 223 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
225 0 obj
<<
  /Length 2133
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let r = @random.Rand::new\(\))' 12 TL (4     assert_eq\(r.uint\(limit=10\), 7\))' 12 TL (5     assert_eq\(r.uint\(limit=10\), 0\))' 12 TL (6     assert_eq\(r.uint\(limit=10\), 5\))' 12 TL (7     assert_eq\(r.int\(\), 1064320769\))' 12 TL (8     assert_eq\(r.double\(\), 0.3318940049218405\))' 12 TL (9     assert_eq\(r.int\(limit=10\), 0\))' 12 TL (10    assert_eq\(r.uint\(\), 311122750\))' 12 TL (11    assert_eq\(r.int64\(\), 2043189202271773519\))' 12 TL (12    assert_eq\(r.int64\(limit=10\), 8\))' 12 TL (13    assert_eq\(r.uint64\(\), 3951155890335085418\))' 12 TL (14    let a = [1, 2, 3, 4, 5])' 12 TL (15    r.shuffle\(a.length\(\), \(i, j\) => {)' 12 TL (16      let t = a[i])' 12 TL (17      a[i] = a[j])' 12 TL (18      a[j] = t)' 12 TL (19    }\))' 12 TL (20    assert_eq\(a, [2, 1, 4, 3, 5]\))' 12 TL (21  })' T* 12 TL T* /F0 24 Tf (Strconv) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package implements conversions to and from string representations of basic ) Tj T* (data types.) Tj T* 12 TL T* /F0 24 Tf (Usage) Tj 24 TL T* 12 TL T* /F0 20 Tf (Parse) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use ) Tj /F0 12 Tf (parse_bool) Tj /F0 12 Tf (, ) Tj /F0 12 Tf (parse_double) Tj /F0 12 Tf (, ) Tj /F0 12 Tf (parse_int) Tj /F0 12 Tf (, and ) Tj /F0 12 Tf (parse_int64) Tj /F0 12 Tf ( convert strings to valu) Tj T* (es.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let b = @strconv.parse_bool\("true"\))' 12 TL (4     assert_eq\(b, true\))' 12 TL (5     let i1 = @strconv.parse_int\("1234567"\))' 12 TL (6     assert_eq\(i1, 1234567\))' 12 TL (7     let i2 = @strconv.parse_int\("101", base=2\))' 12 TL (8     assert_eq\(i2, 5\))' 12 TL (9     let d = @strconv.parse_double\("123.4567"\))' 12 TL (10    assert_eq\(d, 123.4567\))' 12 TL (11  })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (For types that implement the ) Tj /F0 12 Tf (FromStr) Tj /F0 12 Tf ( trait, you can also use helper function ) Tj /F0 12 Tf (par) Tj T* (se) Tj /F0 12 Tf ( to convert a string to a value.) Tj T* 12 TL T* ET
endstream
endobj
226 0 obj
<<
  /Type /Page  
  /Contents 225 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
227 0 obj
<<
  /Length 2405
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let a : Int = @strconv.parse\("123"\))' 12 TL (4     assert_eq\(a, 123\))' 12 TL (5     let b : Bool = @strconv.parse\("true"\))' 12 TL (6     assert_eq\(b, true\))' 12 TL (7   })' T* 12 TL T* /F0 24 Tf (Option) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf ( type is a built-in type in MoonBit that represents an optional value.) Tj T* ( The type annotation ) Tj /F0 12 Tf (Option[A]) Tj /F0 12 Tf ( can also be written as ) Tj /F0 12 Tf (A?) Tj /F0 12 Tf (.) Tj T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (It is an enum with two variants: ) Tj /F0 12 Tf (Some\(T\)) Tj /F0 12 Tf (, which represents a value of type ) Tj /F0 12 Tf (T) Tj /F0 12 Tf (, ) Tj T* (and ) Tj /F0 12 Tf (None) Tj /F0 12 Tf (, representing no value.) Tj T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Note that some methods of the Option are defined in the ) Tj /F0 12 Tf (core/builtin) Tj /F0 12 Tf ( package.) Tj T* 12 TL T* /F0 24 Tf (Usage) Tj 24 TL T* 12 TL T* /F0 20 Tf (Create) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can create an ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf ( value using the ) Tj /F0 12 Tf (Some) Tj /F0 12 Tf ( and ) Tj /F0 12 Tf (None) Tj /F0 12 Tf ( constructors, remember to) Tj T* ( give proper type annotations.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let some : Int? = Some\(42\))' 12 TL (4     let none : String? = None)' 12 TL (5     inspect\(some, content="Some\(42\)"\))' 12 TL (6     inspect\(none, content="None"\))' 12 TL (7   })' T* 12 TL T* /F0 20 Tf (Extracting values) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can extract the value from an ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf ( using the ) Tj /F0 12 Tf (match) Tj /F0 12 Tf ( expression \(Pattern Ma) Tj T* (tching\).) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let i = Some\(42\))' 12 TL (4     let j = match i {)' 12 TL (5       Some\(value\) => value)' 12 TL (6       None => abort\("unreachable"\))' 12 TL (7     })' 12 TL (8     assert_eq\(j, 42\))' 12 TL (9   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Or using the ) Tj /F0 12 Tf (unwrap) Tj /F0 12 Tf ( method, which will panic if the result is ) Tj /F0 12 Tf (None) Tj /F0 12 Tf ( and return th) Tj T* (e value if it is ) Tj /F0 12 Tf (Some) Tj /F0 12 Tf (.) Tj T* 12 TL T* ET
endstream
endobj
228 0 obj
<<
  /Type /Page  
  /Contents 227 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
229 0 obj
<<
  /Length 2490
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let some : Int? = Some\(42\))' 12 TL (4     let value = some.unwrap\(\) // 42)' 12 TL (5     assert_eq\(value, 42\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A safer alternative to ) Tj /F0 12 Tf (unwrap) Tj /F0 12 Tf ( is the ) Tj /F0 12 Tf (or) Tj /F0 12 Tf ( method, which returns the value if it is) Tj T* ( ) Tj /F0 12 Tf (Some) Tj /F0 12 Tf (, otherwise, it returns the default value.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let none : Int? = None)' 12 TL (4     let value = none.unwrap_or\(0\) // 0)' 12 TL (5     assert_eq\(value, 0\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (There is also the ) Tj /F0 12 Tf (or_else) Tj /F0 12 Tf ( method, which returns the value if it is ) Tj /F0 12 Tf (Some) Tj /F0 12 Tf (, otherwi) Tj T* (se, it returns the result of the provided function.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let none : Int? = None)' 12 TL (4     let value = none.unwrap_or_else\(\(\) => 0\) // 0)' 12 TL (5     assert_eq\(value, 0\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Transforming values) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can transform the value of an ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf ( using the ) Tj /F0 12 Tf (map) Tj /F0 12 Tf ( method. It applies the pr) Tj T* (ovided function to the value if it is ) Tj /F0 12 Tf (Some) Tj /F0 12 Tf (, otherwise, it returns ) Tj /F0 12 Tf (None) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let some : Int? = Some\(42\))' 12 TL (4     let new_some = some.map\(\(value : Int\) => value + 1\) // Some\(43\))' 12 TL (5     assert_eq\(new_some, Some\(43\)\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (There is a ) Tj /F0 12 Tf (filter) Tj /F0 12 Tf ( method that applies a predicate to the value if it is ) Tj /F0 12 Tf (Some) Tj /F0 12 Tf (, ot) Tj T* (herwise, it returns ) Tj /F0 12 Tf (None) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let some : Int? = Some\(42\))' 12 TL (4     let new_some = some.filter\(\(value : Int\) => value > 40\) // Some\(42\))' 12 TL (5     let none = some.filter\(\(value : Int\) => value > 50\) // None)' 12 TL (6     assert_eq\(new_some, Some\(42\)\))' 12 TL (7     assert_eq\(none, None\))' 12 TL (8   })' T* 12 TL T* /F0 20 Tf (Monadic operations) Tj 20 TL T* 12 TL T* ET
endstream
endobj
230 0 obj
<<
  /Type /Page  
  /Contents 229 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
231 0 obj
<<
  /Length 2529
>>
stream
 1 0 0 1 50 770 cm BT 12 TL /F0 12 Tf /F0 12 Tf (You can chain multiple operations that return ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf ( using the ) Tj /F0 12 Tf (bind) Tj /F0 12 Tf ( method, whic) Tj T* (h applies a function to the value if it is ) Tj /F0 12 Tf (Some) Tj /F0 12 Tf (, otherwise, it returns ) Tj /F0 12 Tf (None) Tj /F0 12 Tf (. Dif) Tj T* (ferent from ) Tj /F0 12 Tf (map) Tj /F0 12 Tf (, the function in argument returns an ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let some : Int? = Some\(42\))' 12 TL (4     let new_some = some.bind\(\(value : Int\) => Some\(value + 1\)\) // Some\(43\))' 12 TL (5     assert_eq\(new_some, Some\(43\)\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Sometimes we want to reduce the nested ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf ( values into a single ) Tj /F0 12 Tf (Option) Tj /F0 12 Tf (, you c) Tj T* (an use the ) Tj /F0 12 Tf (flatten) Tj /F0 12 Tf ( method to achieve this. It transforms ) Tj /F0 12 Tf (Some\(Some\(value\)\)) Tj /F0 12 Tf ( i) Tj T* (nto ) Tj /F0 12 Tf (Some\(value\)) Tj /F0 12 Tf (, and ) Tj /F0 12 Tf (None) Tj /F0 12 Tf ( otherwise.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let some : Int?? = Some\(Some\(42\)\))' 12 TL (4     let new_some = some.flatten\(\) // Some\(42\))' 12 TL (5     assert_eq\(new_some, Some\(42\)\))' 12 TL (6     let none : Int?? = Some\(None\))' 12 TL (7     let new_none = none.flatten\(\) // None)' 12 TL (8     assert_eq\(new_none, None\))' 12 TL (9   })' T* 12 TL T* /F0 24 Tf (uint64) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (moonbitlang/core/uint64) Tj /F0 12 Tf ( package provides functionality for working with 64-b) Tj T* (it unsigned integers. This package includes constants, operators, and conversion) Tj T* (s for UInt64 values.) Tj T* 12 TL T* /F0 20 Tf (Constants) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The package defines the minimum and maximum values for UInt64:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt64 constants" {)' 12 TL (3     // Minimum value of UInt64)' 12 TL (4     inspect\(@uint64.min_value, content="0"\))' 12 TL (5   )' 12 TL (6     // Maximum value of UInt64)' 12 TL (7     inspect\(@uint64.max_value, content="18446744073709551615"\))' 12 TL (8   })' T* 12 TL T* /F0 20 Tf (Arithmetic Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt64 supports standard arithmetic operations:) Tj T* 12 TL T* ET
endstream
endobj
232 0 obj
<<
  /Type /Page  
  /Contents 231 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
233 0 obj
<<
  /Length 1821
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt64 arithmetic" {)' 12 TL (3     let a : UInt64 = 100UL)' 12 TL (4     let b : UInt64 = 50UL)' 12 TL (5   )' 12 TL (6     // Addition)' 12 TL (7     inspect\(a + b, content="150"\))' 12 TL (8   )' 12 TL (9     // Subtraction)' 12 TL (10    inspect\(a - b, content="50"\))' 12 TL (11  )' 12 TL (12    // Multiplication)' 12 TL (13    inspect\(a * b, content="5000"\))' 12 TL (14  )' 12 TL (15    // Division)' 12 TL (16    inspect\(a / b, content="2"\))' 12 TL (17  )' 12 TL (18    // Overflow behavior)' 12 TL (19    inspect\(@uint64.max_value + 1UL, content="0"\) // Wraps around to 0)' 12 TL (20    inspect\(@uint64.min_value - 1UL, content="18446744073709551615"\) // Underflow wraps to maximum value)' 12 TL (21  })' T* 12 TL T* /F0 20 Tf (Bitwise Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt64 supports various bitwise operations:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt64 bitwise operations" {)' 12 TL (3     let a : UInt64 = 0b1010UL)' 12 TL (4     let b : UInt64 = 0b1100UL)' 12 TL (5   )' 12 TL (6     // Bitwise AND)' 12 TL (7     inspect\(a & b, content="8"\))' 12 TL (8   )' 12 TL (9     // Bitwise OR)' 12 TL (10    inspect\(a | b, content="14"\))' 12 TL (11  )' 12 TL (12    // Bitwise XOR)' 12 TL (13    inspect\(a ^ b, content="6"\))' 12 TL (14  )' 12 TL (15    // Left shift)' 12 TL (16    inspect\(a << 1, content="20"\))' 12 TL (17    inspect\(a << 2, content="40"\))' 12 TL (18  )' 12 TL (19    // Right shift)' 12 TL (20    inspect\(a >> 1, content="5"\))' 12 TL (21    inspect\(b >> 2, content="3"\))' 12 TL (22  })' T* 12 TL T* /F0 20 Tf (Comparison and Equality) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt64 supports comparison and equality operations:) Tj T* 12 TL T* ET
endstream
endobj
234 0 obj
<<
  /Type /Page  
  /Contents 233 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
235 0 obj
<<
  /Length 1749
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt64 comparison and equality" {)' 12 TL (3     let a : UInt64 = 100UL)' 12 TL (4     let b : UInt64 = 50UL)' 12 TL (5     let c : UInt64 = 100UL)' 12 TL (6   )' 12 TL (7     // Equality)' 12 TL (8     inspect\(a == c, content="true"\))' 12 TL (9     inspect\(a != b, content="true"\))' 12 TL (10  )' 12 TL (11    // Comparison)' 12 TL (12    inspect\(a > b, content="true"\))' 12 TL (13    inspect\(b < a, content="true"\))' 12 TL (14    inspect\(a >= c, content="true"\))' 12 TL (15    inspect\(c <= a, content="true"\))' 12 TL (16  })' T* 12 TL T* /F0 20 Tf (Byte Conversion) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt64 provides methods for converting to bytes in both big-endian and little-en) Tj T* (dian formats:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt64 byte conversion" {)' 12 TL (3     // Convert to bytes in big-endian order \(most significant byte first\))' 12 TL (4     let be_bytes = 0x123456789ABCDEF0UL.to_be_bytes\(\))' 12 TL (5     inspect\()' 12 TL (6       be_bytes,)' 12 TL (7       content=\()' 12 TL (8         #|b"\\x12\\x34\\x56\\x78\\x9a\\xbc\\xde\\xf0")' 12 TL (9       \),)' 12 TL (10    \))' 12 TL (11  )' 12 TL (12    // Convert to bytes in little-endian order \(least significant byte first\))' 12 TL (13    let le_bytes = 0x123456789ABCDEF0UL.to_le_bytes\(\))' 12 TL (14    inspect\()' 12 TL (15      le_bytes,)' 12 TL (16      content=\()' 12 TL (17        #|b"\\xf0\\xde\\xbc\\x9a\\x78\\x56\\x34\\x12")' 12 TL (18      \),)' 12 TL (19    \))' 12 TL (20  })' T* 12 TL T* /F0 20 Tf (Default Value and Hashing) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt64 implements the Default trait:) Tj T* 12 TL T* ET
endstream
endobj
236 0 obj
<<
  /Type /Page  
  /Contents 235 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
237 0 obj
<<
  /Length 2227
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt64 default value" {)' 12 TL (3     // Default value is 0)' 12 TL (4     let a : UInt64 = 0UL)' 12 TL (5     inspect\(a, content="0"\))' 12 TL (6   )' 12 TL (7     // Hash support is available via .hash\(\))' 12 TL (8     let value : UInt64 = 42UL)' 12 TL (9     inspect\(value.hash\(\), content="-1962516083"\))' 12 TL (10  })' T* 12 TL T* /F0 20 Tf (Type Conversions) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt64 works with various conversions to and from other types:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt64 conversions" {)' 12 TL (3     // From Int to UInt64)' 12 TL (4     inspect\(\(42\).to_uint64\(\), content="42"\))' 12 TL (5   )' 12 TL (6     // From UInt64 to Int or Double)' 12 TL (7     let value : UInt64 = 100UL)' 12 TL (8     inspect\(value.to_int\(\), content="100"\))' 12 TL (9     let as_double = value.to_double\(\))' 12 TL (10    inspect\(as_double, content="100"\))' 12 TL (11  )' 12 TL (12    // Overflow handling in conversions)' 12 TL (13    inspect\(\(-1\).to_uint64\(\), content="18446744073709551615"\) // Negative numbers wrap around)' 12 TL (14  )' 12 TL (15    // Converting back from floating point)' 12 TL (16    let from_double = 42.0.to_uint64\(\))' 12 TL (17    inspect\(from_double, content="42"\))' 12 TL (18  })' T* 12 TL T* /F0 20 Tf (Working with Large Numbers) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt64 is especially useful for applications requiring large unsigned integers:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt64 for large numbers" {)' 12 TL (3     // UInt64 can represent very large numbers)' 12 TL (4     let large_number : UInt64 = \(1UL << 63\) - 1UL)' 12 TL (5   )' 12 TL (6     // This exceeds a 32-bit integer's maximum value)' 12 TL (7     inspect\(large_number > \(1UL << 32\) - 1UL, content="true"\))' 12 TL (8   )' 12 TL (9     // Arithmetic still works with large values)' 12 TL (10    let result = large_number * 2UL)' 12 TL (11    inspect\(result, content="18446744073709551614"\) // This effectively calculates 2^64 - 2)' 12 TL (12  })' T* 12 TL T* /F0 20 Tf (Working with Hexadecimal Literals) Tj 20 TL T* 12 TL T* ET
endstream
endobj
238 0 obj
<<
  /Type /Page  
  /Contents 237 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
239 0 obj
<<
  /Length 2103
>>
stream
 1 0 0 1 50 770 cm BT 12 TL /F0 12 Tf /F0 12 Tf (UInt64 works well with hexadecimal literals for clarity when working with bit pa) Tj T* (tterns:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "UInt64 hexadecimal literals" {)' 12 TL (3     // Using hex literals for better readability when working with bit patterns)' 12 TL (4     let value = 0xDEADBEEFUL)' 12 TL (5   )' 12 TL (6     // Extract specific byte using shifts and masks)' 12 TL (7     let ad = \(value >> 16\) & 0xFFUL)' 12 TL (8     inspect\(ad.to_byte\(\), content="b'\\\\xAD'"\))' 12 TL (9   )' 12 TL (10    // Convert to byte representation)' 12 TL (11    let bytes = value.to_be_bytes\(\))' 12 TL (12    inspect\()' 12 TL (13      bytes,)' 12 TL (14      content=\()' 12 TL (15        #|b"\\x00\\x00\\x00\\x00\\xde\\xad\\xbe\\xef")' 12 TL (16      \),)' 12 TL (17    \))' 12 TL (18  })' T* 12 TL T* /F0 24 Tf (Queue) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Queue is a first in first out \(FIFO\) data structure, allowing to process their) Tj T* ( elements in the order they come.) Tj T* 12 TL T* /F0 24 Tf (Usage) Tj 24 TL T* 12 TL T* /F0 20 Tf (Create and Clear) Tj 20 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can create a queue manually by using the ) Tj /F0 12 Tf (new) Tj /F0 12 Tf ( or construct it using the ) Tj /F0 12 Tf (from_) Tj T* (array) Tj /F0 12 Tf (.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let _queue : @queue.Queue[Int] = @queue.new\(\))' 12 TL (4     let _queue1 = @queue.of\([1, 2, 3]\))' 12 TL (5   )' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (To clear the queue, you can use the ) Tj /F0 12 Tf (clear) Tj /F0 12 Tf ( method.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let queue = @queue.of\([1, 2, 3]\))' 12 TL (4     queue.clear\(\))' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Length) Tj 20 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can get the length of the queue by using the ) Tj /F0 12 Tf (length) Tj /F0 12 Tf ( method. The ) Tj /F0 12 Tf (is_empty) Tj /F0 12 Tf ( met) Tj T* (hod can be used to check if the queue is empty.) Tj T* ET
endstream
endobj
240 0 obj
<<
  /Type /Page  
  /Contents 239 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
241 0 obj
<<
  /Length 2037
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let queue = @queue.of\([1, 2, 3]\))' 12 TL (4     assert_eq\(queue.length\(\), 3\))' 12 TL (5     assert_eq\(queue.is_empty\(\), false\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Pop and Push) Tj 20 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can add elements to the queue using the ) Tj /F0 12 Tf (push) Tj /F0 12 Tf ( method and remove them using th) Tj T* (e ) Tj /F0 12 Tf (pop) Tj /F0 12 Tf ( method.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let queue = @queue.new\(\))' 12 TL (4     queue.push\(1\))' 12 TL (5     queue.push\(2\))' 12 TL (6     assert_eq\(queue.pop\(\), Some\(1\)\))' 12 TL (7     assert_eq\(queue.pop\(\), Some\(2\)\))' 12 TL (8   })' T* 12 TL T* /F0 20 Tf (Peek) Tj 20 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can get the first element of the queue without removing it using the ) Tj /F0 12 Tf (peek) Tj /F0 12 Tf ( me) Tj T* (thod.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let queue = @queue.of\([1, 2, 3]\))' 12 TL (4     assert_eq\(queue.peek\(\), Some\(1\)\))' 12 TL (5   })' T* 12 TL T* /F0 20 Tf (Traverse) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can traverse the queue using the ) Tj /F0 12 Tf (each) Tj /F0 12 Tf ( method.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let queue = @queue.of\([1, 2, 3]\))' 12 TL (4     let mut sum = 0)' 12 TL (5     queue.each\(x => sum += x\))' 12 TL (6     assert_eq\(sum, 6\))' 12 TL (7   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can fold the queue using the ) Tj /F0 12 Tf (fold) Tj /F0 12 Tf ( method.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let queue = @queue.of\([1, 2, 3]\))' 12 TL (4     let sum = queue.fold\(init=0, \(acc, x\) => acc + x\))' 12 TL (5     assert_eq\(sum, 6\))' 12 TL (6   })' T* 12 TL T* /F0 20 Tf (Copy and Transfer) Tj 20 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can copy a queue using the ) Tj /F0 12 Tf (copy) Tj /F0 12 Tf ( method.) Tj T* ET
endstream
endobj
242 0 obj
<<
  /Type /Page  
  /Contents 241 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
243 0 obj
<<
  /Length 1884
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let queue = @queue.of\([1, 2, 3]\))' 12 TL (4     let _queue2 = queue.copy\(\))' 12 TL (5   )' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Transfer the elements from one queue to another using the ) Tj /F0 12 Tf (transfer) Tj /F0 12 Tf ( method.) Tj T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let dst : @queue.Queue[Int] = @queue.new\(\))' 12 TL (4     let src : @queue.Queue[Int] = @queue.of\([5, 6, 7, 8]\))' 12 TL (5     src.transfer\(dst\))' 12 TL (6   })' T* 12 TL T* /F0 24 Tf (double) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides comprehensive support for double-precision floating-point ) Tj T* (arithmetic, including basic operations, trigonometric functions, exponential and) Tj T* ( logarithmic functions, as well as utility functions for handling special values) Tj T* (.) Tj T* 12 TL T* /F0 20 Tf (Constants and Special Values) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The package provides several important constants and special floating-point valu) Tj T* (es:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "special values" {)' 12 TL (3     // Special values)' 12 TL (4     inspect\(@double.infinity, content="Infinity"\))' 12 TL (5     inspect\(@double.neg_infinity, content="-Infinity"\))' 12 TL (6     inspect\(@double.not_a_number, content="NaN"\))' 12 TL (7   )' 12 TL (8     // Limits)' 12 TL (9     inspect\(@double.max_value, content="1.7976931348623157e+308"\))' 12 TL (10    inspect\(@double.min_value, content="-1.7976931348623157e+308"\))' 12 TL (11    inspect\(@double.min_positive, content="2.2250738585072014e-308"\))' 12 TL (12  })' T* 12 TL T* /F0 20 Tf (Basic Operations) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Basic mathematical operations and rounding functions:) Tj T* 12 TL T* ET
endstream
endobj
244 0 obj
<<
  /Type /Page  
  /Contents 243 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
245 0 obj
<<
  /Length 1837
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "basic operations" {)' 12 TL (3     // Absolute value)' 12 TL (4     inspect\(@double.abs\(-3.14\), content="3.14"\))' 12 TL (5   )' 12 TL (6     // Rounding functions)' 12 TL (7     inspect\(@double.floor\(3.7\), content="3"\))' 12 TL (8     inspect\(@double.ceil\(3.2\), content="4"\))' 12 TL (9     inspect\(@double.round\(3.5\), content="4"\))' 12 TL (10    inspect\(@double.trunc\(3.7\), content="3"\))' 12 TL (11  )' 12 TL (12    // Pow function)' 12 TL (13    inspect\(2.0.pow\(3\), content="8"\))' 12 TL (14  )' 12 TL (15    // Sign)' 12 TL (16    inspect\(\(-3.14\).signum\(\), content="-1"\))' 12 TL (17    inspect\(2.0.signum\(\), content="1"\))' 12 TL (18  )' 12 TL (19    // Type conversion)' 12 TL (20    inspect\(@double.from_int\(42\), content="42"\))' 12 TL (21  })' T* 12 TL T* /F0 20 Tf (Special Value Testing) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Functions for testing special floating-point values and comparing numbers:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "special value testing" {)' 12 TL (3     // Testing for special values)' 12 TL (4     inspect\(@double.not_a_number.is_nan\(\), content="true"\))' 12 TL (5     inspect\(@double.infinity.is_inf\(\), content="true"\))' 12 TL (6     inspect\(@double.infinity.is_pos_inf\(\), content="true"\))' 12 TL (7     inspect\(@double.neg_infinity.is_neg_inf\(\), content="true"\))' 12 TL (8   )' 12 TL (9     // Approximate equality)' 12 TL (10    let relative_tolerance = 1.e-9)' 12 TL (11    inspect\(@double.is_close\(0.1 + 0.2, 0.3, relative_tolerance~\), content="true"\))' 12 TL (12  })' T* 12 TL T* /F0 20 Tf (Binary Representation) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Functions for converting doubles to their binary representation:) Tj T* 12 TL T* ET
endstream
endobj
246 0 obj
<<
  /Type /Page  
  /Contents 245 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
247 0 obj
<<
  /Length 2352
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "binary representation" {)' 12 TL (3     let num = 1.0)' 12 TL (4   )' 12 TL (5     // Convert to big-endian and little-endian bytes)' 12 TL (6     // Different byte orders should produce different results)' 12 TL (7     inspect\()' 12 TL (8       num.to_be_bytes\(\),)' 12 TL (9       content=\()' 12 TL (10        #|b"\\x3f\\xf0\\x00\\x00\\x00\\x00\\x00\\x00")' 12 TL (11      \),)' 12 TL (12    \))' 12 TL (13    inspect\()' 12 TL (14      num.to_le_bytes\(\),)' 12 TL (15      content=\()' 12 TL (16        #|b"\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x3f")' 12 TL (17      \),)' 12 TL (18    \))' 12 TL (19  })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Note: Most methods can be called either as a method \() Tj /F0 12 Tf (d.to_be_bytes\(\)) Tj /F0 12 Tf (\) or as ) Tj T* (a package function \() Tj /F0 12 Tf (@double.to_be_bytes\(d\)) Tj /F0 12 Tf (\).) Tj T* 12 TL T* /F0 24 Tf (Sorted Map) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A mutable map backed by an AVL tree that maintains keys in sorted order.) Tj T* 12 TL T* /F0 20 Tf (Overview) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (SortedMap is an ordered map implementation that keeps entries sorted by keys. It) Tj T* ( provides efficient lookup, insertion, and deletion operations, with stable trav) Tj T* (ersal order based on key comparison.) Tj T* 12 TL T* /F0 20 Tf (Performance) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (add/set) Tj /F0 12 Tf (: O\(log n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (remove) Tj /F0 12 Tf (: O\(log n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (get/contains) Tj /F0 12 Tf (: O\(log n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (iterate) Tj /F0 12 Tf (: O\(n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (range) Tj /F0 12 Tf (: O\(log n + k\) where k is number of elements in range) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (space complexity) Tj /F0 12 Tf (: O\(n\)) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Usage) Tj 20 TL T* 12 TL T* /F0 16 Tf (Create) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can create an empty SortedMap or a SortedMap from other containers.) Tj T* 12 TL T* ET
endstream
endobj
248 0 obj
<<
  /Type /Page  
  /Contents 247 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
249 0 obj
<<
  /Length 1891
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let _map1 : @sorted_map.SortedMap[Int, String] = @sorted_map.new\(\))' 12 TL (4     let _map2 = @sorted_map.from_array\([\(1, "one"\), \(2, "two"\), \(3, "three"\)]\))' 12 TL (5   )' 12 TL (6   })' T* 12 TL T* /F0 16 Tf (Container Operations) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Add a key-value pair to the SortedMap in place.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(1, "one"\), \(2, "two"\)]\))' 12 TL (4     map.set\(3, "three"\))' 12 TL (5     assert_eq\(map.size\(\), 3\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can also use the convenient subscript syntax to add or update values:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.new\(\))' 12 TL (4     map[1] = "one")' 12 TL (5     map[2] = "two")' 12 TL (6     assert_eq\(map.size\(\), 2\))' 12 TL (7   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Remove a key-value pair from the SortedMap in place.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(1, "one"\), \(2, "two"\), \(3, "three"\)]\))' 12 TL (4     map.remove\(2\))' 12 TL (5     assert_eq\(map.size\(\), 2\))' 12 TL (6     assert_eq\(map.contains\(2\), false\))' 12 TL (7   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get a value by its key. The return type is ) Tj /F0 12 Tf (Option[V]) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(1, "one"\), \(2, "two"\), \(3, "three"\)]\))' 12 TL (4     assert_eq\(map.get\(2\), Some\("two"\)\))' 12 TL (5     assert_eq\(map.get\(4\), None\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Safe access with error handling:) Tj T* 12 TL T* ET
endstream
endobj
250 0 obj
<<
  /Type /Page  
  /Contents 249 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
251 0 obj
<<
  /Length 1961
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(1, "one"\), \(2, "two"\)]\))' 12 TL (4     let key = 3)' 12 TL (5     inspect\(map.get\(key\), content="None"\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Check if a key exists in the map.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(1, "one"\), \(2, "two"\), \(3, "three"\)]\))' 12 TL (4     assert_eq\(map.contains\(2\), true\))' 12 TL (5     assert_eq\(map.contains\(4\), false\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Iterate over all key-value pairs in the map in sorted key order.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(3, "three"\), \(1, "one"\), \(2, "two"\)]\))' 12 TL (4     let keys = [])' 12 TL (5     let values = [])' 12 TL (6     map.each\(\(k, v\) => {)' 12 TL (7       keys.push\(k\))' 12 TL (8       values.push\(v\))' 12 TL (9     }\))' 12 TL (10    assert_eq\(keys, [1, 2, 3]\))' 12 TL (11    assert_eq\(values, ["one", "two", "three"]\))' 12 TL (12  })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Iterate with index:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(3, "three"\), \(1, "one"\), \(2, "two"\)]\))' 12 TL (4     let result = [])' 12 TL (5     map.eachi\(\(i, k, v\) => result.push\(\(i, k, v\)\)\))' 12 TL (6     assert_eq\(result, [\(0, 1, "one"\), \(1, 2, "two"\), \(2, 3, "three"\)]\))' 12 TL (7   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get the size of the map.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(1, "one"\), \(2, "two"\), \(3, "three"\)]\))' 12 TL (4     assert_eq\(map.size\(\), 3\))' 12 TL (5   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Check if the map is empty.) Tj T* 12 TL T* ET
endstream
endobj
252 0 obj
<<
  /Type /Page  
  /Contents 251 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
253 0 obj
<<
  /Length 2174
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map : @sorted_map.SortedMap[Int, String] = @sorted_map.new\(\))' 12 TL (4     assert_eq\(map.is_empty\(\), true\))' 12 TL (5   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Clear the map.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(1, "one"\), \(2, "two"\), \(3, "three"\)]\))' 12 TL (4     map.clear\(\))' 12 TL (5     assert_eq\(map.is_empty\(\), true\))' 12 TL (6   })' T* 12 TL T* /F0 16 Tf (Data Extraction) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get all keys or values from the map.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(3, "three"\), \(1, "one"\), \(2, "two"\)]\))' 12 TL (4     assert_eq\(map.keys_as_iter\(\).collect\(\), [1, 2, 3]\))' 12 TL (5     assert_eq\(map.values_as_iter\(\).collect\(\), ["one", "two", "three"]\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Convert the map to an array of key-value pairs.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(3, "three"\), \(1, "one"\), \(2, "two"\)]\))' 12 TL (4     assert_eq\(map.to_array\(\), [\(1, "one"\), \(2, "two"\), \(3, "three"\)]\))' 12 TL (5   })' T* 12 TL T* /F0 16 Tf (Range Operations) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get a subset of the map within a specified range of keys. The range is inclusive) Tj T* ( for both bounds ) Tj /F0 12 Tf ([low, high]) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([)' 12 TL (4       \(1, "one"\),)' 12 TL (5       \(2, "two"\),)' 12 TL (6       \(3, "three"\),)' 12 TL (7       \(4, "four"\),)' 12 TL (8       \(5, "five"\),)' 12 TL (9     ]\))' 12 TL (10    let range_items = [])' 12 TL (11    map.range\(2, 4\).each\(\(k, v\) => range_items.push\(\(k, v\)\)\))' 12 TL (12    assert_eq\(range_items, [\(2, "two"\), \(3, "three"\), \(4, "four"\)]\))' 12 TL (13  })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Edge cases for range operations:) Tj T* ET
endstream
endobj
254 0 obj
<<
  /Type /Page  
  /Contents 253 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
255 0 obj
<<
  /Length 2787
>>
stream
 1 0 0 1 50 770 cm BT /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (If ) Tj /F0 12 Tf (low > high) Tj /F0 12 Tf (, returns an empty result) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (If ) Tj /F0 12 Tf (low) Tj /F0 12 Tf ( or ) Tj /F0 12 Tf (high) Tj /F0 12 Tf ( are outside the map bounds, returns only pairs within valid bound) Tj T* (s) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (The returned iterator preserves the sorted order of keys) Tj T* -10 0 Td 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   ///  Example with out-of-bounds range)' 12 TL (3   test {)' 12 TL (4     let map = @sorted_map.from_array\([\(1, "one"\), \(2, "two"\), \(3, "three"\)]\))' 12 TL (5     let range_items = [])' 12 TL (6     map.range\(0, 10\).each\(\(k, v\) => range_items.push\(\(k, v\)\)\))' 12 TL (7     assert_eq\(range_items, [\(1, "one"\), \(2, "two"\), \(3, "three"\)]\))' 12 TL (8   )' 12 TL (9     // Example with invalid range)' 12 TL (10    let empty_range : Array[\(Int, String\)] = [])' 12 TL (11    map.range\(10, 5\).each\(\(k, v\) => empty_range.push\(\(k, v\)\)\))' 12 TL (12    assert_eq\(empty_range, []\))' 12 TL (13  })' T* 12 TL T* /F0 16 Tf (Iterators) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The SortedMap supports several iterator patterns. Create a map from an iterator:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let pairs = [\(1, "one"\), \(2, "two"\), \(3, "three"\)].iter\(\))' 12 TL (4     let map = @sorted_map.from_iter\(pairs\))' 12 TL (5     assert_eq\(map.size\(\), 3\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use the ) Tj /F0 12 Tf (iter) Tj /F0 12 Tf ( method to get an iterator over key-value pairs:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(3, "three"\), \(1, "one"\), \(2, "two"\)]\))' 12 TL (4     let pairs = map.iter\(\).to_array\(\))' 12 TL (5     assert_eq\(pairs, [\(1, "one"\), \(2, "two"\), \(3, "three"\)]\))' 12 TL (6   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use the ) Tj /F0 12 Tf (iter2) Tj /F0 12 Tf ( method for a more convenient key-value iteration:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map = @sorted_map.from_array\([\(3, "three"\), \(1, "one"\), \(2, "two"\)]\))' 12 TL (4     let transformed = [])' 12 TL (5     map.iter2\(\).each\(\(k, v\) => transformed.push\(k.to_string\(\) + ": " + v\)\))' 12 TL (6     assert_eq\(transformed, ["1: one", "2: two", "3: three"]\))' 12 TL (7   })' T* 12 TL T* /F0 16 Tf (Equality) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Maps with the same key-value pairs are considered equal, regardless of the order) Tj T* ( in which elements were added.) Tj T* ET
endstream
endobj
256 0 obj
<<
  /Type /Page  
  /Contents 255 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
257 0 obj
<<
  /Length 2497
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test {)' 12 TL (3     let map1 = @sorted_map.from_array\([\(1, "one"\), \(2, "two"\)]\))' 12 TL (4     let map2 = @sorted_map.from_array\([\(2, "two"\), \(1, "one"\)]\))' 12 TL (5     assert_eq\(map1 == map2, true\))' 12 TL (6   })' T* 12 TL T* /F0 16 Tf (Error Handling Best Practices) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (When working with keys that might not exist, prefer using pattern matching for s) Tj T* (afety:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   fn get_score\(scores : @sorted_map.SortedMap[Int, Int], student_id : Int\) -> Int {)' 12 TL (3     match scores.get\(student_id\) {)' 12 TL (4       Some\(score\) => score)' 12 TL (5       None =>)' 12 TL (6         // println\()' 12 TL (7         //   "Student ID " +)' 12 TL (8         //   student_id.to_string\(\) +)' 12 TL (9         //   " does not exist, returning default score",)' 12 TL (10        // \))' 12 TL (11        0 // Default score)' 12 TL (12    })' 12 TL (13  })' 12 TL (14  )' 12 TL (15  ///|)' 12 TL (16  test "safe_key_access" {)' 12 TL (17    // Create a mapping storing student IDs and their scores)' 12 TL (18    let scores = @sorted_map.from_array\([\(1001, 85\), \(1002, 92\), \(1003, 78\)]\))' 12 TL (19  )' 12 TL (20    // Access an existing key)' 12 TL (21    assert_eq\(get_score\(scores, 1001\), 85\))' 12 TL (22  )' 12 TL (23    // Access a non-existent key, returning the default value)' 12 TL (24    assert_eq\(get_score\(scores, 9999\), 0\))' 12 TL (25  })' T* 12 TL T* /F0 20 Tf (Implementation Notes) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The SortedMap is implemented as an AVL tree, a self-balancing binary search tree) Tj T* (. After insertions and deletions, the tree automatically rebalances to maintain ) Tj T* (O\(log n\) search, insertion, and deletion times.) Tj T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Key properties of the AVL tree implementation:) Tj T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Each node stores a balance factor \(height difference between left and right sub) Tj T* (trees\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (The balance factor is maintained between -1 and 1 for all nodes) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Rebalancing is done through tree rotations \(single and double rotations\)) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Comparison with Other Collections) Tj 20 TL T* ET
endstream
endobj
258 0 obj
<<
  /Type /Page  
  /Contents 257 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
259 0 obj
<<
  /Length 2546
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (@hashmap.T) Tj /F0 12 Tf (: Provides O\(1\) average case lookups but doesn't maintain order; use) Tj T* ( when order doesn't matter) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (@indexmap.T) Tj /F0 12 Tf (: Maintains insertion order but not sorted order; use when insertion ) Tj T* (order matters) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (@sorted_map.SortedMap) Tj /F0 12 Tf (: Maintains keys in sorted order; use when you need keys to) Tj T* ( be sorted) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Choose SortedMap when you need:) Tj T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Key-value pairs sorted by key) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Efficient range queries) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Ordered traversal guarantees) Tj T* -10 0 Td 12 TL T* /F0 24 Tf (MoonBit QuickCheck Package) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (MoonBit QuickCheck package provides property-based testing capabilities by gener) Tj T* (ating random test inputs.) Tj T* 12 TL T* /F0 20 Tf (Basic Usage) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Generate random values of any type that implements the ) Tj /F0 12 Tf (Arbitrary) Tj /F0 12 Tf ( trait:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "basic generation" {)' 12 TL (3     let b : Bool = @quickcheck.gen\(\))' 12 TL (4     inspect\(b, content="true"\))' 12 TL (5     let x : Int = @quickcheck.gen\(\))' 12 TL (6     inspect\(x, content="0"\))' 12 TL (7   )' 12 TL (8     // Generate with size parameter)' 12 TL (9     let sized : Array[Int] = @quickcheck.gen\(size=5\))' 12 TL (10    inspect\(sized.length\(\) <= 5, content="true"\))' 12 TL (11  })' T* 12 TL T* /F0 20 Tf (Multiple Samples) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Generate multiple test cases using the ) Tj /F0 12 Tf (samples) Tj /F0 12 Tf ( function:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "multiple samples" {)' 12 TL (3     let ints : Array[Int] = @quickcheck.samples\(5\))' 12 TL (4     inspect\(ints, content="[0, 0, 0, -1, -1]"\))' 12 TL (5     let strings : Array[String] = @quickcheck.samples\(12\))' 12 TL (6     inspect\()' 12 TL (7       strings[5:10],)' 12 TL (8       content=\()' 12 TL (9         #|["E\\b\\u{0f} ", "", "K\\u{1f}[", "!@", "xvLxb"])' 12 TL (10      \),)' 12 TL (11    \))' 12 TL (12  })' T* ET
endstream
endobj
260 0 obj
<<
  /Type /Page  
  /Contents 259 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
261 0 obj
<<
  /Length 2009
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F0 20 Tf (Built-in Types) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (QuickCheck provides ) Tj /F0 12 Tf (Arbitrary) Tj /F0 12 Tf ( implementations for all basic MoonBit types:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "builtin types" {)' 12 TL (3     // Basic types)' 12 TL (4     let v : \(Bool, Char, Byte\) = @quickcheck.gen\(\))' 12 TL (5     inspect\(v, content="\(true, '#', b'\\\\x12'\)"\))' 12 TL (6     // Numeric types)' 12 TL (7     let v : \(Int, Int64, UInt, UInt64, Float, Double, BigInt\) = @quickcheck.gen\(\))' 12 TL (8     inspect\(v, content="\(0, 0, 0, 0, 0.1430625319480896, 0.33098446695254635, 0\)"\))' 12 TL (9     // Collections)' 12 TL (10  )' 12 TL (11    let v : \(String, Bytes, Iter[Int]\) = @quickcheck.gen\(\))' 12 TL (12    inspect\()' 12 TL (13      v,)' 12 TL (14      content=\()' 12 TL (15        #|\("", b"", []\))' 12 TL (16      \),)' 12 TL (17    \))' 12 TL (18  })' T* 12 TL T* /F0 20 Tf (Custom Types) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Implement ) Tj /F0 12 Tf (Arbitrary) Tj /F0 12 Tf ( trait for custom types:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   struct Point {)' 12 TL (3     x : Int)' 12 TL (4     y : Int)' 12 TL (5   } derive\(Show\))' 12 TL (6   )' 12 TL (7   ///|)' 12 TL (8   impl Arbitrary for Point with arbitrary\(size, r0\) {)' 12 TL (9     let r1 = r0.split\(\))' 12 TL (10    let y = @quickcheck.Arbitrary::arbitrary\(size, r1\))' 12 TL (11    { x: @quickcheck.Arbitrary::arbitrary\(size, r0\), y })' 12 TL (12  })' 12 TL (13  )' 12 TL (14  ///|)' 12 TL (15  test "custom type generation" {)' 12 TL (16    let point : Point = @quickcheck.gen\(\))' 12 TL (17    inspect\(point, content="{x: 0, y: 0}"\))' 12 TL (18    let points : Array[Point] = @quickcheck.samples\(10\))' 12 TL (19    inspect\()' 12 TL (20      points[6:],)' 12 TL (21      content="[{x: 0, y: 1}, {x: -1, y: -5}, {x: -6, y: -6}, {x: -1, y: 7}]",)' 12 TL (22    \))' 12 TL (23  })' T* 12 TL T* ET
endstream
endobj
262 0 obj
<<
  /Type /Page  
  /Contents 261 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
263 0 obj
<<
  /Length 2119
>>
stream
 1 0 0 1 50 770 cm BT 12 TL /F0 12 Tf /F0 12 Tf (The package is useful for writing property tests that verify code behavior acros) Tj T* (s a wide range of randomly generated inputs.) Tj T* 12 TL T* /F0 24 Tf (uint) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides functionalities for handling 32-bit unsigned integers in M) Tj T* (oonBit. To this end, it includes methods for converting between ) Tj /F0 12 Tf (UInt) Tj /F0 12 Tf ( and other n) Tj T* (umber formats, as well as utilities for byte representation.) Tj T* 12 TL T* /F0 20 Tf (Basic Properties) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (uint) Tj /F0 12 Tf ( provides constants for ) Tj /F0 12 Tf (UInt) Tj /F0 12 Tf ('s value range and default value:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "uint basics" {)' 12 TL (3     // Default value is 0)' 12 TL (4     inspect\(@uint.default\(\), content="0"\))' 12 TL (5   )' 12 TL (6     // Maximum and minimum values)' 12 TL (7     inspect\(@uint.max_value, content="4294967295"\))' 12 TL (8     inspect\(@uint.min_value, content="0"\))' 12 TL (9   })' T* 12 TL T* /F0 20 Tf (Byte Representation) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (UInt) Tj /F0 12 Tf ( can be converted to bytes in both big-endian and little-endian formats:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "uint byte conversion" {)' 12 TL (3     let num = 258U // 0x00000102 in hex)' 12 TL (4   )' 12 TL (5     // Big-endian bytes \(most significant byte first\))' 12 TL (6     let be_bytes = num.to_be_bytes\(\))' 12 TL (7     inspect\()' 12 TL (8       be_bytes,)' 12 TL (9       content=\()' 12 TL (10        #|b"\\x00\\x00\\x01\\x02")' 12 TL (11      \),)' 12 TL (12    \))' 12 TL (13  )' 12 TL (14    // Little-endian bytes \(least significant byte first\))' 12 TL (15    let le_bytes = num.to_le_bytes\(\))' 12 TL (16    inspect\()' 12 TL (17      le_bytes,)' 12 TL (18      content=\()' 12 TL (19        #|b"\\x02\\x01\\x00\\x00")' 12 TL (20      \),)' 12 TL (21    \))' 12 TL (22  })' T* 12 TL T* /F0 20 Tf (Converting to Other Number Types) Tj 20 TL T* 12 TL T* ET
endstream
endobj
264 0 obj
<<
  /Type /Page  
  /Contents 263 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
265 0 obj
<<
  /Length 1616
>>
stream
 1 0 0 1 50 770 cm BT 12 TL /F0 12 Tf /F0 12 Tf (UInt) Tj /F0 12 Tf ( can be converted to ) Tj /F0 12 Tf (Int64) Tj /F0 12 Tf ( when you need to work with signed 64-bit integers) Tj T* (:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "uint type conversion" {)' 12 TL (3     let num = 42U)' 12 TL (4     inspect\(num.to_int64\(\), content="42"\))' 12 TL (5     let large_num = 4294967295U // max value)' 12 TL (6     inspect\(large_num.to_int64\(\), content="4294967295"\))' 12 TL (7   })' T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (These conversion functions are also available as methods:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "uint methods" {)' 12 TL (3     let num = 1000U)' 12 TL (4   )' 12 TL (5     // Using method syntax)' 12 TL (6     inspect\(num.to_int64\(\), content="1000"\))' 12 TL (7     inspect\()' 12 TL (8       num.to_be_bytes\(\),)' 12 TL (9       content=\()' 12 TL (10        #|b"\\x00\\x00\\x03\\xe8")' 12 TL (11      \),)' 12 TL (12    \))' 12 TL (13    inspect\()' 12 TL (14      num.to_le_bytes\(\),)' 12 TL (15      content=\()' 12 TL (16        #|b"\\xe8\\x03\\x00\\x00")' 12 TL (17      \),)' 12 TL (18    \))' 12 TL (19  })' T* 12 TL T* /F0 24 Tf (json) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The ) Tj /F0 12 Tf (json) Tj /F0 12 Tf ( package provides comprehensive JSON handling capabilities, including pa) Tj T* (rsing, stringifying, and type-safe conversion between JSON and other MoonBit dat) Tj T* (a types.) Tj T* 12 TL T* /F0 20 Tf (Basic JSON Operations) Tj 20 TL T* 12 TL T* /F0 16 Tf (Parsing and Validating JSON) Tj 16 TL T* 12 TL T* ET
endstream
endobj
266 0 obj
<<
  /Type /Page  
  /Contents 265 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
267 0 obj
<<
  /Length 1084
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "parse and validate jsons" {)' 12 TL (3     // Check if a string is valid JSON)' 12 TL (4     assert_true\(@json.valid\("{\\"key\\": 42}"\)\))' 12 TL (5     assert_true\(@json.valid\("[1, 2, 3]"\)\))' 12 TL (6     assert_true\(@json.valid\("null"\)\))' 12 TL (7     assert_true\(@json.valid\("false"\)\))' 12 TL (8   )' 12 TL (9     // Parse JSON string into Json value)' 12 TL (10    let json = @json.parse\("{\\"key\\": 42}"\) catch {)' 12 TL (11      \(_ : @json.ParseError\) => panic\(\))' 12 TL (12      // _ => panic\(\) // redundant, the type checker won't refine further)' 12 TL (13    })' 12 TL (14  )' 12 TL (15    // Pretty print with indentation)' 12 TL (16    inspect\()' 12 TL (17      json.stringify\(indent=2\),)' 12 TL (18      content={)' 12 TL (19        let output =)' 12 TL (20          #|{)' 12 TL (21          #|  "key": 42)' 12 TL (22          #|})' 12 TL (23        output)' 12 TL (24      },)' 12 TL (25    \))' 12 TL (26  })' T* 12 TL T* /F0 16 Tf (Object Navigation) Tj 16 TL T* 12 TL T* ET
endstream
endobj
268 0 obj
<<
  /Type /Page  
  /Contents 267 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
269 0 obj
<<
  /Length 1989
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "json object navigation" {)' 12 TL (3     let json = @json.parse\()' 12 TL (4       "{\\"string\\":\\"hello\\",\\"number\\":42,\\"array\\":[1,2,3]}",)' 12 TL (5     \))' 12 TL (6   )' 12 TL (7     // Access string)' 12 TL (8     let string_opt = json.value\("string"\).unwrap\(\).as_string\(\))' 12 TL (9     inspect\()' 12 TL (10      string_opt,)' 12 TL (11      content=\()' 12 TL (12        #|Some\("hello"\))' 12 TL (13      \),)' 12 TL (14    \))' 12 TL (15  )' 12 TL (16    // Access number)' 12 TL (17    let number_opt = json.value\("number"\).unwrap\(\).as_number\(\))' 12 TL (18    inspect\(number_opt, content="Some\(42\)"\))' 12 TL (19  )' 12 TL (20    // Access array)' 12 TL (21    let array_opt = json.value\("array"\).unwrap\(\).as_array\(\))' 12 TL (22    inspect\(array_opt, content="Some\([Number\(1\), Number\(2\), Number\(3\)]\)"\))' 12 TL (23  )' 12 TL (24    // Handle missing keys gracefully)' 12 TL (25    inspect\(json.value\("missing"\), content="None"\))' 12 TL (26  })' T* 12 TL T* /F0 16 Tf (Array Navigation) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "json array navigation" {)' 12 TL (3     let array = @json.parse\("[1,2,3,4,5]"\))' 12 TL (4   )' 12 TL (5     // Access by index)' 12 TL (6     let first = array.item\(0\))' 12 TL (7     inspect\(first, content="Some\(Number\(1\)\)"\))' 12 TL (8   )' 12 TL (9     // Access out of bounds)' 12 TL (10    let missing = array.item\(10\))' 12 TL (11    inspect\(missing, content="None"\))' 12 TL (12  )' 12 TL (13    // Iterate through array)' 12 TL (14    let values = array.as_array\(\).unwrap\(\))' 12 TL (15    inspect\()' 12 TL (16      values.iter\(\),)' 12 TL (17      content="[Number\(1\), Number\(2\), Number\(3\), Number\(4\), Number\(5\)]",)' 12 TL (18    \))' 12 TL (19  })' T* 12 TL T* /F0 20 Tf (Type-Safe JSON Conversion) Tj 20 TL T* 12 TL T* /F0 16 Tf (From JSON to Native Types) Tj 16 TL T* 12 TL T* ET
endstream
endobj
270 0 obj
<<
  /Type /Page  
  /Contents 269 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
271 0 obj
<<
  /Length 1947
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "json decode" {)' 12 TL (3     // Decode basic types)' 12 TL (4     let json_number = \(42 : Json\))' 12 TL (5     let number : Int = @json.from_json\(json_number\))' 12 TL (6     inspect\(number, content="42"\))' 12 TL (7   )' 12 TL (8     // Decode arrays)' 12 TL (9     let json_array = \([1, 2, 3] : Json\))' 12 TL (10    let array : Array[Int] = @json.from_json\(json_array\))' 12 TL (11    inspect\(array, content="[1, 2, 3]"\))' 12 TL (12  )' 12 TL (13    // Decode maps)' 12 TL (14    let json_map = \({ "a": 1, "b": 2 } : Json\))' 12 TL (15    let map : Map[String, Int] = @json.from_json\(json_map\))' 12 TL (16    inspect\()' 12 TL (17      map,)' 12 TL (18      content=\()' 12 TL (19        #|{"a": 1, "b": 2})' 12 TL (20      \),)' 12 TL (21    \))' 12 TL (22  })' T* 12 TL T* /F0 16 Tf (Error Handling with JSON Path) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "json path" {)' 12 TL (3     // Handle decode errors)' 12 TL (4     try {)' 12 TL (5       let _arr : Array[Int] = @json.from_json\(\([42, "not a number", 49] : Json\)\))' 12 TL (6       panic\(\))' 12 TL (7     } catch {)' 12 TL (8       @json.JsonDecodeError\(\(path, msg\)\) => {)' 12 TL (9         inspect\(path, content="$[1]"\))' 12 TL (10        inspect\(msg, content="Int::from_json: expected number"\))' 12 TL (11      })' 12 TL (12    })' 12 TL (13  })' T* 12 TL T* /F0 20 Tf (JSON-based Snapshot Testing) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (@json.inspect\(\)) Tj /F0 12 Tf ( can be used as an alternative to ) Tj /F0 12 Tf (inspect\(\)) Tj /F0 12 Tf ( when a value's ) Tj /F0 12 Tf (To) Tj T* (Json) Tj /F0 12 Tf ( implementation is considered a better debugging representation than its ) Tj /F0 12 Tf (Sho) Tj T* (w) Tj /F0 12 Tf ( implementation.) Tj /F0 12 Tf ( ) Tj /F0 12 Tf (This is particularly true for deeply-nested data structures.) Tj T* 12 TL T* ET
endstream
endobj
272 0 obj
<<
  /Type /Page  
  /Contents 271 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
273 0 obj
<<
  /Length 2045
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "json inspection" {)' 12 TL (3     let null = null)' 12 TL (4   )' 12 TL (5     // Simple json values)' 12 TL (6     let json_value : Json = { "key": "value", "numbers": [1, 2, 3] })' 12 TL (7     @json.inspect\(json_value, content={ "key": "value", "numbers": [1, 2, 3] }\))' 12 TL (8   )' 12 TL (9     // Null and boolean values)' 12 TL (10    let json_special = { "null": null, "bool": true })' 12 TL (11    @json.inspect\(json_special, content={ "null": null, "bool": true }\))' 12 TL (12  })' T* 12 TL T* /F0 24 Tf (Env Package Documentation) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (This package provides utilities for interacting with the runtime environment, in) Tj T* (cluding access to command line arguments, current time, and working directory in) Tj T* (formation.) Tj T* 12 TL T* /F0 20 Tf (Command Line Arguments) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Access command line arguments passed to your program:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "command line arguments" {)' 12 TL (3     let arguments = @env.args\(\))' 12 TL (4   )' 12 TL (5     // The arguments array contains program arguments)' 12 TL (6     // In a test environment, this will typically be empty or contain test runner args)' 12 TL (7     inspect\(arguments.length\(\) >= 0, content="true"\))' 12 TL (8   )' 12 TL (9     // Example of how you might process arguments in a real program:)' 12 TL (10    fn process_args\(args : Array[String]\) -> String {)' 12 TL (11      if args.length\(\) == 0 {)' 12 TL (12        "No arguments provided")' 12 TL (13      } else {)' 12 TL (14        "First argument: " + args[0])' 12 TL (15      })' 12 TL (16    })' 12 TL (17  )' 12 TL (18    let result = process_args\(arguments\))' 12 TL (19    inspect\(result.length\(\) > 0, content="true"\))' 12 TL (20  })' T* 12 TL T* /F0 20 Tf (Current Time) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get the current time in milliseconds since Unix epoch:) Tj T* 12 TL T* ET
endstream
endobj
274 0 obj
<<
  /Type /Page  
  /Contents 273 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
275 0 obj
<<
  /Length 1648
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "current time" {)' 12 TL (3     let timestamp = @env.now\(\))' 12 TL (4   )' 12 TL (5     // Timestamp should be a reasonable value \(after year 2020\))' 12 TL (6     let year_2020_ms = 1577836800000UL // Jan 1, 2020 in milliseconds)' 12 TL (7     inspect\(timestamp > year_2020_ms, content="true"\))' 12 TL (8   )' 12 TL (9     // Demonstrate time-based operations)' 12 TL (10    fn format_timestamp\(ts : UInt64\) -> String {)' 12 TL (11      "Timestamp: " + ts.to_string\(\))' 12 TL (12    })' 12 TL (13  )' 12 TL (14    let formatted = format_timestamp\(timestamp\))' 12 TL (15    inspect\(formatted.length\(\) > 10, content="true"\) // Should contain timestamp data)' 12 TL (16  })' T* 12 TL T* /F0 20 Tf (Working Directory) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get the current working directory:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "working directory" {)' 12 TL (3     let cwd = @env.current_dir\(\))' 12 TL (4     match cwd {)' 12 TL (5       Some\(path\) => {)' 12 TL (6         // We have a current directory)' 12 TL (7         inspect\(path.length\(\) > 0, content="true"\))' 12 TL (8         inspect\(path.length\(\) > 1, content="true"\) // Should be a meaningful path)' 12 TL (9       })' 12 TL (10      None =>)' 12 TL (11        // Current directory unavailable \(some platforms/environments\))' 12 TL (12        inspect\(true, content="true"\) // This is also valid)' 12 TL (13    })' 12 TL (14  })' T* 12 TL T* /F0 20 Tf (Practical Usage Examples) Tj 20 TL T* 12 TL T* /F0 16 Tf (Command Line Tool Pattern) Tj 16 TL T* 12 TL T* ET
endstream
endobj
276 0 obj
<<
  /Type /Page  
  /Contents 275 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
277 0 obj
<<
  /Length 2456
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "command line tool pattern" {)' 12 TL (3     fn parse_command\(args : Array[String]\) -> Result[String, String] {)' 12 TL (4       if args.length\(\) < 2 {)' 12 TL (5         Err\("Usage: program <command> [args...]"\))' 12 TL (6       } else {)' 12 TL (7         match args[1] {)' 12 TL (8           "help" => Ok\("Showing help information"\))' 12 TL (9           "version" => Ok\("Version 1.0.0"\))' 12 TL (10          "status" => Ok\("System is running"\))' 12 TL (11          cmd => Err\("Unknown command: " + cmd\))' 12 TL (12        })' 12 TL (13      })' 12 TL (14    })' 12 TL (15  )' 12 TL (16    // Test with mock arguments)' 12 TL (17    let test_args = ["program", "help"])' 12 TL (18    let result = parse_command\(test_args\))' 12 TL (19    inspect\(result, content="Ok\(\\"Showing help information\\"\)"\))' 12 TL (20    let invalid_result = parse_command\(["program", "invalid"]\))' 12 TL (21    match invalid_result {)' 12 TL (22      Ok\(_\) => inspect\(false, content="true"\))' 12 TL (23      Err\(msg\) => inspect\(msg.length\(\) > 10, content="true"\) // Should have error message)' 12 TL (24    })' 12 TL (25  })' T* 12 TL T* /F0 16 Tf (Configuration Loading) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "configuration loading" {)' 12 TL (3     fn load_config_path\(\) -> String {)' 12 TL (4       match @env.current_dir\(\) {)' 12 TL (5         Some\(cwd\) => cwd + "/config.json")' 12 TL (6         None => "./config.json" // Fallback)' 12 TL (7       })' 12 TL (8     })' 12 TL (9   )' 12 TL (10    let config_path = load_config_path\(\))' 12 TL (11    inspect\(config_path.length\(\) > 10, content="true"\) // Should have path with config.json)' 12 TL (12  })' T* 12 TL T* /F0 16 Tf (Logging with Timestamps) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "logging with timestamps" {)' 12 TL (3     fn log_message\(level : String, message : String\) -> String {)' 12 TL (4       let timestamp = @env.now\(\))' 12 TL (5       "[" + timestamp.to_string\(\) + "] " + level + ": " + message)' 12 TL (6     })' 12 TL (7   )' 12 TL (8     let log_entry = log_message\("INFO", "Application started"\))' 12 TL (9     inspect\(log_entry.length\(\) > 20, content="true"\) // Should have timestamp and message)' 12 TL (10    inspect\(log_entry.length\(\) > 10, content="true"\) // Should have substantial content)' 12 TL (11  })' T* ET
endstream
endobj
278 0 obj
<<
  /Type /Page  
  /Contents 277 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
279 0 obj
<<
  /Length 2397
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F0 16 Tf (File Path Operations) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "file path operations" {)' 12 TL (3     fn resolve_relative_path\(relative : String\) -> String {)' 12 TL (4       match @env.current_dir\(\) {)' 12 TL (5         Some\(base\) => base + "/" + relative)' 12 TL (6         None => relative)' 12 TL (7       })' 12 TL (8     })' 12 TL (9   )' 12 TL (10    let resolved = resolve_relative_path\("data/input.txt"\))' 12 TL (11    inspect\(resolved.length\(\) > 10, content="true"\) // Should have resolved path)' 12 TL (12  })' T* 12 TL T* /F0 20 Tf (Platform Differences) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The env package behaves differently across platforms:) Tj T* 12 TL T* /F0 16 Tf (JavaScript Environment) Tj 16 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (args\(\)) Tj /F0 12 Tf ( returns arguments from the JavaScript environment) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (@env.now\(\)) Tj /F0 12 Tf ( uses ) Tj /F0 12 Tf (Date.@env.now\(\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (@env.current_dir\(\)) Tj /F0 12 Tf ( may return ) Tj /F0 12 Tf (None) Tj /F0 12 Tf ( in browser environments) Tj T* -10 0 Td 12 TL T* /F0 16 Tf (WebAssembly Environment) Tj 16 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (args\(\)) Tj /F0 12 Tf ( behavior depends on the WASM host) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (@env.now\(\)) Tj /F0 12 Tf ( provides millisecond precision timing) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (@env.current_dir\(\)) Tj /F0 12 Tf ( availability depends on host capabilities) Tj T* -10 0 Td 12 TL T* /F0 16 Tf (Native Environment) Tj 16 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (args\(\)) Tj /F0 12 Tf ( returns actual command line arguments) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (@env.now\(\)) Tj /F0 12 Tf ( provides system time) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (@env.current_dir\(\)) Tj /F0 12 Tf ( uses system calls to get working directory) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Error Handling) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Handle cases where environment information is unavailable:) Tj T* 12 TL T* ET
endstream
endobj
280 0 obj
<<
  /Type /Page  
  /Contents 279 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
281 0 obj
<<
  /Length 1871
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "error handling" {)' 12 TL (3     fn safe_get_cwd\(\) -> String {)' 12 TL (4       match @env.current_dir\(\) {)' 12 TL (5         Some\(path\) => path)' 12 TL (6         None =>)' 12 TL (7           // Fallback when current directory is unavailable)' 12 TL (8           ".")' 12 TL (9       })' 12 TL (10    })' 12 TL (11  )' 12 TL (12    let safe_cwd = safe_get_cwd\(\))' 12 TL (13    inspect\(safe_cwd.length\(\) > 0, content="true"\))' 12 TL (14    fn validate_args\()' 12 TL (15      args : Array[String],)' 12 TL (16      min_count : Int,)' 12 TL (17    \) -> Result[Unit, String] {)' 12 TL (18      if args.length\(\) < min_count {)' 12 TL (19        Err\("Insufficient arguments: expected at least " + min_count.to_string\(\)\))' 12 TL (20      } else {)' 12 TL (21        Ok\(\(\)\))' 12 TL (22      })' 12 TL (23    })' 12 TL (24  )' 12 TL (25    let validation = validate_args\(["prog"], 2\))' 12 TL (26    match validation {)' 12 TL (27      Ok\(_\) => inspect\(false, content="true"\))' 12 TL (28      Err\(msg\) => inspect\(msg.length\(\) > 10, content="true"\) // Should have error message)' 12 TL (29    })' 12 TL (30  })' T* 12 TL T* /F0 20 Tf (Best Practices) Tj 20 TL T* 12 TL T* /F0 16 Tf (1. Handle Missing Environment Data Gracefully) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "graceful handling" {)' 12 TL (3     fn get_work_dir\(\) -> String {)' 12 TL (4       match @env.current_dir\(\) {)' 12 TL (5         Some\(dir\) => dir)' 12 TL (6         None => "~" // Fallback to home directory symbol)' 12 TL (7       })' 12 TL (8     })' 12 TL (9   )' 12 TL (10    let work_dir = get_work_dir\(\))' 12 TL (11    inspect\(work_dir.length\(\) > 0, content="true"\))' 12 TL (12  })' T* 12 TL T* /F0 16 Tf (2. Validate Command Line Arguments) Tj 16 TL T* 12 TL T* ET
endstream
endobj
282 0 obj
<<
  /Type /Page  
  /Contents 281 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
283 0 obj
<<
  /Length 2904
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "argument validation" {)' 12 TL (3     fn validate_and_parse_args\()' 12 TL (4       args : Array[String],)' 12 TL (5     \) -> Result[\(String, Array[String]\), String] {)' 12 TL (6       if args.length\(\) == 0 {)' 12 TL (7         Err\("No program name available"\))' 12 TL (8       } else if args.length\(\) == 1 {)' 12 TL (9         Ok\(\(args[0], []\)\) // Program name only, no arguments)' 12 TL (10      } else {)' 12 TL (11        let program = args[0])' 12 TL (12        let arguments = Array::new\(\))' 12 TL (13        for i in 1..<args.length\(\) {)' 12 TL (14          arguments.push\(args[i]\))' 12 TL (15        })' 12 TL (16        Ok\(\(program, arguments\)\))' 12 TL (17      })' 12 TL (18    })' 12 TL (19  )' 12 TL (20    let test_result = validate_and_parse_args\(["myprogram", "arg1", "arg2"]\))' 12 TL (21    match test_result {)' 12 TL (22      Ok\(\(prog, args\)\) => {)' 12 TL (23        inspect\(prog, content="myprogram"\))' 12 TL (24        inspect\(args.length\(\), content="2"\))' 12 TL (25      })' 12 TL (26      Err\(_\) => inspect\(false, content="true"\))' 12 TL (27    })' 12 TL (28  })' T* 12 TL T* /F0 16 Tf (3. Use Timestamps for Unique Identifiers) Tj 16 TL T* 12 TL T* /F4 12 Tf 12 TL (1   ///|)' 12 TL (2   test "unique identifiers" {)' 12 TL (3     fn generate_unique_id\(prefix : String\) -> String {)' 12 TL (4       prefix + "_" + @env.now\(\).to_string\(\))' 12 TL (5     })' 12 TL (6   )' 12 TL (7     let id1 = generate_unique_id\("task"\))' 12 TL (8     let id2 = generate_unique_id\("task"\))' 12 TL (9     inspect\(id1.length\(\) > 10, content="true"\) // Should have task prefix and timestamp)' 12 TL (10    inspect\(id2.length\(\) > 10, content="true"\) // Should have task prefix and timestamp)' 12 TL (11    // IDs should be different \(though they might be the same in fast tests\))' 12 TL (12  })' T* 12 TL T* /F0 20 Tf (Common Use Cases) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Command Line Tools) Tj /F0 12 Tf (: Parse arguments and provide help/usage information) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Configuration Management) Tj /F0 12 Tf (: Load config files relative to current directory) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Logging Systems) Tj /F0 12 Tf (: Add timestamps to log entries) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (File Processing) Tj /F0 12 Tf (: Resolve relative file paths) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Debugging) Tj /F0 12 Tf (: Include environment information in error reports) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (Build Tools) Tj /F0 12 Tf (: Determine working directory for relative path operations) Tj T* -10 0 Td 12 TL T* ET
endstream
endobj
284 0 obj
<<
  /Type /Page  
  /Contents 283 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
285 0 obj
<<
  /Length 953
>>
stream
 1 0 0 1 50 770 cm BT /F0 20 Tf (Performance Considerations) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (args\(\)) Tj /F0 12 Tf ( is typically called once at program startup) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (@env.now\(\)) Tj /F0 12 Tf ( is lightweight but avoid calling in tight loops if high precision i) Tj T* (sn't needed) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (@env.current_dir\(\)) Tj /F0 12 Tf ( may involve system calls, so cache the result if used frequ) Tj T* (ently) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Environment functions are generally fast but platform-dependent) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The env package provides essential runtime environment access for building robus) Tj T* (t MoonBit applications that interact with their execution environment.) Tj T* 12 TL T* ET
endstream
endobj
286 0 obj
<<
  /Type /Page  
  /Contents 285 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
xref
0 287
0000000000 65535 f 
0000000055 00000 n
0000001148 00000 n
0000022677 00000 n
0000000521 00000 n
0000001403 00000 n
0000000521 00000 n
0000001651 00000 n
0000000521 00000 n
0000002115 00000 n
0000000522 00000 n
0000001872 00000 n
0000000523 00000 n
0000001860 00000 n
0000000523 00000 n
0000002028 00000 n
0000000523 00000 n
0000002950 00000 n
0000000523 00000 n
0000002008 00000 n
0000000523 00000 n
0000001291 00000 n
0000000523 00000 n
0000002011 00000 n
0000000523 00000 n
0000002085 00000 n
0000000523 00000 n
0000001348 00000 n
0000000523 00000 n
0000001584 00000 n
0000000523 00000 n
0000001669 00000 n
0000000523 00000 n
0000002883 00000 n
0000000523 00000 n
0000002259 00000 n
0000000523 00000 n
0000001836 00000 n
0000000523 00000 n
0000001965 00000 n
0000000523 00000 n
0000002335 00000 n
0000000523 00000 n
0000002104 00000 n
0000000523 00000 n
0000003221 00000 n
0000000523 00000 n
0000002888 00000 n
0000000523 00000 n
0000002685 00000 n
0000000523 00000 n
0000001432 00000 n
0000000523 00000 n
0000001682 00000 n
0000000523 00000 n
0000001972 00000 n
0000000523 00000 n
0000001782 00000 n
0000000523 00000 n
0000003001 00000 n
0000000523 00000 n
0000001691 00000 n
0000000523 00000 n
0000001806 00000 n
0000000523 00000 n
0000001759 00000 n
0000000523 00000 n
0000001363 00000 n
0000000523 00000 n
0000003027 00000 n
0000000523 00000 n
0000002550 00000 n
0000000523 00000 n
0000002005 00000 n
0000000523 00000 n
0000002219 00000 n
0000000523 00000 n
0000001894 00000 n
0000000523 00000 n
0000002031 00000 n
0000000523 00000 n
0000002047 00000 n
0000000523 00000 n
0000002208 00000 n
0000000523 00000 n
0000001828 00000 n
0000000523 00000 n
0000002134 00000 n
0000000523 00000 n
0000002161 00000 n
0000000523 00000 n
0000002686 00000 n
0000000523 00000 n
0000002044 00000 n
0000000523 00000 n
0000002106 00000 n
0000000523 00000 n
0000002381 00000 n
0000000523 00000 n
0000001238 00000 n
0000000524 00000 n
0000002383 00000 n
0000000525 00000 n
0000001405 00000 n
0000000525 00000 n
0000002254 00000 n
0000000525 00000 n
0000001428 00000 n
0000000525 00000 n
0000001873 00000 n
0000000525 00000 n
0000003375 00000 n
0000000525 00000 n
0000001375 00000 n
0000000525 00000 n
0000001123 00000 n
0000000525 00000 n
0000001268 00000 n
0000000525 00000 n
0000002132 00000 n
0000000525 00000 n
0000002159 00000 n
0000000525 00000 n
0000002002 00000 n
0000000525 00000 n
0000001926 00000 n
0000000525 00000 n
0000003096 00000 n
0000000525 00000 n
0000002457 00000 n
0000000525 00000 n
0000002152 00000 n
0000000525 00000 n
0000002399 00000 n
0000000525 00000 n
0000002103 00000 n
0000000525 00000 n
0000001745 00000 n
0000000525 00000 n
0000001508 00000 n
0000000525 00000 n
0000002128 00000 n
0000000525 00000 n
0000001879 00000 n
0000000525 00000 n
0000002197 00000 n
0000000525 00000 n
0000002264 00000 n
0000000525 00000 n
0000002428 00000 n
0000000525 00000 n
0000002344 00000 n
0000000525 00000 n
0000002293 00000 n
0000000525 00000 n
0000002407 00000 n
0000000525 00000 n
0000000927 00000 n
0000000525 00000 n
0000001759 00000 n
0000000525 00000 n
0000002041 00000 n
0000000525 00000 n
0000001368 00000 n
0000000525 00000 n
0000002886 00000 n
0000000525 00000 n
0000002145 00000 n
0000000525 00000 n
0000002186 00000 n
0000000525 00000 n
0000003178 00000 n
0000000525 00000 n
0000001914 00000 n
0000000525 00000 n
0000002706 00000 n
0000000525 00000 n
0000001752 00000 n
0000000525 00000 n
0000001386 00000 n
0000000525 00000 n
0000001421 00000 n
0000000525 00000 n
0000001788 00000 n
0000000525 00000 n
0000001855 00000 n
0000000525 00000 n
0000001375 00000 n
0000000525 00000 n
0000002261 00000 n
0000000525 00000 n
0000003284 00000 n
0000000525 00000 n
0000001854 00000 n
0000000525 00000 n
0000002121 00000 n
0000000525 00000 n
0000002113 00000 n
0000000525 00000 n
0000002157 00000 n
0000000525 00000 n
0000002175 00000 n
0000000525 00000 n
0000001694 00000 n
0000000525 00000 n
0000002235 00000 n
0000000525 00000 n
0000001394 00000 n
0000000525 00000 n
0000002128 00000 n
0000000525 00000 n
0000002147 00000 n
0000000525 00000 n
0000002759 00000 n
0000000525 00000 n
0000002457 00000 n
0000000525 00000 n
0000001776 00000 n
0000000525 00000 n
0000001482 00000 n
0000000525 00000 n
0000001825 00000 n
0000000525 00000 n
0000001369 00000 n
0000000525 00000 n
0000002189 00000 n
0000000525 00000 n
0000002461 00000 n
0000000525 00000 n
0000002546 00000 n
0000000525 00000 n
0000002585 00000 n
0000000525 00000 n
0000001877 00000 n
0000000525 00000 n
0000001805 00000 n
0000000525 00000 n
0000002283 00000 n
0000000525 00000 n
0000002159 00000 n
0000000525 00000 n
0000002093 00000 n
0000000525 00000 n
0000001940 00000 n
0000000525 00000 n
0000001893 00000 n
0000000525 00000 n
0000002408 00000 n
0000000525 00000 n
0000001947 00000 n
0000000525 00000 n
0000002017 00000 n
0000000525 00000 n
0000002230 00000 n
0000000525 00000 n
0000002843 00000 n
0000000525 00000 n
0000002553 00000 n
0000000525 00000 n
0000002602 00000 n
0000000525 00000 n
0000002065 00000 n
0000000525 00000 n
0000002175 00000 n
0000000525 00000 n
0000001672 00000 n
0000000525 00000 n
0000001140 00000 n
0000000525 00000 n
0000002045 00000 n
0000000525 00000 n
0000002003 00000 n
0000000525 00000 n
0000002101 00000 n
0000000525 00000 n
0000001704 00000 n
0000000525 00000 n
0000002512 00000 n
0000000525 00000 n
0000002453 00000 n
0000000525 00000 n
0000001927 00000 n
0000000525 00000 n
0000002960 00000 n
0000000525 00000 n
0000001008 00000 n
0000000525 00000 n
trailer
<<
  /Size 5  
  /Root 1 0 R
>>
startxref
395457
%%EOF
