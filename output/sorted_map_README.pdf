%PDF-1.4
%ÄÅÇÉ
1 0 obj
<<
  /Type /Catalog  
  /Pages 2 0 R
>>
endobj
2 0 obj
<<
  /Type /Pages  
  /Kids [4 0 R 6 0 R 8 0 R 10 0 R 12 0 R 14 0 R 16 0 R 18 0 R]  
  /Count 8
>>
endobj
3 0 obj
<<
  /Length 824
>>
stream
 1 0 0 1 50 770 cm BT /F0 24 Tf 24 TL (Table of Contents)' /F0 12 Tf 12 TL T* (1)' 0 TL 40 0 Td (Sorted Map) Tj -40 0 Td 12 TL (1.1)' 0 TL 40 0 Td (Overview) Tj -40 0 Td 12 TL (1.2)' 0 TL 40 0 Td (Performance) Tj -40 0 Td 12 TL (1.3)' 0 TL 40 0 Td (Usage) Tj -40 0 Td 12 TL (1.3.1)' 0 TL 40 0 Td (Create) Tj -40 0 Td 12 TL (1.3.2)' 0 TL 40 0 Td (Container Operations) Tj -40 0 Td 12 TL (1.3.3)' 0 TL 40 0 Td (Data Extraction) Tj -40 0 Td 12 TL (1.3.4)' 0 TL 40 0 Td (Range Operations) Tj -40 0 Td 12 TL (1.3.5)' 0 TL 40 0 Td (Iterators) Tj -40 0 Td 12 TL (1.3.6)' 0 TL 40 0 Td (Equality) Tj -40 0 Td 12 TL (1.3.7)' 0 TL 40 0 Td (Error Handling Best Practices) Tj -40 0 Td 12 TL (1.4)' 0 TL 40 0 Td (Implementation Notes) Tj -40 0 Td 12 TL (1.5)' 0 TL 40 0 Td (Comparison with Other Collections) Tj -40 0 Td 12 TL 36 TL T* ET
endstream
endobj
4 0 obj
<<
  /Type /Page  
  /Contents 3 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
5 0 obj
<<
  /Length 3692
>>
stream
 1 0 0 1 50 770 cm BT /F0 24 Tf (Sorted Map) Tj 24 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (A mutable map backed by an AVL tree that maintains keys in sorted order.) Tj T* 12 TL T* /F0 20 Tf (Overview) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (SortedMap is an ordered map implementation that keeps entries sorted by keys. It) Tj T* ( provides efficient lookup, insertion, and deletion operations, with stable trav) Tj T* (ersal order based on key comparison.) Tj T* 12 TL T* /F0 20 Tf (Performance) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (add/set) Tj /F0 12 Tf (: O\(log n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (remove) Tj /F0 12 Tf (: O\(log n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (get/contains) Tj /F0 12 Tf (: O\(log n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (iterate) Tj /F0 12 Tf (: O\(n\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (range) Tj /F0 12 Tf (: O\(log n + k\) where k is number of elements in range) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (space complexity) Tj /F0 12 Tf (: O\(n\)) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Usage) Tj 20 TL T* 12 TL T* /F0 16 Tf (Create) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can create an empty SortedMap or a SortedMap from other containers.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( _map1) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.SortedMap) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.new) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( _map2) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* /F0 16 Tf (Container Operations) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Add a key-value pair to the SortedMap in place.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (  map) Tj 0 0 0 rg (.set) Tj 0 0 0 rg (\() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.size) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 3) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (You can also use the convenient subscript syntax to add or update values:) Tj T* 12 TL T* ET
endstream
endobj
6 0 obj
<<
  /Type /Page  
  /Contents 5 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
7 0 obj
<<
  /Length 5822
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.new) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (  map) Tj 0 0 0 rg ([) Tj 1 0 1 rg (1) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  map) Tj 0 0 0 rg ([) Tj 1 0 1 rg (2) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.size) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 2) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (7   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Remove a key-value pair from the SortedMap in place.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (  map) Tj 0 0 0 rg (.remove) Tj 0 0 0 rg (\() Tj 1 0 1 rg (2) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.size) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 2) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.contains) Tj 0 0 0 rg (\() Tj 1 0 1 rg (2) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 1 rg ( false) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (7   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get a value by its key. The return type is ) Tj /F0 12 Tf (Option[V]) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.get) Tj 0 0 0 rg (\() Tj 1 0 1 rg (2) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( Some) Tj 0 0 0 rg (\() Tj 1 0 0 rg ("two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.get) Tj 0 0 0 rg (\() Tj 1 0 1 rg (4) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( None) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Safe access with error handling:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( key) Tj 0 0 0 rg ( =) Tj 1 0 1 rg ( 3) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  inspect) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.get) Tj 0 0 0 rg (\() Tj 0 0 0 rg (key) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( content) Tj 0 0 0 rg (=) Tj 1 0 0 rg ("None") Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Check if a key exists in the map.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.contains) Tj 0 0 0 rg (\() Tj 1 0 1 rg (2) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 1 rg ( true) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.contains) Tj 0 0 0 rg (\() Tj 1 0 1 rg (4) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 1 rg ( false) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Iterate over all key-value pairs in the map in sorted key order.) Tj T* 12 TL T* ET
endstream
endobj
8 0 obj
<<
  /Type /Page  
  /Contents 7 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
9 0 obj
<<
  /Length 6792
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( keys) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (]) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( values) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (]) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (  map) Tj 0 0 0 rg (.each) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\() Tj 0 0 0 rg (k) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (7   ) Tj 0 0 0 rg (    keys) Tj 0 0 0 rg (.push) Tj 0 0 0 rg (\() Tj 0 0 0 rg (k) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (8   ) Tj 0 0 0 rg (    values) Tj 0 0 0 rg (.push) Tj 0 0 0 rg (\() Tj 0 0 0 rg (v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (9   ) Tj 0 0 0 rg (  }) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (10  ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (keys) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( [) Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 2) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 3) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (11  ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (values) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( [) Tj 1 0 0 rg ("one") Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (12  ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Iterate with index:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( result) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (]) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  map) Tj 0 0 0 rg (.eachi) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\() Tj 0 0 0 rg (i) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( k) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( result) Tj 0 0 0 rg (.push) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\() Tj 0 0 0 rg (i) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( k) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (result) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (\() Tj 1 0 1 rg (0) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (7   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get the size of the map.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.size) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 3) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Check if the map is empty.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.SortedMap) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.new) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.is_empty) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 1 rg ( true) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Clear the map.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (  map) Tj 0 0 0 rg (.clear) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.is_empty) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 1 rg ( true) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* /F0 16 Tf (Data Extraction) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get all keys or values from the map.) Tj T* 12 TL T* ET
endstream
endobj
10 0 obj
<<
  /Type /Page  
  /Contents 9 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
11 0 obj
<<
  /Length 8637
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.keys_as_iter) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (.collect) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( [) Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 2) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 3) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.values_as_iter) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (.collect) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( [) Tj 1 0 0 rg ("one") Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Convert the map to an array of key-value pairs.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.to_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* /F0 16 Tf (Range Operations) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Get a subset of the map within a specified range of keys. The range is inclusive) Tj T* ( for both bounds ) Tj /F0 12 Tf ([low, high]) Tj /F0 12 Tf (.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (    \() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (    \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (    \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg () Tj T* 12 TL (7   ) Tj 0 0 0 rg (    \() Tj 1 0 1 rg (4) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "four") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg () Tj T* 12 TL (8   ) Tj 0 0 0 rg (    \() Tj 1 0 1 rg (5) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "five") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg () Tj T* 12 TL (9   ) Tj 0 0 0 rg (  ]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (10  ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( range_items) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (]) Tj 0 0 0 rg () Tj T* 12 TL (11  ) Tj 0 0 0 rg (  map) Tj 0 0 0 rg (.range) Tj 0 0 0 rg (\() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 4) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (.each) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\() Tj 0 0 0 rg (k) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( range_items) Tj 0 0 0 rg (.push) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\() Tj 0 0 0 rg (k) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (12  ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (range_items) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (\() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (4) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "four") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (13  ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Edge cases for range operations:) Tj T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (If ) Tj /F0 12 Tf (low > high) Tj /F0 12 Tf (, returns an empty result) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (If ) Tj /F0 12 Tf (low) Tj /F0 12 Tf ( or ) Tj /F0 12 Tf (high) Tj /F0 12 Tf ( are outside the map bounds, returns only pairs within valid bound) Tj T* (s) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (The returned iterator preserves the sorted order of keys) Tj T* -10 0 Td 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 0 rg (                                     ) Tj T* 12 TL (3   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( range_items) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (]) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (  map) Tj 0 0 0 rg (.range) Tj 0 0 0 rg (\() Tj 1 0 1 rg (0) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 10) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (.each) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\() Tj 0 0 0 rg (k) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( range_items) Tj 0 0 0 rg (.push) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\() Tj 0 0 0 rg (k) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (7   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (range_items) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (8   ) Tj 0 0 0 rg () Tj T* 12 TL (9   ) Tj 0 0 0 rg (                               ) Tj T* 12 TL (10  ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( empty_range) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Array) Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( String) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (]) Tj 0 0 0 rg () Tj T* 12 TL (11  ) Tj 0 0 0 rg (  map) Tj 0 0 0 rg (.range) Tj 0 0 0 rg (\() Tj 1 0 1 rg (10) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 5) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (.each) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\() Tj 0 0 0 rg (k) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( empty_range) Tj 0 0 0 rg (.push) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\() Tj 0 0 0 rg (k) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (12  ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (empty_range) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (13  ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* ET
endstream
endobj
12 0 obj
<<
  /Type /Page  
  /Contents 11 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
13 0 obj
<<
  /Length 6053
>>
stream
 1 0 0 1 50 770 cm BT 12 TL T* /F0 16 Tf (Iterators) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The SortedMap supports several iterator patterns. Create a map from an iterator:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( pairs) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (.iter) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_iter) Tj 0 0 0 rg (\() Tj 0 0 0 rg (pairs) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map) Tj 0 0 0 rg (.size) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 3) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use the ) Tj /F0 12 Tf (iter) Tj /F0 12 Tf ( method to get an iterator over key-value pairs:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( pairs) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( map) Tj 0 0 0 rg (.iter) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (.to_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (pairs) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Use the ) Tj /F0 12 Tf (iter2) Tj /F0 12 Tf ( method for a more convenient key-value iteration:) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (3) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "three") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( transformed) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( [) Tj 0 0 0 rg (]) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  map) Tj 0 0 0 rg (.iter2) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg (.each) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\() Tj 0 0 0 rg (k) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( transformed) Tj 0 0 0 rg (.push) Tj 0 0 0 rg (\() Tj 0 0 0 rg (k) Tj 0 0 0 rg (.to_string) Tj 0 0 0 rg (\() Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( +) Tj 1 0 0 rg ( ": ") Tj 0 0 0 rg ( +) Tj 0 0 0 rg ( v) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (transformed) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( [) Tj 1 0 0 rg ("1: one") Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "2: two") Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "3: three") Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (7   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* /F0 16 Tf (Equality) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Maps with the same key-value pairs are considered equal, regardless of the order) Tj T* ( in which elements were added.) Tj T* 12 TL T* /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (test) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map1) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( map2) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (2) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "two") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (1) Tj 0 0 0 rg (,) Tj 1 0 0 rg ( "one") Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (map1) Tj 0 0 0 rg ( ==) Tj 0 0 0 rg ( map2) Tj 0 0 0 rg (,) Tj 0 0 1 rg ( true) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* /F0 16 Tf (Error Handling Best Practices) Tj 16 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (When working with keys that might not exist, prefer using pattern matching for s) Tj T* (afety:) Tj T* 12 TL T* ET
endstream
endobj
14 0 obj
<<
  /Type /Page  
  /Contents 13 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
15 0 obj
<<
  /Length 4521
>>
stream
 1 0 0 1 50 770 cm BT /F4 12 Tf 12 TL (1   ) Tj 0 0 0 rg (    ) Tj T* 12 TL (2   ) Tj 0 0 1 rg (fn) Tj 0 0 0 rg ( get_score) Tj 0 0 0 rg (\() Tj 0 0 0 rg (scores) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.SortedMap) Tj 0 0 0 rg ([) Tj 0 0 0 rg (Int) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( Int) Tj 0 0 0 rg (]) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( student_id) Tj 0 0 0 rg ( :) Tj 0 0 0 rg ( Int) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( ->) Tj 0 0 0 rg ( Int) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (3   ) Tj 0 0 1 rg (  match) Tj 0 0 0 rg ( scores) Tj 0 0 0 rg (.get) Tj 0 0 0 rg (\() Tj 0 0 0 rg (student_id) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (4   ) Tj 0 0 0 rg (    Some) Tj 0 0 0 rg (\() Tj 0 0 0 rg (score) Tj 0 0 0 rg (\)) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg ( score) Tj 0 0 0 rg () Tj T* 12 TL (5   ) Tj 0 0 0 rg (    None) Tj 0 0 0 rg ( =>) Tj 0 0 0 rg () Tj T* 12 TL (6   ) Tj 0 0 0 rg (                 ) Tj T* 12 TL (7   ) Tj 0 0 0 rg (                          ) Tj T* 12 TL (8   ) Tj 0 0 0 rg (                                   ) Tj T* 12 TL (9   ) Tj 0 0 0 rg (                                                      ) Tj T* 12 TL (10  ) Tj 0 0 0 rg (          ) Tj T* 12 TL (11  ) Tj 1 0 1 rg (      0) Tj 0 0 0 rg (                 ) Tj T* 12 TL (12  ) Tj 0 0 0 rg (  }) Tj 0 0 0 rg () Tj T* 12 TL (13  ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* 12 TL (14  ) Tj 0 0 0 rg () Tj T* 12 TL (15  ) Tj 0 0 0 rg (    ) Tj T* 12 TL (16  ) Tj 0 0 1 rg (test) Tj 1 0 0 rg ( "safe_key_access") Tj 0 0 0 rg ( {) Tj 0 0 0 rg () Tj T* 12 TL (17  ) Tj 0 0 0 rg (                                                          ) Tj T* 12 TL (18  ) Tj 0 0 1 rg (  let) Tj 0 0 0 rg ( scores) Tj 0 0 0 rg ( =) Tj 0 0 0 rg ( @sorted_map) Tj 0 0 0 rg (.from_array) Tj 0 0 0 rg (\() Tj 0 0 0 rg ([) Tj 0 0 0 rg (\() Tj 1 0 1 rg (1001) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 85) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (1002) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 92) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 0 0 0 rg ( \() Tj 1 0 1 rg (1003) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 78) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (]) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (19  ) Tj 0 0 0 rg () Tj T* 12 TL (20  ) Tj 0 0 0 rg (                           ) Tj T* 12 TL (21  ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (get_score) Tj 0 0 0 rg (\() Tj 0 0 0 rg (scores) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 1001) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 85) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (22  ) Tj 0 0 0 rg () Tj T* 12 TL (23  ) Tj 0 0 0 rg (                                                           ) Tj T* 12 TL (24  ) Tj 0 0 0 rg (  assert_eq) Tj 0 0 0 rg (\() Tj 0 0 0 rg (get_score) Tj 0 0 0 rg (\() Tj 0 0 0 rg (scores) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 9999) Tj 0 0 0 rg (\)) Tj 0 0 0 rg (,) Tj 1 0 1 rg ( 0) Tj 0 0 0 rg (\)) Tj 0 0 0 rg () Tj T* 12 TL (25  ) Tj 0 0 0 rg (}) Tj 0 0 0 rg () Tj T* T* 12 TL T* /F0 20 Tf (Implementation Notes) Tj 20 TL T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (The SortedMap is implemented as an AVL tree, a self-balancing binary search tree) Tj T* (. After insertions and deletions, the tree automatically rebalances to maintain ) Tj T* (O\(log n\) search, insertion, and deletion times.) Tj T* 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Key properties of the AVL tree implementation:) Tj T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Each node stores a balance factor \(height difference between left and right sub) Tj T* (trees\)) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (The balance factor is maintained between -1 and 1 for all nodes) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Rebalancing is done through tree rotations \(single and double rotations\)) Tj T* -10 0 Td 12 TL T* /F0 20 Tf (Comparison with Other Collections) Tj 20 TL T* 12 TL T* /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (@hashmap.T) Tj /F0 12 Tf (: Provides O\(1\) average case lookups but doesn't maintain order; use) Tj T* ( when order doesn't matter) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (@indexmap.T) Tj /F0 12 Tf (: Maintains insertion order but not sorted order; use when insertion ) Tj T* (order matters) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F1 12 Tf (@sorted_map.SortedMap) Tj /F0 12 Tf (: Maintains keys in sorted order; use when you need keys to) Tj T* ( be sorted) Tj T* -10 0 Td 12 TL T* 12 TL /F0 12 Tf /F0 12 Tf (Choose SortedMap when you need:) Tj T* ET
endstream
endobj
16 0 obj
<<
  /Type /Page  
  /Contents 15 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
17 0 obj
<<
  /Length 329
>>
stream
 1 0 0 1 50 770 cm BT /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Key-value pairs sorted by key) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Efficient range queries) Tj T* -10 0 Td /F1 12 Tf 0 TL 10 0 Td (- ) Tj 12 TL /F0 12 Tf /F0 12 Tf (Ordered traversal guarantees) Tj T* -10 0 Td ET
endstream
endobj
18 0 obj
<<
  /Type /Page  
  /Contents 17 0 R  
  /Parent 2 0 R  
  /MediaBox [0 0 595.2765 841.89105]  
  /Resources <<
  /Font <<
  /F0 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Roman
>>  
  /F1 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Bold
>>  
  /F2 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-Italic
>>  
  /F3 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Times-BoldItalic
>>  
  /F4 <<
  /Type /Font  
  /Subtype /Type1  
  /BaseFont /Courier
>>
>>
>>
>>
endobj
xref
0 19
0000000000 65535 f 
0000000055 00000 n
0000000114 00000 n
0000000877 00000 n
0000000521 00000 n
0000003746 00000 n
0000000521 00000 n
0000005876 00000 n
0000000521 00000 n
0000006846 00000 n
0000000522 00000 n
0000008692 00000 n
0000000523 00000 n
0000006108 00000 n
0000000523 00000 n
0000004576 00000 n
0000000523 00000 n
0000000383 00000 n
0000000523 00000 n
trailer
<<
  /Size 5  
  /Root 1 0 R
>>
startxref
41905
%%EOF
